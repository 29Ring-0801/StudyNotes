

# JAVA进阶手册

## 第一部分：前端知识

框架:Vue,Bootstrap,

### 1、HTML:超文本标记语言

#### 1、html页面基本组成

```html
<!-- 基本页面 shift+1 -->
<!-- 注释:Ctrl+/ -->
<!DOCTYPE html><!--document Type html 表示符合HTML5标准的文档类型结构-->
<html lang="en"><!--表示语言是英语-->
<!--以下是头部-->
<head>
    <!--设置字符编码UTF-8支持中文,浏览器默认支持iso-8859-1-->
    <meta charset="UTF-8">
    <!-- 通过不同设备访问显示不同的效果--响应式 -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 页面的标题 -->
    <title>MyFirstHTML</title>
    <!-- css和js -->
    <link rel="stylesheet" href=""/>	
 	<script src=""/>
</head>
<!-- 以下是书写页面代码的地方 -->
<body>
</body>
</html>
```

#### 2、常见标签及其属性(h,p,span,marquee,audio)

```html
	<!-- 便签/元素:
        单标签:<标签名>或者<标签名/> 没有内容区域
        双标签:<标签名>内容区域</标签名>
    -->
	<!-- 标题标签:h1-h6 -->	
    <h6>数字越大字体越小,会有加粗的效果,会自动换行,有行间距</h6>
	<!-- p 标签:-->	
	<p>p 标签:段落标签,会自动换行,有行间距</p>
    <!-- br 标签:换行标签 -->
    <span><b>span标签:空标签,不会自动换行,没有行间距</b></span><br>
    <span><i><u>span标签为什么不能居中?</u></i></span>

    <!-- hr 标签:分割线标签 -->
    <hr color="green" size="10px">
    <!-- 标签的属性: 
        居中:align="center" span标签不能居中?因为内容区域随着内容大小变换
        左对齐:align="left"
        右对齐:align="right"
        颜色:color="颜色英文"
        大小粗细:size=""
    -->
    <!-- 属性标签: 
        b标签:加粗<b></b>
        i标签:斜体<i></i>
        u标签:下划线<u></u>
	    上标:<sub>
		下标:<sup>
     -->
	<!-- 特殊符号: 
         空格:&nbsp;
		人明币:&yen
		版权:&copy
		注册上标:&reg
     -->
    <!-- 移动标签:marquee
        设置属性:滚动方向:direction="right/left"  
    -->
    <marquee direction="right">我来了哦!</marquee>
    <marquee direction="left">我也来了哦!</marquee>
    <!-- 音频标签:audio
        属性:src--指向要导入音乐的路径/地址
            controls--播放组件的控件(不需要给值)
            loop:循环播放(不需要给值)
            autoplay:自动播放(不需要给值)
    -->
    <audio src="./audio/董敏 - 西海情歌.mp3" controls loop autoplay></audio>
```

#### 3、常见标签及其属性(ul-li,ol-li,img,a,form,input)

```html
<!-- 1.无序列表(ul--li),type="none"取消行前默认小圆点 "circle":空心圆,"square":矩形-->
    <ul type="none">
        <li>无序列表第一行</li>
        <li>无序列表第二行</li>
        <li>无序列表第三行</li>
    </ul>
<!-- 2.有序列表(ol--li),start="3"表示从3开始,type="A"顺序的类型-->
    <ol start="3" type="A">
        <li>有序列表第一行</li>
        <li>有序列表第二行</li>
        <li>有序列表第三行</li>
    </ol>
    <hr>
    <!-- 图片img标签:src="":文件路径,alt="":文件打开失败的提示信息, -->
    <!-- width=""height="":设置图片规格,title="":鼠标放入给的提示信息 -->
    <img src="../作业/1.png" alt="文件打开失败的提示信息" width="300px" height="300px" title="这是我老婆">
    <hr>
    <!-- a标签:超链接标签 
        href="":代表跳转链接 href="#"表示回到最顶部。
        target="":设置跳转的方式,默认_self在当前页面打开
                    _blank:在新开一个页面打开
        title="":鼠标放入给的提示信息-->
    <a href="https://www.baidu.com" target="_blank" title="花花">百度一下</a>
    <hr>
    <!-- input输入框: 
        	type:
				text:文本输入框     属性placeholder:输入框提示   maxlength :设置字段最大数
				password:密码输入框    属性required:设置字段为必填项
            	 radio:单选框(name要相同才是单选)
            	 checkbox:多选框
				file:上传文件 accept设置上传文件类型
				time、date:时间选择
             	 button:按钮(可以是属性,也可以是一个双标签<button></button>)
             	 submit:提交按钮(要设置提交的区域,所以一般在form表单中使用)
             	 reset:重置按钮(要设置重置的区域,所以一般在form表单中使用)
				select-option:下拉框    selected:默认选中
				<p>账号:<input type="text" required pattern="[a-z0-9]">:required代表该字段不能为空,pattern:规定输入的格式,内容为正则表达式
				outline-color:red 设置点击后边框颜色
    -->
    <!-- form表单:
        action="":数据提交到的地方
        method="":数据提交的方式,默认是get;
     -->
    <form action="" method="">
        <p>账号:<input type="text" required></p>
        <p>密码:<input type="password"></p>
        <p>性别:
            <input type="radio" name="sex">男
            <input type="radio" name="sex">女 
        </p>
        <p>爱好:
            <input type="checkbox" name="hobby">篮球
            <input type="checkbox" name="hobby">足球
            <input type="checkbox" name="hobby">排球
        </p>
        <p>头像:
            <input type="file">
        </p>
        <p>生日:
            <input type="date">
        </p>
        <p>
            按钮:
            <input type="button" value="登录">
            <button>注册</button>
            <input type="submit" value="提交">
            <input type="reset" value="重置">
        </p>
    </form>

```

#### 4、常见标签及其属性(table,select)

```html
	<!-- table表格:	table>tr*2>td*3(快捷生成两行三列)
        tr:代表一行;td:代表一个单元格
        属性:
            border:边框
            bgcolor:表格背景色
            cellspacing:设置单元格外边距
            cellpadding:设置单元格内边距
            colspan:设置当前单元格占的列数
            rowspan:设置当前单元格占的行数
		   align:内容对齐方式
		   valign : 设置单元格里面的上下排版
     -->
    <table border="1" bgcolor="hotpink" cellspacing="10px" cellpadding="10px">
        <tr>
            <th colspan="3">一</th>
            <!-- <th>二</th>
            <th>三</th> -->
        </tr>
        <tr>
            <td rowspan="2">1</td>
            <td>2</td>
            <td>3</td>
        </tr>
        <tr>
            <td>2</td>
            <td>3</td>
        </tr>
    </table>
<!-- select下拉框:
	下拉列表: select
	下拉列表选项: option  属性selected : 默认选项
     -->
<select>
	<option>武汉</option>
	<option selected>广州</option>
	<option>深圳</option>
	<option>上海</option>
</select>
```



#### 5、标签的分类及转换

**标签分类:**

​		行内标签:一个标签和一个便签相继出现,在同一行显示,不可以设置宽高,不会自动换行(span...)

​		行内块级标签:一个标签和一个便签相继出现,在同一行显示,可以设置宽高,不会自动换行(img..)

​    	块级标签:一个标签写出后,不管是否还有其他内容,都会'独占一行'可以设置宽高(p div...)

 **标签转换 display** 

​    	标签转换为块级元素  display:block

​		标签转换为行内块标签/元素 display:inline-block

​    	便签转换为行内标签 display:inline

​    	 隐藏 display:none

### 2、CSS:层叠样式表

#### 命名建议

>wrap ------用于最外层
>
>header----用于头部
>
>main-------用于主体内容
>
>main-left--左侧布局
>
>main-right-右侧布局
>
>nav----------网页菜单导航条
>
>content-----网页中部主体
>
>footer--------底部
>
>

#### **1、css写入样式分类**

```html
  	<style>
        /* 标签选择器 对所有的改标签设置属性*/
        p{
            color: indigo;
            font-size: 15px;
        }
    </style>
    <!-- 外部样式 -->
    <link rel="stylesheet" href="./index.css">
<body>
    <!-- css写入样式分类:
        1.方式一内联样式: <标签名 style="样式名:样式值"></标签名>
        2.方式二内部样式:
            <style>
                标签选择器{
                    属性:属性值;
                }
                .class名(class选择器){
                    class不唯一
                }
                #id名(id选择器){
                    id是唯一的
                }
                伪类选择器:hover 悬停
                选择器:hover{
                    悬停之后产生的效果
                }
            </style>
        3.方式三外部样式:单独写在外部的以.css结尾的文件
                      通过<link rel="stylesheet" href="./index.css">引入css文件
					
     -->
    <p style="color: hotpink;font-size: 30px;">不再是二十出头</p>
    <p class="class_1">年少已不是理由</p>
    <p id="id_1">屋外是大厦高楼</p>
    <p class="class_1">屋内是父母眼眸</p>
</body>
```

#### 2、选择器的分类及使用

``` css
/* id选择器优先级最高>class选择器>标签选择器 */
/* 1.id选择器: id是唯一的 */
#id_1{
    font-size: 40px;
    color: rgb(238, 235, 51);
}
/* 2.class选择器:多个class选择器中间用空格隔开class="class_1 class_2" */
.class_1{
    font-size: 30px;
    color: rgb(221, 17, 17);
}
/* 3.标签选择器 */
p{
    color: rgb(80, 201, 64);
    font-size: 5px;
}
/* 4.通配选择器:* */
*{
    color: rgb(80, 201, 64);
    font-size: 5px;
}
/* 5.分组选择器 */
p,span,h5{      }
/* 子代和后代的区别:子代只指父子,后代包括子代 */
<ul class="ul_one" id="id_one">
       <li class="li_one">
           <span>第一个span</span>
		  <span>第一个span</span>
		  <span>第一个span</span>
       </li>
       <li>
           <span>第二个span</span>
       </li>
       <li>
		  <span>第三个span</span>
	  </li>
       <span>第四个span</span>
</ul>
/* 6.后代选择器:用空格 */
.ul_one span{	作用于ul中所有的span	}
/* 7.子代选择器:用'>' */
#id_one>span{	只作用于ul中的第四个span	}
ul>span{	只作用于ul中的第四个span	}
#id_one>li>span{	只作用于ul中的第一、第二、第三个span	}
ul>li>span{	只作用于ul中的第一、第二、第三个span	}
/* 8.兄弟选择器:用'+',对当前标签的同级的下一个标签进行设置*/
.li_one+li>span{	只作用于第二个span	}
/* 9.伪类选择器:hover 悬停 */
.class_1:hover{
    font-size: 60px;
    color: rgb(88, 4, 223);
}
.li_one>:first-child{	对当前标签的第一个子元素进行操作	}
.li_one>:last-child{	对当前标签的最后一个子元素进行操作	}
.li_one>:nth-child(n){	对当前标签的第n个子元素进行操作	}
```

#### 3、常见的CSS样式

```css
 <style>
        p{
            /* 设置字体大小 */
            font-size: 20px;
            /* 设置字体样式 */
            font-family:'楷体';
            /* 设置字体粗细 bold加粗*/
            font-weight:bold;
            /* 首行缩进 px */
            text-indent: 50px;
            /* 设置颜色 */
            color: blueviolet;
            /* 设置文本对齐方式 center居中 left左对齐 right右对齐*/
            text-align: center;
            /* line-height:设置垂直居中:只需要把行高设置为当前'容器'的高度即可垂直居中 */
            height: 50px;
            border: 1px solid red;/*边框*/
            line-height: 50px;
        }
		 /* 背景样式 */
        .class1{
            border: 1px solid red;
            /* 背景图片的大小随盒子大小变化 */
            width: 200px;
            height: 200px;
            
            /* 设置背景图片 */
            background-image: url(./图片素材/manor-1.jpg);
            
            /* 设置背景平不平铺:no-repeat不平铺,repeat-x横坐标平铺,repeat-y纵坐标平铺 */
            background-repeat:no-repeat
                
            /* 设置背景图片大小 background-size: x轴 y轴;*/
            background-size: 100% 100%;
            
            /* 设置背景位置 background-position:100px 200px */
            background-position:100px 200px;
            
            /* 设置背景颜色 */           
            background-color: rgb(37, 231, 12);
            
            /* 设置透明 */
            opacity: 0.5;
            
            /* 渐变颜色 background-image: linear-gradient(方向,开始颜色,结束颜色); */
            /* to top right:左下到右上;to top下倒上; */
            background-image: linear-gradient(to right,red,pink);
            从下到上：0deg
		   	background-image: linear-gradient(0deg, pink, yellow);
            从左到右：90deg
            background-image: linear-gradient(90deg, pink, yellow);
            从左下到右上：45deg
            background-image: linear-gradient(45deg, pink, yellow);
            
            /* 文字阴影text-shadow:阴影颜色 x轴偏移量 y轴偏移量 阴影模糊半径 ; */
            text-shadow: blue 5px 15px 1px;
            
            /* 行内元素对齐方式:middle垂直居中,top居上对齐,bottom居下对齐(默认) */
            img{/*效果如下*/
            height: 50px;
            /*文本和图片对齐的方式*/
            vertical-align: middle;
            }
            
            /* 过渡: transition:过渡属性 过渡完成时间 过渡类型 过渡延时; */
            /* 过渡类型:linear线性过渡,ease:平滑过渡,ease-in:由慢到快,ease-out:由快到慢,ease-in-out:慢到快到慢 */
            transition:width 3s linear 1s;
       	 }
       	 /* 设置整个页面的背景图片 */
       	 body{
            /* 宽度100%:根据页面的宽度自适应 */
            width: 100%;
            /*  vh:视图高度
                100%
            */
            height: 100vh;
            background-image: url(./图片素材/manor-1.jpg);
            background-size: 100% 100%;
       	 }
   </style>
```

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\css垂直居中.png)

#### 4、div盒子模型



```html
<style>
        /* *通配选择器:修改浏览器默认边距为0 */
        *{
            padding: 0;
            margin: 0;
        }
        .div_one{
            width: 200px;
            height: 20px;
            background-color: rgb(9, 146, 82);
            /* 设置外边距 margin*/
            margin:30px 30px 30px 30px;/*分别为上右下左*/
            margin:30px 40px 50px;/*上30px;左右40px;下50px*/
            margin:30px 40px;/*上下30px;左右40px*/
            margin-bottom: 20px;/* 下边距 */
            margin-top: 20px;/* 上边距 */
            /* auto:自适应 */
            margin:0 auto;/* 盒子水平居中方法一 */
            
            /* 用相对位置设置盒子垂直居中:50%父级元素的高度 - 当前盒子一半的高度  */
    		position: relative;
    		top: calc(50% - 230px);/* 父级盒子一定要设置宽高,比如body:vw vh */
             left: calc(50% - 230px);/* 盒子水平居中方法二 */
            
            /* 设置内边距:padding */
            padding:20px 20px 20px 20px;/*可以给四个值;上右下左*/
            /*box-sizing: content-box; 标准盒子(默认):盒子大小要算上外边距*/
            /*box-sizing: border-box; 怪异盒子:盒子大小固定,边距向内占*/ 
            /* 设置边框:border */
            border: 5px solid red;/* 粗细 样式 颜色 */
            border-style:solid;	/*可以给四个值;上右下左(solid实线;double双线;dotted点状线;dashed虚线)*/
            border-color:red;/*可以给四个值;上右下左*/
            border-width:20px;/*可以给四个值;上右下左*/
            /* 设置盒子边角弧度:borderr-radius: 20px; */
            border-radius: 20px;
        }
        .div_two{
            width: 200px;
            height: 20px;
            background-color: rgb(81, 14, 170);
        }
        input{
            margin-top: 10px;
            margin-left: 50px;
            width: 200px;
            height: 50px;
            /* 设置内边距 padding */
            padding-left: 50px;
        }
    </style>
</head>
<body>
    <!-- 盒子模型是一种思想 -->
    <!-- div盒子:万能的div
         内边距:padding
         边框:border
         外边距:margin -->
    <div class="div_one"></div>
    <div class="div_two"></div>
    <input type="text">
</body>
```

 #### 5、浮动 float

>浮动:用来格式化内容,可以脱离文档流,转换为浮动的行内块标签

``` html
	<style>
        div{
            width: 200px;
            height: 200px;
        }
        .one{
            /* float:right(浮动到容器右边);	
            		left(浮动到容器左边);
            		none(不浮动) */
            float: left; 
            background-color: pink;
        }
        .two{
            background-color: chartreuse;
        }
    </style>
</head>
<body>
    <div class="one"></div>
    <div class="two"></div>
</body>
```

#### 6、定位:position(会脱离文档流)



``` html
<style> 
.class{
   /* 1.static为默认的,不定位 */
    position: static;
    /* 2.相对定位:relative,相对本身不定位时的位置进行偏移 */
    position: relative;
    top: 20px;
    left: 20px;
    /* 3.固定定位:fixed,根据视图进行定位 */
    position: fixed;
    bottom:20px;
    right:20px;
    /* 4.绝对地位:absolute,相对最近的父级元素进行定位,前提是父级设置了position属性(包括static),如果没有设置,就一直往上找,找到设置了position属性的最近的祖先元素,如果都没有就根据body进行定位 */
    position: absolute;
    top: 20px;
    left: 20px;
    
    /* 5.设置优先级(前提是需要定位),默认值为1 */
    z-index: 1;
    }
</style>  
```



#### 7、常用CSS动画和自定义动画

``` html
<style>
	div:hover{
            /* 动画transform: 1.平移属性:*/
            /* translateX() 沿X轴平移(默认从左到右)*/
            transform: translateX(100px);
            /* translateY() 沿Y轴平移(默认从上到下) */
            transform: translateY(100px);
            /* translate(100px,100px); 沿斜线移 */
            transform: translate(100px,100px);
        
            /* 动画transform: 2.放大,缩小属性:默认是1*/
            transform: scale(2);
            transform: scaleX(0.2);
        
		   /* 动画transform: 3.旋转属性 单位deg*/
            /* rotateX(180deg);沿X轴旋转180度 */
            transform: rotateX(180deg);
            /* rotateY(180deg);沿Y轴旋转180度 */
            transform: rotateY(180deg);
            /* rotate(180deg);rotateZ(180deg);沿Z轴旋转180度 */
            transform: rotate(180deg);
            transform: rotateZ(180deg);

		   /* 设置所有动画效果采取过渡方式 */
            transition: all 1s linear;
        }
   </style>
```

**下面是自定义动画和应用自定义动画的步骤(重要)**

``` html
    <style>
        div{
            width: 200px;
            height: 200px;
        }
        body{
            width: 100vw;
            height: 100vh;
        }
        .content_1{
            background-color: rgb(214, 38, 38);
            position: relative;
            top: calc(50% - 100px);
            left: calc(50% - 100px);
        }
        div:hover{
            /* 应用自定义动画animation: 动画名 执行时间 [动画类型] [等待时间] [执行次数]; */
            /* infinite:一直执行该动画 */
            animation: xuanzhuan 2s linear infinite;
            transition: all 1s linear;
        }
        /* 自定义动画 */
        @keyframes xuanzhuan {
            /* 设置动画初始状态,也可以用百分数形式 */
            from{
                transform: rotate(0deg);
            }
            /* 设置动画结束状态 */
            to{
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <div class="content_1"></div>
</body>
```

#### 8、Flex布局(弹性布局)

>弹性布局,为盒子模型提供最大的灵活度,当使用flex布局的时候,子元素float,clear,vertical-align属性都会失效
>
>采用flex布局的元素,称为flex容器,里面的所有子元素都是flex元素,以下是flex容器的常用属性:
>
>flex-direction:设置主轴方向(X轴:row  Y轴:column)
>
>justify-content:设置主轴上子元素排列的方式
>
>flex-warp:设置子元素是否换行
>
>align-content:设置侧轴上的子元素的排列方式(多行)
>
>align-items:设置侧轴上的子元素的排列方式(单行)

``` html
<div class="wrap">
        <div class="one">1</div>
        <div class="one">2</div>
        <div class="one">3</div>
</div>
<main>
        <span>1</span>
        <span>2</span>
        <span>3</span>
 </main>
```

```css
.wrap{
    width: 500px;
    height: 500px;
    border: 1px solid red;
    /* 设置weiflex布局 */
    display: flex;
    
    /* 设置X轴为主轴(默认) */
        /* row:从左到右   row-reverse:从右到左*/
        flex-direction: row;
        flex-direction: row-reverse;
        /* 设置Y轴为主轴 */
        /* column:从上到下  column-reverse:从下到上 */
        flex-direction: column;
        flex-direction: column-reverse;
    
    /* 设置主轴上子元素的排列方式 */
        /* center:居中 */
        justify-content: center;
        /* 两边留白，中间平分 */
        justify-content: space-around;
        /* 两边紧贴，中间平分 */
        justify-content: space-between;
        /* 平分空白 */
        justify-content: space-evenly;
    
    /* 设置元素是否换行wrap换，nowrap不换（默认） */
    	flex-wrap: nowrap;
    	flex-wrap: wrap;
    
    /* 设置侧轴上子元素排列方式 */
        /* 单行子元素 center居中 */
        	align-items: center;
        /* 多行子元素 */
            /* 两边留白，中间平分 */
            align-content: space-around;
            /* 两边紧贴，中间平分 */
            align-content: space-between;
}
.one{
    width: 100px;
    height: 100px;
    background-color: rgb(39, 180, 46);
}


main{
    width: 80%;
    height: 500px;
    border: 1px solid red;
    margin: 50px auto;
    /* 设置flex布局 */
    display: flex;
    flex-direction: row;
    justify-content: space-between;
}
main>span{
    border: 1px solid blue;
}
main>:first-child{
    width: 50px;
    height: 50px;
}
main>:last-child{
    width: 50px;
    height: 50px;
    /* 单独对一个元素进行操作 */
    align-self: flex-end;
}
main>:nth-child(2){
    /* 重点:设置子元素占一份 */
    /* flex属性定义子项目分配剩余空间,用flex来表示占多少份 */
    flex: 1;
}
```



#### 9、响应式布局

>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置,从而适配不同设备

| 设备划分               | 尺寸区间      |
| ---------------------- | ------------- |
| 超小屏幕(手机)         | <768px        |
| 小屏设备(平板)         | [768px,992px) |
| 中等屏幕(桌面显示器)   | [992px,1200)  |
| 宽屏设备(大桌面显示屏) | >=1200px      |

``` html
<style>
        @media screen and (max-width:768px){
            body{
                background-color: rgb(230, 36, 11);
            }
        }
        @media screen and (max-width:992px) and (min-width:768px) {
            body{
                background-color: rgb(161, 214, 16);
            }
        }
        @media screen and (max-width:1200px) and (min-width:992px) {
            body{
                background-color: rgb(21, 150, 209);
            }
        }
        @media screen and (min-width:1200px) {
            body{
                background-color: rgb(201, 10, 159);
            }
        }

   </style>
```



### 3、JavaScript

>完整JavaScript包含三个部分:
>
>1.  ECMAScript:描述该语言的语法和基本对象 
>2. 浏览器对象模型**(BOM)**:描述与浏览器进行交互的方法和接口
>3. 文本对象模型**(DOM)**:描述处理网页内容的方法和接口 

#### 1、ECMAScript

##### 1.1.JS的引入方式

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title></title>
        <!--方法一:直接写入到Script标签中-->
        <script>
            //警告
            alert("你好呀！");
            //确认
            confirm("你要做我男朋友吗？");
            //输入
            prompt("请输入你觉得最好看的女人！");
        </script>
        <!--方法二:引入外部js（my1.js）-->
        <script src="./js/my1.js"/>
    </head>
    <body>
        <!--方法三:直接写在标签的内部，不推荐-->
        <a href="javascript:;alert('1')">点击一下</a>
    </body>
</html>
```

##### 1.2.JavaScript变量

>var 是全局变量
>let 局部变量

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script>
            //变量的声明
            //java的写法: 变量类型 变量名=变量值;变量值与变量的类型匹配
            width=100;
            //输出到控制台 sout
            console.log(width);
            //可以通过typeof去检测变量的类型 number:100是个数字
            console.log("通过typeof检测width类型1："+typeof(width));
            width='果果';
            console.log(width);
            console.log("通过typeof检测width类型2："+typeof(width));
            width=true;
            console.log(width);
            console.log("通过typeof检测width类型3："+typeof(width));
            //如果定义的时候没有给变量类型，那么是根据值做类型
            var a=13;
            console.log(a);
            console.log("检测var a=13中a的类型"+typeof(a));
            //建议写法:
            //不用去强调变量的类型
            //var 是全局变量
            //let 局部变量
            {
            	var num=520;
            }
            console.log(num);//
            {
            	let sum=1314;
            }
            //console.log(sum);//let局部变量，作用范围受定义局限
            //赋值
            let b;
            //undefined表示定义没有赋值(初始化),也是js一种数据类型
            console.log(b);
        </script>
    </head>
    <body>
    </body>
</html>
```

##### 1.3.JavaScript数据类型

###### 1.3.1.undefined

```html
<script>
    //定义了一个变量没有初始化
    let b;
    console.log(b);//undefined 表示没有赋值,这也是一种js数据类型
</script>
```

###### 1.3.2.number

```html
<script>
	var num1=1;
    var num2=1.34;
    //检测变量的类型
    console.log(typeof(num1));//number
    console.log(typeof(num2));//number
    //可以使用isNaN去检测一个变量是否是非数字
    //isNaN: is not a number-判断变量是否是非数字
    console.log("判断num1:"+isNaN(num1));//检测num1是不是非数字，(false)
    console.log("判断true:"+isNaN(true));//true==1(false)
    console.log("判断'果果':"+isNaN('果果'));//
</script>
```

###### 1.3.3.string	

```html
<script>
    let str1="锄禾日当午";
    let str2='汗滴禾下土';
    //根据下标找字符
    console.log("charAt:"+str1.charAt(2));//日
    //根据字符找下标
    console.log("indexOf:"+str2.indexOf('下'));//3
    //字符串的截取
    console.log("substring:"+str2.substring(0,3));//汗滴禾
    //字符串拆分
    let str3="武汉-随州-宜昌-荆门";
    let strs=str3.split("-");
    console.log(strs);
</script>
```

###### 1.3.4.boolean

```
true/false
```

###### 1.3.5.null

```html
let b=null;//null值与undefined是一样的
```

###### 1.3.6.数组

```html
<script>
	//数组的定义
    var arr1=new Array();//方法一
    arr1[0]=11;
    arr1[1]=11;
    console.log(typeof(arr1));//object
    var arr2=new Array(1,'果果',true,null);//方法二
    console.log(typeof(arr2));//object
    console.log("arr2初始长度:"+arr2.length);
    console.log(arr2);
    //变长的数组！！!
    arr2[4]=520;//只要赋值了，数组就会扩容
    console.log("arr2第二次长度:"+arr2.length);
    console.log(arr2);
    console.log(arr1);
    //数组中一些常见的方法
        //1.在js数组的末尾添加一个元素:push
        arr1.push("通过push添加的元素")
        console.log(arr1);
        //2.删除js的末尾元素：pop
        let str=arr2.pop();
        console.log("arr2的末尾元素是："+str);
        console.log("arr2被删除末尾元素后:"+arr2)
        //3.在js数组首项添加元素:unshift
        arr2.unshift("首项添加的元素");
        console.log(arr2);
        //4.在js数组首项删除元素:shift
        let str2=arr1.shift();
        console.log("arr1首项删除的是"+str2);
        //5.排序sort()
        //6.join：将数组的所有元素放入一个字符串，参数是链接的符号
        let str3=arr2.join("-");//首项添加的元素-果果-1-true
        console.log(str3);
</script>
```

###### 1.3.7.Date日期

```html
<script>
    //方法一
    var now1=new Date();
    console.log(now1);//表示当前的时间
    //方法二
    var date=new Date('2022-4-20 22:01:00');
    console.log(date);//设置任意时间
    //方法三
    var date1=new Date(36000);
    console.log(date1);//设置任意时间
        //1.获取时间毫秒数
        console.log("获取毫秒数:"+now1.getTime());
        //code?毫秒数
        //2.获取年
        console.log("获取年:"+now1.getFullYear());
        //3.获取月
        console.log("获取月:"+(now1.getMonth()+1));
        //4.获取日
        console.log("获取日:"+now1.getDate());
        //5.获取时
        console.log("获取时:"+now1.getHours());
        //6.获取分
        console.log("获取分:"+now1.getMinutes());
        //7.获取秒
        console.log("获取秒:"+now1.getSeconds());
        //8周几
        console.log("周几"+now1.getDay());
</script>
```

##### 1.4.JavaScript函数

```html
<script>
    //1.没有参数函数,
    function f1(){
        console.log('函数f1运行');
        return '果果';//如果需要返回直接使用return即可
    }
    
    let name=f1();
    console.log(name);
    //2.有参数函数
    function f2(name,age){
    	console.log('你好,我叫'+name+'今年'+age);
    }
    f2('石头',18);
    //3.第三种
    let mytest=function(){
    	console.log('第三种函数的创建');
    }
</script>

```

##### 1.5.正则表达式对象RegExp

>可以通过以下两种方式构建:

```html
<script>
    //构造器
    var pattern=new RegExp('word','ig');
    //i:表示不区分大小写匹配
    //m:表示多行匹配
    //g:表示全局匹配
    //字面量
    //var reg=/^\d{3,6}$/ig;
    var reg=/^\d{3,6}$/;
</script>
```

>一般通过test来进行检查字符串

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title></title>
    <script>
        //构造器
        var pattern=new RegExp('word');
        //test方法可以检测传入的字符串是否满足正则表达式
        console.log(pattern.test('word'));
        //i:表示不区分大小写匹配
        //m:表示多行匹配
        //g:表示全局匹配
        //字面量
        //var reg=/^\d{3,6}$/ig;
        var reg=/^\d{3,6}$/;//3-6个数字
        console.log(reg.test('333'))
        function f1(obj){
            let name=obj.value;
            var reg1=/^[A-Za-z]{6,10}$/;
            if(!reg1.test(name)){
                //可以提示输入的用户名不合法
                document.getElementById("s1").innerHTML="输入的用户名不合法!!";
            }
        }
    </script>
</head>
<body>
    用户名:<input type="text" name="" id="i1" onblur="f1(this)"/>
    <span id="s1"></span>
</body>
</html>

```

##### 1.6.Math

| 方法     | 说明                | 案例                                            |      |
| -------- | ------------------- | ----------------------------------------------- | ---- |
| ceil()   | 数据向上取整        | Math.ceil(25.5)返回26,Math.ceil(-25.5)返回-25   |      |
| floor()  | 数据向下取整        | Math.floor(25.5)返回25,Math.floor(-25.5)返回-26 |      |
| round()  | 四舍五入最近的数    | Math.round(25.5)返回26,Math.round(-25.5)返回-25 |      |
| random() | 返回0-1之间的随机数 | Math.random()                                   |      |

##### 1.7.创建对象

>方法一:基于object对象的方式来创建对象

```html
<script>
//创建对象
//语法规则：var 对象名=new Object();
var bf1=new Object();
//给对象赋值属性
//语法规则:对象名.属性名=属性值;
bf1.name='朱亚文';
bf1.age=30;
//给对象添加函数
//对象名.函数名=function(){}
bf1.sleep=function(){
	console.log(this.name+'正在和果果睡觉....')
}
//通过对象调用函数
bf1.sleep();
</script>
```

>方法二：使用字面量赋值方式创建对象

```html
语法规则：
var 对象名={
属性名1:属性值1，
属性名2:属性值2，
.....
属性名n:属性值n,
函数名1:function(){}，
....
函数名n:function(){}
};

var bf2={
    name:'彭于晏',
    age:32,
    money:'1000亿',
    cooking:function(){
    	console.log(this.name+'正在给果果做饭!');
    }
};
```

#### 2、BOM

>BOM(Browser Object Model ) :浏览器对象模型,由多个对象构成,其中window对象是BOM的顶层对象，其他对象都是该对象的子对象 
>
>1.  window对象，顶层对象，其他对象都是window对象的属性 
>2. document对象,   文档对象 
>3. location对象，浏览器当前url信息
>4.  navigator对象，浏览器本身信息 
>5. screen对象，客户端屏幕信息 
>6. history对象，浏览器访问历史信息

##### 2.1.窗口加载事件load

```html
1.window.onload是页面(窗口)的加载事件,当文档内容完全加载完成会触发该事件，
```

##### 2.2.定时器

> window.setTimeout(调用函数，延迟的毫秒数)：用于定义一个定时器，该定时器在定时到期后执行函数 
>
>window.clearTimeout(定时器执行返回标志值)

```html
<script>
    //当三秒后，执行函数实现跳转到百度页面
    // window.setTimeout(function(){
    // //url信息。
    // window.location.href="https://www.baidu.com/";
    // },3000);
    //window是全局内置对象，可以省略
    function f1(){
    	alert('这是我的延迟函数');
    }
    let name=setTimeout(f1,3000);
    let num=setTimeout(function(){
        //一秒钟后，清除了第一个定时器，没有第一个定时器是没有执行的！
        clearTimeout(name);
    },1000)
    console.log(name+"-"+num);
</script>
```

>window.setInternal(调用函数，间隔的毫秒数)，每隔一段时间调用一次函数 window.clearnternal(定时器执行返回标志值)

```html
<script>
    var seconds;
    //创建定时器，并且将当前定时器返回的标志值存入num1中
    let num1=setInterval(function(){
        //获取当前时间秒数
        let date=new Date();
        seconds=date.getSeconds();
        //输出秒数
        console.log(seconds)
        //判断秒数是否大于40.
        if(seconds>40){
            //如果大于40清除当前定时器
            clearInterval(num1);
        }
        //如果没有大于40该函数每隔一秒钟调用一次
    },1000);
</script>

```

##### 2.3.location对象

| location的对象属性 | 说明                    |
| ------------------ | ----------------------- |
| location.href      | 获取或者设置整个页面url |
| location.host      | 返回主机(域名)          |
| location.port      | 返回端口号，空字符串    |
| location.pathname  | 返回路径                |
| location.search    | 返回参数                |
| location.reload    | 刷新页面                |

```html
<script>
    //location是window的属性
    console.log('url:'+location.href);
    //location.href="";设置url地址，跳转到指定的页面
    console.log('主机:'+location.host);
    console.log('端口:'+location.port);
    console.log('参数:'+location.search);
</script>
```

##### 2.4.history对象

```html
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script>
            //history.back();网页回退
            //history.forward();网页前进
            //history.go(index);网页的前进或者后退，index为正数就是前进index页，反之
        </script>
    </head>
    <body>
        <input type="button" value="前一页" onclick="javascript:;history.back()"/>
        <input type="button" value="后一页" onclick="javascript:;history.forward()" />
        <a href="后一页.html">跳转到后一页</a>
        <input type="button" value="go前一页" onclick="javascript:;history.go(-1)" />
        <input type="button" value="go后一页" onclick="javascript:;history.go(1)"  />
    </body>
</html>
```

#### 3、DOM

>文档对象模型( document object Model) :把浏览器页面的元素当做一个对象来操作,

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\dom.gif)

##### 3.1.选择器

###### 3.1.1.通过id获取元素

```html
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script>
            //创建函数
            function f1(){         
                //获取页面中username 和password标签值
                //1.通过getElementById可以根据id获取页面中元素对象
                //如果id名有重复的情况,永远找到的第一个;如果id没有,则返回null
                let obj1=window.document.getElementById("username");
                let obj2=document.getElementById("password");
                //2.通过.value等可以操作元素的value等属性
                //alert(obj1.value);//访问对象的属性
                obj1.value='果果真美!';
            }
        </script>
    </head>
    <body>
        <!--
            action:当form表单中点击submit触发请求
            method:
                post:请求的提交方式,隐式,请求信息数据不会在url去显示出来
                get:请求的提交方式,显式,请求的信息数据会在utl去显式出来
        -->
        <form >
            username:<input type="text" id="username" /><br>
            name:<input type="text" id="username"><br>
            password:<input type="text" id="password" />
            <input type="submit" value="提交" onclick="f1()" />
        </form>
    </body>
</html>
```

###### 3.1.2.通过class获取元素

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script>
            function f1(){
                //可以同getElementByClassName获取页面中指定类名的所有元素对象
                //返回的是集合类型NodeList
                let obj1=document.getElementsByClassName("c1");
                console.log("obj1长度为:"+obj1.length)
                let obj2=document.getElementsByClassName("c2");
                console.log("obj2长度为:"+obj2.length)
                //如果需要访问集合中的第二个元素,传入下标即可
                console.log("obj2[1]:"+obj2[1].value)
            }
        </script>
    </head>
    <body>
        <input type="button" class="c1" value="阿武" /><br>
        <input type="button" class="c2" value="康康" /><br>
        <input type="button" class="c2" value="凡凡" /><br>
        <input type="button" value="点击测试class选择器" onclick="f1()" />
    </body>
</html>
```

###### 3.1.3.通过标签名获取元素

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
            <script>
            function f1(){
                //通过getElementsByTagName根据指定标签名获取所有的元素对象
                //返回集合类型NodeList
                let objs=document.getElementsByTagName("p");
                console.log(objs);
                console.log(objs.length);
                //获取集合中某个元素，根据下标获取即可
                //可以通过innerText属性获取双标签的文本内容
                console.log(objs[2].innerText);
            }
        </script>
    </head>
    <body>
        <p>锄禾日当午</p>
        <p>谁知盘中餐</p>
        <div>
            <!--双标签中的文本，innertText-->
            <p>疑是地上霜</p>
        </div>
        <input type="button" value="标签选择器测试" onclick="f1()"/>
    </body>
</html>
```

###### 3.1.4.通过name获取元素

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script>
            function f1(){
                //通过getElementsByName根据指定name值获取所有元素对象
                //返回值也是集合类型
                let objs=document.getElementsByName("hz");
                console.log(objs.length);
            }
        </script>
    </head>
    <body>
        <input type="button" value="海子2" name="hz" /><br>
        <input type="button" value="海子1" name="hz" /><br>
        <input type="button" value="测试name选择器" onclick="f1();" />
    </body>
</html>
```



###### 3.1.5.其他选择器

>有些时候需要获取一些比较复杂的标签，可以通过如下两种方式:

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title></title>
        <script>
            function f1(){
                //1.找到所有c2拿到集合中第一个元素
                //2.1先找到d1
                let d1=document.getElementById("d1");
                //2.2通过d1再获得c2
                let c2=d1.getElementsByClassName("c2");
                console.log("c2:"+c2);
            }
        </script>
    </head>
    <body>
        <div id="d1" class="c3">
            <div class="c1">锄禾日当午</div>
            <div class="c2">汗滴禾下土</div>
        </div>
        <div class="c1">床前明月光</div>
        <div class="c2">疑是地上霜</div>
        <input type="button" value="测试其他选择器" onclick="f1()" />
    </body>
</html>
```

```js
//querySelector()可以通过指定选择器，获取元素
//如果找到元素返回一个元素（如果有多个，返回第一个）
//如果没有找到则返回null
let obj=document.querySelector("#d1>.c2")
console.log("通过querySelector:"+obj.innerText)
//querySelectorAll()可以通过指定选择，获取满足的所有元素
//返回一个NodeList集合,如果找到了，则集合中会包含所有的元素
//如果找不到返回一个null的NodeList
let objs=document.querySelectorAll(".c2");

```

##### 3.2.DOM结构

| 标签名 | 第一级               | 第二级      | 第三级  | 第四级 | 第五级      |
| ------ | -------------------- | ----------- | ------- | ------ | ----------- |
| div    | HTMLDivElement       | HTMLElement | Element | Node   | EventTarget |
| p      | HTMLParagraphElement | HTMLElement | Element | Node   | EventTarget |
| input  | HTMLInputElement     | HTMLElement | Element | Node   | EventTarget |

**结论**::所有的元素都继承自Node(第五级先不考虑),可以Node当做所有文档对象的最终的父类

>#### Elemenet(元素)和Node(节点):
>
>1.  在网页中,所有的标签他都是一个元素(Element),同时也是一个节点(Node) 
>
>2.  但是并不是所有的节点(Node)都是元素(Element);(节点:元素/文字/注释/回车)
>
>```html
><div>
>    这是一段文件
>    <!--这是一段注释-->
>    <div>一行div </div>
></div>
>```
>
>上述元素element只有div,但是节点Node包含注释与元素还有回车和文字



##### 3.3.Element常用属性

>###### 1.children属性:获取当前元素下面的子元素 
>
>###### 2.parentElement属性:获取当前元素的父级元素 
>
>###### 3.nextElementSibling属性:获取当前元素的下一个兄弟节点 
>
>###### 4.previousElementSibling属性:获取当前元素的上一个兄弟节点

```html
<script>
    window.onload=function(){
        //1.获取d1的孩子元素对象
        //1.1获取d1这个元素
        let obj1=document.getElementById("d1")
        //1.2获取d1这个元素孩子元素对象
        console.log(obj1.children);
        //2.获取d6的父级元素对象
        //2.1获取d6这个元素
        let obj2=document.getElementById("d6");
        //2.2通过d6获取它的父级元素
        console.log(obj2.parentElement);
        //3.获取果果d3上一个元素(兄/弟)
        //3.1获取d3这个元素对象
        let obj3=document.getElementById("d3");
        //3.2通过d3获取它的上一个元素对象
        console.log("果果师姐是:");
        console.log(obj3.previousElementSibling);
        //3.3通过d3获取它的下一个元素对象
        console.log("果果的师妹:")
        console.log(obj3.nextElementSibling);
    }
</script>
</head>
<body>
    <div id="d1">
        影视巨星
        <div id="d2"> 小泽玛利亚</div>
        <div id="d3">果果</div>
        <div id="d4"> 波多野结衣</div>
    </div>
    <div id="d5">
        日本巨星
        <div id="d6">吉泽明步</div>
    </div>
</body>
```

##### 3.4.innerText和innerHTML

>innerText:获取或者修改标签元素内部的文本内容 
>
>innerHTML:获取或者修改元素内部的标签内容,包含文本和超文本(元素)
>
>value:针对个别input标签,并不是每个element都有这个属性

```js
function f1(){
    //获取d1这个标签元素对象
    let obj=document.getElementById("d1");
    //分别获取d1这个标签元素的innerText和innerHTML
    console.log("获取obj.innerText");
    //获取d1元素的文本内容
    console.log(obj.innerText);
    //修改语法
    //obj.innerText=""
    console.log("获取obj.innerHTML");
    //获取d1元素的标签内容
    console.log(obj.innerHTML);
}
```

##### 3.5.className和classList和style

>1.通过style的属性修改对应的样式 
>
>2.获取对象classname来修改和增加样式 
>
>3.classList属性,返回一个样式的集合
>
>注意:所有的标签的属性都可以当做这个对象的属性
>
>​		输入框的id属性可以当做obj.id 
>
>​		输入框的type属性可以当做obj.type....

```html
<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <title></title>
    <style>
        .c1{
        color: green;
        }
        .c2{
        color: red;
        }
    </style>
    <script>
        //检查用户名
        function checkUsername(){
            //获取用户名元素对象--用户检查用户名输入的内容
            let obj=document.getElementById("username");
            //通过元素对象获取value值
            let username=obj.value;
            //获取用户名后提示标签--用于做提示
            let span=document.getElementById("err-username");
            //使用正则表达式判断username是否合法
            //创建关于用户名的正则表达式对象
            let reg=/^[a-zA-Z0-9]{6,10}$/;
            if(reg.test(username)){
                //表示username满足正则表达式,合法
                span.innerText="用户名可以使用!"
                span.className="c1"
                //span.style.color="green";修改样式方法1
            }else{
                //表示username不满足正则表达式,不合法
                span.innerText="用户名不符合规则!"
                //span.style.color="red";
                span.className="c2"
            }
        }
    </script>
    </head>
    <body>
        <h1>用户注册页面</h1>
        用户名:<input type="text" id="username" />
        	<span id="err-username"></span>
        <br />
        密码: <input type="password" id="pssword" />
        	<span id="err-password"></span>
        <br />
        <input type="button" value="验证用户名" onclick="checkUsername()" />
    </body>
</html>
```

##### 3.6.Attribute方法

>1.获取属性值:getAttribute("属性名"); 
>
>2.设置属性:setAttribute("属性名","属性值") 
>
>3.删除属性:removeAttribute("属性名") 
>
>4.判断是否有次属性:hasAttribute("属性名");

##### 3.7.节点的创建,添加,修改,删除

###### 3.7.1.创建节点

```js
document.createElement("div")
//1.创建元素;有没有指定添加到页面的某个位置?
let obj=document.createElement("div");
obj.innerText="苍#null";
obj.className="c1";
//obj.style.backgroundColor="deeppink";
```

###### 3.7.2.添加节点

```js
1.在元素的"内部"结尾位置插入内容:append();
2.在元素的"内部"开始位置插入内容:prepend();
3.在元素的"后面"添加内容:after();
4.在元素的"前面"添加内容:before();
5.删除当前元素:remove()
删除当前元素的子元素removeChild()
```





### 4、JQuery

#### 1.介绍

>Jquery就是JavaScript库,提供强大的选择器,简洁的API,优雅的链式操作 
>
>核心理念 Write less,Do more (写得少,做得多) 
>
>3个大版本: 
>		1.X:对于很多低版本IE兼容处理
>		2.X:抛弃对IE9以下的版本的兼容性 
>		3.X:就是在2.X的基础上新增一些功能
>
>https://jquery.com/ 官方英文站
>
>https://www.jquery123.com/ :中文站

#### 2.选择器

##### 2.1.基本选择器

| -           | -(单引号双引号都可以) |
| ----------- | --------------------- |
| id选择器    | $("#id")              |
| class选择器 | $(".class")           |
| 标签选择器  | $("标签名")           |

##### 2.2.层级选择器

| -                                                          | -                        |
| ---------------------------------------------------------- | ------------------------ |
| 子代选择器(直接儿子)                                       | $("parent>child")        |
| 后代选择器(所有后代)                                       | $("ancestor descendant") |
| 兄弟选择器(在前面节点之后的兄弟节点及其兄弟节点的后代节点) | $("perv+siblings")       |
| 兄弟选择器(在前面节点之后的兄弟节点)                       | $("perv~siblings")       |

##### 2.3.属性选择器

| -                                                   | -                                   |
| --------------------------------------------------- | ----------------------------------- |
| 选择属性名为attribute,值 等于 value的seletor元素    | $('seletor[attribute = value]')     |
| 选择属性名为attribute,值以value 打头 的seletor元素  | $('seletor[attribute ^= value]')    |
| 选择属性名为attribute,值以value 结尾 的seletor元素  | $('seletor[attribute $= value]')    |
| 选择属性名为attribute,值 包含 value的seletor元素    | $('seletor[attribute *= value]')    |
| 选择有id属性的,并且name属性以value结尾的seletor元素 | $('seletor\[id\]\[name$="value"\]') |

##### 2.4.位置选择器

| -                                | -                     |
| -------------------------------- | --------------------- |
| 获取第一个元素                   | $('selector :first ') |
| 获取最后一个元素                 | $('selector :last ')  |
| 从0开始,获取指定下标的元素       | $('selector :eq(n) ') |
| 从0开始,获取指定下标为偶数的元素 | $('selector :even ')  |
| 从0开始,获取指定下标为奇数的元素 | $('selector :odd ')   |

##### 2.5.表单选择器

| -              | -                        |
| -------------- | ------------------------ |
| 选中所有输入框 | $('selector :input ')    |
| 选中文本框     | $('selector :text ')     |
| 选中密码框     | $('selector :password ') |
| 选中提交框     | $('selector :submit ')   |
| 选中重置框     | $('selector :reset ')    |

#### 3.

---

## 第二部分：Java

### 1、java 基础

#### 1、java程序执行的过程

>java跨平台原理:在需要运行java程序的操作系统上,安装一个与操作系统相对应的java虚拟机(JVM)即可
>
>JDK运行环境:包括JVM虚拟机+java的类库

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\java虚拟机.png)

编辑源代码xxx.java ==>Java编译器编译xxx.java文件生成字节码文件xxx.class ==> JVM中的类加载器加载字节码文件 ==> JVM中的执行引擎找到入口方法main()，执行其中的方法.

<img src="C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\java程序执行过程.png"  />

#### 2、java中的数据类型

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\java中的数据类型.png)

java中的数据类型有两种:

##### 1.基本数据类型(8种):

​		**整型**:byte short int long(整数默认是int)

​		**浮点数**:double float(浮点数默认是double)

​		**布尔型**:true false

​		**字符型**:char

|      基本数据类型       | 所占字节 |                          取值范围                           | 默认值  |
| :---------------------: | :------: | :---------------------------------------------------------: | ------- |
|          byte           |    1     |                 -2^7到2^7-1       -128到127                 | 0       |
|          short          |    2     |           -2^15到2^15-1             -32768到32767           | 0       |
|       int（默认）       |    4     |         -2^31到2^31-1      -2147483648到2147483647          | 0       |
|          long           |    8     | -2^63到2^63-1     -9223372036854775808到9223372036854775807 | 0L      |
| float（数字后面加 f/F） |    4     |  单精度小数：精度七位 3.4028235 E38(1后面38个0) 到 1.4E-45  | 0.0f    |
|     double（默认）      |    8     |    双精度小数：精度16位 1.7976931348623157E308 4.9E-324     | 0.0     |
|          char           |    2     |                           0-65535                           | 'u0000' |
|         boolean         |    1     |                         true/false                          | false   |

##### 2.引用数据类型：

> java提供的类以及自己写的类,所有的基本数据类型都有对应的引用数据类型,也就是**包装类**
>
> **String**(字符串,默认值为**null**),对象,数组

##### 3.数据类型转换

>数据类型的转换是在**所赋值的数值类型**和**被变量接收的数据类型**不一致时发生的，它需要从一种数据类型转换成另一种数据类型。数据类型的转换可以分为**隐式转换（自动类型转换）**和**显式转换（强制类型转换）**两种
>
>**自动类型转换(也叫隐式类型转换)** ，其实就是小范围的数据类型向大范围的数据类型转换,byte—>(short/char）—>int—>long—>float—>double，例如Integer i = 12;//这里int自动转换成Integer也是自动转换,但也只能**对对应的基本类型进行自动转换**
>
>**强制转换类型**，在要强制转换类型的前面加上括号，然后再括号里面加上你要转换的类型。有些数据经过转换运算后，**精度就丢失了**

##### 4.String字符串和数字间的转换

>**字符串转数字**:通过基本类型对应的**包装类**则可以实现把字符串转换成基本类型。(**注意：如果字符串不是数值型字符串，转换将导致一个运行时错误。**)

```java
String s = "123";

byte b = Byte.parseByte(s);
short t = Short.parseShort(s);
int i = Integer.parseInt(s);
long l = Long.parseLong(s);
Float f = Float.parseFloat(s);
Double d = Double.parseDouble(s);
boolean bo = Boolean.parseBoolean(s);
char c = Character.parseCharacter(s);
```

>**数字转String字符串**:1.直接拼接;2.String.valueOf(int i);3.强制类型转换

```java
//方法一
int a = 123;
String str = ""+a;
//方法二
int i = 123;
String s = String.valueOf(i);
//方法三
String str = (String)a;
```

#### 3、命名规范

| 类型(名) | 约束                                                         | 例              |
| -------- | ------------------------------------------------------------ | --------------- |
| 项目     | 全部小写,多个单词中用'-'分割                                 | spring-cloud    |
| 包       | 全部小写                                                     | cn.hnist.dao    |
| 类       | 单词首字母大写                                               | FirstClass      |
| 变量     | 首字母小写,多个单词组成时,首单词首字母小写,其他单词首字母大写 | userName        |
| 常量     | 全部大写,多个单词用'_'分割                                   |                 |
| 方法名   | 首字母小写,多个单词组成时,首单词首字母小写,其他单词首字母大写 | getById(int id) |

>所有命名规则必须遵循以下规则：
>
>1)、名称只能由字母、数字、下划线、$符号组成,不限制长度
>
>2)、不能以数字开头
>
>3)、名称不能使用JAVA中的关键字。
>
>4)、坚决不允许出现中文及拼音命名

#### 4、键盘扫描类Scanner

```java
// 1.创建键盘扫描器
Scanner sc = new Scanner(System.in);
System.out.println("请输入您的年龄:");
// 2.接收用户输入进来的值
// next:接收字符串
// nextLine:接收一行不限制
// nextInt : 接收整数
// nextDouble: 接收小数
String str = sc.next();
// InputMismatchException 输入类型异常
System.out.println("您的年龄为:"+str);
// 3.用完关闭
sc.close();
```

#### 5、随机数类Random

>补充:Math.random():在0.0-1.0之间随机生成小数  double num = Math.random();

```java
// 2. 使用随机数类
Random rd = new Random();  
// rd.nextInt():在int取值范围随机生成整数 i
nt number1 = rd.nextInt(); 
//在0-9之间随机生成
int number2 = rd.nextInt(10);
//在1-10之间随机生成
int number2 = rd.nextInt(10)+1;
```

#### 6、break和continue的区别

>**break:**跳出当前循环, 或者可以结束指定循环

``` java
name:for (int i = 1;i<=5;i++){
	System.out.println("=====================");
	System.out.println("这是i家族的第"+i+"次");
	for (int j = 1;j<=5;j++){
		if (i==3){
		//结束指定代码块的循环
		break name;
		}
	System.out.println("这是j家族的第"+j+"次");
	}
}

```

>**continue** :跳出当次循环,进行下次循环条件判断,但是循环不结束

#### 7、数组

>**一维数组**: Java 提供了数组(Array)的 数据结构 ,是一个可以存储 相同数据 类型 元素的容器,每个存在数组中的数称为 元素 ,然后把元素从 0 开始 编号,这样方便会数据更好的操作
>
>格式1: 数组类型[]  数组名=new 数组类型[数组的长度];
>格式2: 数组类型[]  数组名={值1,值2,值3,,,,,};
>格式3: 数组类型[]  数组名=new 数组类型[]{值1,值2,值3,,,,,};
>
>Arrays工具类:



```java
//数组遍历的一种方法(只读),增强for循环
for(遍历目标的类型 变量名:遍历的目标){
}
// 数组的长度是固定的,如果需要多添加元素,那么就需要将原来的数组容量变大,就是创建一个新的数组!
String[] strings = new String[3];
strings[0] = "贾静雯";
strings[1] = "袁隆平";
strings[2] = "媛媛";
System.out.println("原来的数组" + Arrays.toString(strings));
System.out.println("原来的数组内存地址:"+strings);
// Arrays.copyOf(拷贝的目标数组,拷贝以后的新长度);
String[] strings1 = Arrays.copyOf(strings, strings.length +1);
System.out.println("拷贝以后的数组:" +Arrays.toString(strings1));
System.out.println("拷贝以后的数组内存地址:"+strings1);
// 给最后一个属性赋值
strings1[strings1.length-1] = "慕容楷";
System.out.println("赋值以后的数组:" +Arrays.toString(strings1));
}
```

>**二维数组:**Java 中没有严格意义的二维数组,所谓的二维数组就是数组中的数组
>
>二维数组的遍历通过双重for循环

#### 8、Arrays工具类

>**java.util.Arrays** :该类包提供了大量用于操作数组的静态方法（如排序和搜索）。 该类还包含一个静态工厂，可以将数组视为列表。
>
>asList(数组);返回指定数组的list集合
>copyOf(数组,int length);数组扩容/缩容length长度
>copyOfRange(数组,  int from, int to);将指定数组的指定范围复制到新数组中。 
>sort(数组)按照顺序排列指定的数组。

#### 9、内存分配

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\内存分配.png)

#### 10、方法的重载和重写

>**方法重载(overload):**是指在**一个类**中定义多个同名的方法，但要求每个方法具有**不同的参数的类型**或**不同的参数的个数**。调用重载方法时，Java编译器能通过检查调用的方法的参数类型和个数选择一个恰当的方法**(只要是方法名相同,参数列表不同就是重载,不考虑其他)。**
>
>**方法重写(override)：**是父类和子类之间的,子类定义的方法与父类的方法名字相同,参数列表和返回值类型也相同；(**注意:1、被final修饰的方法不能重写；2、抽象类和接口的方法必须要重写。**)
>
>面试题：重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？
>答：方法的重载和重写都是实现多态的方式，区别在于重载实现的是编译时的多态性，而重写实现的是运行时的多态性。**重载发生在一个类中**，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；**重写发生在子类与父类之间**，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常。

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\重载和重写的区别.png)



### 2、java 进阶

#### 1、类与对象

>**什么是类**(月饼模具,学生类,老师类,人类) 就是对具有相同属性和行为的物体的统称 用来描述同一类事物的属性和行为 
>
>**什么是对象**(每一个月饼就是一个对象,贺龙同学,媛媛老师,黄同学) 客观存在的事物皆为对象 具体一点说:就是某一类事物的体现 
>
>**类与对象的关系** 一个月饼是月饼模具的具体实例(一个月饼是真实存在的实物) 对象是类的实体体现

##### 1、如何创建类

**类中的成员**:

​	**属性:**姓名 性别 身份证号 科目 ...... 

​	**行为:**上课 吃饭 睡觉 打游戏 泡帅哥/美女....

**创建类的步骤:**

>1.创建一个类 
>
>访问修饰词 class 类名{--(类名首字母大写,如果由多个单词组成,建议每个单词首字母大写) 
>
>} 
>
>2.编写类的属性(成员变量) 
>
>属性:姓名 性别 身份证 科目 年龄...... String name; String sex; String id; int age; 
>
>访问修饰词 数据类型 变量名; 
>
>3.编写类的行为(成员方法) 
>
>行为:吃饭 睡觉 打游戏 考试...... 
>
>方法五要素: 访问修饰词 返回值 方法名(方法参数){ 
>
>方法体 
>
>}

```java
/*
在同一个java文件中只能有一个public修饰的class(不包含内部类的说法)
而且public修饰class的类名必须与java文件名相同
*/
//创建类的方法一:在main方法类外创建
class Student{
//学生类的属性.
	String name;
	String sex;
	int age;
//吃饭方法
	public void eat(String str){
		System.out.println(name+"正在吃"+str);
	}
	//无参构造
	public Student(){
		name=null;
		sex=null;
		age=0;
	}//方法的重载
	//有参构造
	public Student(String n,String s,int a ){
		name=n;
		sex=s;
		age=a;
	}
}

```

``` java
package day0112;
/*
创建类的方法二:
*/
public class Person {
//属性--成员变量
	String name;
//行为--成员方法
	public void sleep(){
		System.out.println(name+"正在睡觉....");
	}
}
/*
总结
Java类的固定格式
修饰词 class 类名{
成员变量类型1 变量1;
成员变量类型2 变量2;
成员变量类型3 变量3;
方法1{}
方法2{}
}
*/

```

##### 2、通过类创建对象

>1.创建对象的格式 : 类名 对象名=new 类名();  
>
>2.调用成员变量/方法的格式 : 对象名.成员变量  对象名.成员方法()

```java
public class Demo01 {
public static void main(String[] args) {
	//类名 对象名=new 类名();
	int a=10;
	Student ff=new Student();
	//通过ff调用name属性
	ff.name="峰峰";
	ff.age=18;
	//通过ff调用吃饭的方法
	ff.eat("KFC");
	System.out.println("峰峰的性别:"+ff.sex);
	/*
	如果没有对成员变量赋值
	那么:
	如果成员变量是基本类型数,则默认值为0
	如果成员变量是引用类型(除了基本类型以外的所有类型),则默认值为null
	如果成员变量是boolean,则默认值是false
	*/
	// int b;
	// System.out.println(b);b没有初始化,编译出错
	Person pp=new Person();
	}
}

```



##### 3、访问修饰符

>java访问修饰词(可以**修饰类**,可以**修饰方法**,可以**修饰成员变量**) 
>
>1.private 私有的；被其修饰的类、属性、方法只能被该类的对象访问，其子类不能访问，更不允许挎包访问 
>
>2.default (什么都不写)只能同一个包中的类访问 
>
>3.protected 受保护的；被其修饰的类、属性、方法只能被**类本身的方法及子类访问（包括子类跨包）** 
>
>4.public 公共的,公开的,表示任何地方都可以访问 

| 修饰符    | 同一个类 | 同一个包 | 子类 | 任何地方 |
| --------- | -------- | -------- | ---- | -------- |
| private   | 可以     |          |      |          |
| default   | 可以     | 可以     |      |          |
| protected | 可以     | 可以     | 可以 |          |
| public    | 可以     | 可以     | 可以 | 可以     |

##### 4、状态修饰符

```
一.static:静态的---->随着类的加载而加载--->意味着静态方法比非静态 方法先加载
	1.修饰方法
        语法格式:状态修饰词 返回值  方法名(方法参数){方法体}
        作用:当使用static修饰方法,则表示该方法属于类,可以直接通过类名调用,不可通过对象调用
        结论
           1.静态方法中不可以调用非静态方法
           2.非静态方法中可以调用静态方法
	2.修饰变量(不能修饰局部变量)
         语法格式:状态修饰词  变量类型  变量名..
         作用:当使用static修饰变量的,则表示该变量属于类,只可以直接通过类名调用
         结论
            1.在静态方法中,只能调用静态的资源
            2.在非静态方法中,可以调用静态的资源也可以调用非静态的资源
	3.修饰静态代码块
         语法格式:
           static{
            }
         作用:用于初始化静态变量
     4.注意:
         1.类一被加载,则就会去执行静态代码块
         2.先执行父类静态代码块还是子类的?一定是先加载父类的,因为子类可以使用父类的静态资源
         3.先执行父类的构造还是子类的构造?一定是先执行父类的构造,因为子类可以使用父类的非静态资源

```

```java
public class Demo01 {
    public static void main(String[] args) {
        /*
          非静态方法的访问步骤
          1.创建对象
          2.通过对象调用方法
         */
        Aoo a=new Aoo();
        a.test();
        a.name="代代";//非静态的name可以直接通过对象调用
        /*
         静态方法的访问步骤
          1.直接通过类名调用
         */
        Aoo.staticTest();
        Aoo.id=10;//静态的id可以直接通过类调用
    }
}
class Aoo{
    String name;//非静态的成员变量
    static int id;//静态的成员变量
    public void test(){
        System.out.println("非静态方法test");
         staticTest();
         //非静态方法中可以直接写方法名调用静态方法
    }
    public static void staticTest(){
        System.out.println("静态方法test");
        //test();报错
        //this.test();报错,因为static方法不认识this(因为静态方法属于类,不认this对象)
        //为什么静态方法中不能调用非静态方法?
        //1.非静态方法是需要通过对象调用的
        //2.方法使用static,没有this的概念了
        //3.所以static方法中不可以直接写方法名调用非静态方法
        id=100;
      //  name="苍老师";静态方法中不可以调用非静态的资源
    }
    public void testAoo(){
        //非静态方法中可以直接调用非静态方法
        //this:在非静态方法中有隐式的this传递
        //this:指代的是当前类对象
        test();//===this.test();
        id=100;
        name="苍老师";
    }

}
```

```
二.final代表最终的意思
   1.修饰类:该类不能被继承(不可以有子类或者孙子类,但是可以有父类)
   2.修饰方法:该方法不能被重写,但是可以被重载
   3.修饰变量:表示该变量只能赋值一次，不可以再次赋值

   注意:使用final修饰的变量就是常量...
```

```java
public class FinalDemo01 {
}
class Goo{
    final int b;
    /*如果成员变量用final修饰，则要么在定义的时候初始化，要么在构造中手动初始化,但是只能初始化一次*/
    public Goo(){
        b=10;
    }
    public final  void test(){
        final  int a;//a使用final修饰，则a只能赋值一次
        a=20;
        //如果使用final修饰当前方法，
        //所以该方法是不带参数的最终形态,所以不能重写
    }
    public final  void test(int a){
        //如果使用final修饰当前方法，
        //所以该方法是带参数的最终形态,所以不能重写
    }
}
final class Coo extends  Goo{//定义一个最终的类叫Coo
//    public final  void test(){
//
//    }
}
//class Doo extends Coo{
//     因为Coo用final修饰,所以在这里Doo不能继承自Coo
//}

```

```
三.static final可以用来修饰变量，
     一但使用static final修饰变量之后，那么改变量就变成了常量
     该常量必须在定义的时候初始化

	 取名:常量的每个字母都大写，为了区分的普通的成员变量
```



##### 5、成员变量和局部变量

>**成员变量和局部变量的区别**:
>
>1.**类中定义的位置** : 成员变量(类中方法外定义) 
>
>​								局部变量(方法内或**方法的声明上(形参)**) 
>
>2.**初始化值不同**: 成员变量(有默认的初始化值) 
>
>​							局部变量(没有默认初始化值,必须先定义,赋值才可以使用) 
>
>3.**生命周期**: 成员变量(随着对象的存在而存在,随着对象的消亡而消亡) 
>
>​					局部变量(随着方法的调用而存在,随着方法的调用完毕而消失

##### 6、构造方法

>**构造方法的注意事项【理解】**
>
>1.构造方法的创建 
>
>​			如果没有定义构造方法,系统将给出一个默认的无参构造 
>
>​			如果定义了构造方法,系统将不会提供默认的无参构造 
>
>2.构造方法的重载(方法名相同,参数列表不同) 
>
>​			如果自定义了带参数的构造方法,new对象的时候还是调用的无参构造, 就必须再写一个无参构造方法 
>
>3.推荐的构造方法的创建方式 
>
>​			无论是否使用,都需要手动添加一个无参构造
>
> 4.重要功能 可以使用带参数的构造,为成员变量进行初始化

``` java
package day0112;
/*
构造方法/构造函数/构造器
是一种特殊的方法
普通方法(五要素)
修饰词 返回值 方法名(方法参数){
方法体
}
构造方法(特殊的方法)(四要素)
1.修饰词 方法名(方法参数){
方法体
}
2.方法名与类同名
在学生类中的构造方法应该
修饰词 类名(){
}
public Student(){
}
普通方法的调用
对象名.方法名()
构造方法的调用
new 类名();创建对象的同时调用构造方法,用来初始化成员变量
如果创建类的时候,没有给类手动添加构造方法,系统会默认补充一个无参构造
如果创建类的时候,有手动添加构造方法,系统不会提供默认的无参构造
构造方法的注意事项【理解】
构造方法的作用:用来初始化成员变量
*/
public class Demo02 {
public static void main(String[] args) {
//因为无参构造创建的时候给属性的都是null或者0
Student ss=new Student();
//所以需要通过对象挨个对每个属性赋值
ss.name="苏苏";
ss.age=18;
ss.sex="男";
Student ss1=new Student("小刘","男",19);
}
}

```

##### 7、继承

>1、继承的概念:其实就是抽取子类的共性,子类继承父类,就具备父类的属性和行为
>
>2、继承的语法格式:      通过extends实现**(java只支持单继承,但是基础具有传递性)**
>     格式: class 子类 extends 父类(一定是先有父才能做子)
>     例如: class Student extends Person{};表示Student类继承自Person类
>               class Teacher extends  Person{};表示Teacher类继承自Person类
>
>3、继承的特点:     继承可以让类与类之间产生父子关系,然后子类就可以使用父类中非私有的成员（**继承具有传递性,孙子类也可以使用祖辈类的非私有的属性或者行为**）
>        例如:
>              class Student extends Person{};
>              		表示Student类继承自Person类,Student类可以使用Person类中**所有非私有的**属性或者行为
>             class Teacher extends  Person{};
>                	 表示Teacher类继承自Person类,Teacher类可以使用Person类中**所有的非私有的**属性或者行为
>
>4、继承的好处
>        1.提高了代码的复用性(多个类相同的成员可以放到同一个类中,再使用extends继承即可)
>        2.提高了代码的维护性(如果方法的代码需要修改,只需要去父类中修改即可)
>
>5、继承的弊端
>        1.继承让类与类直接产生父子关系,当父类发生变化的时候,子类实现也不得不跟着改变,
>        2.削弱了子类的独立性

``` java
package day0114;

public class Demo01 {
    public static void main(String[] args) {
    }
}
/*
人类--父类
 */
class Person{
    //子类中都有的属性
    String name;//姓名
    String num;//身份证号
    String sex;//性别
    //子类中都有的行为
    public void eat(){
        System.out.println(name+"正在吃饭...");
    }
    public void sleep(){
        System.out.println(name+"正在睡大觉...");
    }
    public void playGame(){
        System.out.println(name+"正在打游戏....");
    }
}
//学生类
class Student extends Person{
    int id;//学号
    //行为
    public void study(){
        System.out.println(name+"正在学习...");
    }
}
//老师类
class Teacher extends  Person{
    int id;
    public void teaching(){
        System.out.println(name+"正在讲课....");
    }
}
class JavaTeacher extends Teacher{
    public void teachingJava(){
        System.out.println(name+"正在上java课程!...");
    }
}
```

##### 8、方法的重写

>1.继承中的重写:子类出现了和父类一模一样的方法声明(**方法名和方法参数**必须是一样的)
>
>2.重写的应用场景
>   当子类需要父类的功能, 而且功能主体子类又持有自己内容时,可以重写
>  父类的方法,这样即沿袭父类的功能,又定义子类持有的内容
>
>3.重写需要遵循的规则"两同两小一大"(方法五要素)
>   1)两同:
>           	方法名相同,参数列表相同
>  2)两小:
>         	返回值类型
>       			void:若父类方法的返回类型是void,则子类必须也是void
>       			基本类型:若父类方法的返回值是基本类型,则子类必须是该基本类型
>       			引用类型:
>           				若父类方法的返回值是引用类型,则子类在重写方法的时候;子类方法的返回值可以是该类型的子类(总结:子类方法的返回值可以是父类方法的返回值的子类:子类方法的返回值小于等于父类方法的返回值)
>   			抛出异常
>       					子类抛出异常小于或者等于父类方法抛出的异常(异常再介绍)
>  3)一大:
>   			**访问修饰词:**子类方法的访问权限大于或等于父类方法的访问权限的
>       		例如
>       				父类方法的访问权限是public,那么子类若想重写该方法必须也是public
>       				父类方法的访问权限是protected,那么子类若想重写该方法必须使用public/protected
>
>> 重载(overload)和重写(override)区别
>>      发生在:重载发生在同一个类中
>>            		重写发生在父子类中
>>      方法的定义:
>>            		重载在只要方法名相同,参数列表不同,就发生了重载,不考虑其他因素
>>            		重写:"两同两小一大"

``` java
package day0114;

public class Demo02 {
    public static void main(String[] args) {
       Boo b=new Boo();
       b.name="小刘";
       b.sayHi();//Boo

       Coo c=new Coo();
       c.name="小武";
       c.sayHi();//Aoo
    }
}
class Aoo{
    String name;
    public void sayHi(){//在Aoo所有子孙类中都可以调用
        System.out.println("Aoo:"+name+"Hi~");
    }
   protected Aoo test(){//要求方法返回Aoo类型

        return new Aoo();//创建Aoo类型的对象并根据return返回
    }
    public int add(){
        return 10;
    }
}
class Boo extends Aoo{
    @Override
    public void sayHi(){
        System.out.println("Boo:"+name+"Hi~");
    }
}
class Coo extends  Aoo{
    @Override
    public  Coo test(){
        return new Coo();
    }
//    public byte add(){
//        return 10;
//    }
}
```

##### 9、this和super对象

>    继承中成员访问的特点 
>        this &super
>        this:代表的是本类对象的引用
>        super:代表的父类对象的引用
>
>        this&super的使用
>             成员变量
>                 this.变量名-----表示访问本类的成员变量
>                 super.变量名----表示访问父类的成员变量
>             成员方法
>                 this.方法名/方法名---表示访问本类的成员方法
>                 super.方法名----表示访问父类的成员方法
>             构造方法
>             	super()----调用父类的无参构造
>               	super(有参数)---调用父类的有参构造
>                                                                                                                                                                                                                                                                                                                                        
>                this()----调用当前类的无参构造
>               	this(有参数)----调用当前类的有参构造
>        		使用 this和super调用构造方法,必须写在构造方法的第一行
>        1).Boo中会不会自动补充无参构造?
>        	Boo中没有手动添加构造方法,所以会补充无参构造
>        2).Boo会不会调用Aoo的构造方法?
>            子类是需要使用父类的属性的,父类中属性初始化是在父类的构造方法中完成,所以会调用父类的构造
>        3).当没有使用super关键手动调用构造的时候,父类的构造有调用吗?有,默认调用父类的无参构造
>            得出结论:
>              	若父类没有无参构造,子类会报错
>            解决办法:
>              	1.在子类构造方法中去手动调用有参构造
>              	2.在父类中添加一个无参构造(建议大家都是用这种,)
>

``` java
package day0114;

public class Demo03 {
    public static void main(String[] args) {
        B b=new B();
        b.test();//输出的是局部变量age的值
    }
}
class A{
    int age=10;
    public void show(){
        System.out.println("A的show");
    }
    public void sayHi(){
        System.out.println("A的sayHi()");
    }
}
class B extends  A{
    int age=20;
    public void test(){
        /*
            静态方法(指的是static修饰的方法)
            非静态方法(指的是没有static修饰的方法)
                非静态方法中有隐式的this传递
         */
        int age=30;
        /*
        若父类和子类以及方法中都定义一个age,那么在
        该方法输出age的时候,就近原则输出方法中
        的局部变量age的值
         */
        //演示通过this和super调用成员变量
        System.out.println("test方法中的age:"+age);
        System.out.println("B中的age:"+this.age);
        System.out.println("A中的age:"+super.age);

        //演示通过this和super调用成员方法
       // this.sayHi();调用的是B类自己的sayHi
       // sayHi();//===this.sayHi()(非静态方法中的特征)
        super.sayHi();
    }
    @Override
    public void sayHi(){
        System.out.println("B的sayHi()");
    }
}
```

#### 2、多态

##### 1、多态的概念

>1.多态:一个事物可以表现出多种形态
>      	例如:苍老师----老师/人妻/孩他妈/演员
>
> 2.多态需要满足的前提条件
>      	1.要有继承或者实现(接口)关系
>      	2.要有方法的重写
>      	3.要有父类型接收子类对象(**向上转型**)
>
> 3.多态的表现形式
>      	1.方法形式参数用父类,实参可以使该类的子类
>      	2.引用类型数组方面,定义数组的属性为父类,数组元素可以是本类也可以是该类子类
>      	3.

``` java
package day0117;

public class Demo03 {
    public static void main(String[] args) {
        //多态
        //父类型接收子类对象(向上造型:多态的表现形式)
        Person p=new Mom();//扮成大人的样子,其实本身还是子类
        p.sleep();//调用还是子类的睡觉
        //但是p调用不了eat()方法
       /*
         一看: 通过p可以调用什么,要看p前面的类型(要看他扮成什么)
         二看:当调用的方法在子类中发生了重写,p在调用重写方法时,需要看new的对象
        */
        Mom m=new Mom();
        m.eat();//可以调用子类特有的属性和方法
    }
}
class Person{
    String name;
    int age;
    public  Person(){
    }
    //alt+insert
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void sleep(){
        System.out.println("人自己在睡觉...");
    }
}
class Wife extends Person{
    @Override
    public void sleep(){
        System.out.println("人妻自己在跟老公睡觉...");
    }
}
class Teacher extends Person{
    @Override
    public void sleep(){
        System.out.println("老师在学校宿舍睡觉....");
    }
}
class Mom extends  Person{
    @Override
    public void sleep(){
        System.out.println("妈妈在跟孩子睡觉...");
    }
    public void eat(){
        System.out.println("妈妈给小孩喂饭...");
    }
}
```

##### 2、多态的使用场景

``` java
package day0117;
/*
  基本类型数组
    	语法格式:
    	基本类型[] 数组名=new 基本类型[数组长度]
  引用类型数组
    	语法格式
    	引用类型[] 数组名=new 引用类型[数组长度]
    想定义一个数组
      这个数组可以存放A  也可以存放B 还可以存放C 还可以存放D
 */
public class Demo05 {
    public static void main(String[] args) {
        //基本类型数组
        int[] arr=new int[10];
        arr[0]=1;
       // arr[1]=6.5;arr是int类型数组.所以只能存放int的数
        //引用类型
      Teacher[] ts=new Teacher[2];
      ts[0]=new Teacher();
     // ts[1]=new Mom();ts是老师类型的数组,所以只能存放老师对象
        B[] bs=new B[5];
        bs[0]=new B();
       // bs[1]=new C();bs是A类型的数组,所以只能存放A对象

       A[]  as=new A[10];
       //as[0]是A类型
   //A as[0]=new A()
       as[0]=new A();
   //A as[1]=new B() ---向上造型
   //父类型的引用指向子类型对象
       as[1]=new B();
       as[2]=new C();//向上造型
       as[3]=new D();//向上造型
    }
}

```

#### 3、abstract抽象

```java
package day0121;
/*
修饰词
   abstract 抽象
   1.修饰类
      语法格式:访问修饰词 abstract class 类名{}
      a.在抽象类中可以抽象方法也可以有普通方法,也可以构造方法
      b.抽象类不能被实例化,不能new对象;因为抽象类中可能存在抽象方法,需要重写抽象方法之后,才可以实例化.
      c.抽象类的子类,要么重写抽象类中所有的抽象方法,要么该子类也是抽象类

   2.修饰方法(没有方法体)
      语法格式:访问修饰词 abstract 方法返回值 方法名();
      什么时候定义为抽象方法:
         当需要子类强制重写的时候,就把该方法设置为抽象方法
 */
public class AbstractDemo01 {
    public static void main(String[] args) {
       // Beauty b=new Beauty();//b不可以直接创建抽象类对象
        //参考多态
        Beauty b=new PureBeauty();//父类型引用指向子类型的对象(多态)

    }
}
abstract  class Beauty{
    public  abstract  void dressing();
    /*
    当一个类中出现了抽象方法,那么该类必须是抽象类
     */
    public void add(){
    }

}
//清纯型的美女
class PureBeauty extends Beauty{
    /*
     1.当前类继承自抽象类后,需要重写抽象类中所有的抽象方法
     */
    @Override
    public void dressing() {
        System.out.println("打扮成清纯型美女......");
    }
}
//成熟型的美女
abstract class MatureBeauty extends Beauty{
    /*
     2.当前类继承自抽象类后,还可以把子类写成抽象的
     */
}
```

#### 4、interface接口

```java
package day0121;
/*
  接口  使用时接口的关键字 interface
    语法格式: interface 接口名{}

    普通类:构造方法+静态方法+非静态方法+静态变量+非静态变量
    抽象类:抽象方法+构造方法+静态方法+非静态方法+静态变量+非静态变量

    接口:静态方法(jdk1.8之后)+抽象方法
      接口就是 一个公共的规范标准,只要符合这个规范,大家都可以使用
      java中的接口可以更多的体现对行为的抽象(在接口中除了静态方法以外,全是抽象方法)
      
      继承说的是类与类的关系,是用的是extends

      接口的特点
        1.接口不能new创建对象实例化,
        2.实现类的解决方案
          a.当前实现自接口后,可以重写接口中所有的抽象方法
          (如果是实现类是普通类型则实现后,需要重写接口中的抽象方法)
          b.将实现类变为抽象类,不重写接口的抽象方法也行
          (如果是抽象类,则可不重写抽象方法)

       
		注意:
			1.接口间的继承是多继承
			2.类之间的继承只能是单继承
			3.类与接口之间的关系是实现implements,一个类可以实现多个接口
            */
public class InterfaceDemo {
}
//类Aoo
class Aoo{
    int a;
    static  final int b=10;
    public Aoo(){
    }
    public void add(){
    }
    public static void test(){
    }
}
//抽象类Boo
abstract  class Boo{
    public abstract void demo();//类中有一个抽象方法,那么该类一定是抽象类

    int A;
    static  final int B=10;
    public Boo(){
    }
    public void add(){
    }
    public static void test(){
    }
}
//接口Coo
interface  Coo{
    int A=10;//===static final int A=10;
    static  final int B=10;
    /*
    在接口中定义的都是静态常量,必须定义的时候初始化
     */
    public static void test(){
        //jdk1.8之后接口中可以定义静态方法
    }
    public abstract void demo();
}

```

#### 5、内部类

>1.内部类的概述
>    当一个事务的内部,还有一个部分需要一个完整的结构进行描述(用属性和行为描述会不完整),那么这整个结构最好使用内部类;这个内部结构又为外部事务提供服务
>
> 2.内部类的基本使用,  在一个类中定义一个类
>      	例如:
>      		class A{
>       	 		class B{
>         			 }
>       		 }
>     	B类型就被称为内部类, 内部类可以直接访问外部类所有的资源,包括私有的! 外部类要访问内部类的成员,必须创建内部类对象
>
>3.创建内部类对象, 需要通过外部类对象创建内部类对象
>        Outer.Inner i1=new Outer().new Inner();
>            i1.show();
>
>4.内部类的分类:  成员内部类和局部内部类(匿名内部类)
>
>​		1).成员变量:类中定义的
>
>	成员内部类:在类中定义的
>	    也是一个类,作为一个类他有什么特征
>	        a.类中可以定义属性,方法 构造器
>	        b.可以被final&static&abstract修饰
>	c作为B的成员内部类,是B的成员,所以可以使用public修饰,因为如果想要创建C对象,直接通过B对象来创建即可,所以任意,地方都可以
>
>​			2).局部变量:方法中定义的
>
>

```java
package day0121;
public class Demo02 {
    public static void main(String[] args) {
        Person.Cat c=new Person().new Cat();
        c.display("花花");
    }
}
class Person{
    String name="person";
    int age=10;
    //成员内部类
    class Cat{
        int age;
        String name="cat";
        public Cat(){

        }
        public Cat(String name,int age){
            this.age=age;
            this.name=name;
        }
        public void eat(){
            System.out.println("猫在吃小鱼干");
        }
        public  void display(String name){
            System.out.println("方法参数name:"+name);//就近原则,表示的是参数name
            System.out.println("cat成员变量name:"+this.name);//this表示当前猫对象,所以是cat成员变量name
            System.out.println("person成员变量name:"+Person.this.name);//表示的是外部类的name
           // System.out.println(Person.age);person.this.age
        }
    }
}
```

```java
package day0124;

public class Demo02 {
    public static void main(String[] args) {

    }
  /*
  如果下列方法返回值是Y,则直接return new Y();
  如果下列方法返回值是T,则不能直接return new T();因为抽象类不能实例化
  如果下列方法返回值是Compare,则不能直接return new Compare();因为接口不能实例化
   */
  public T getT(){
        /*
        局部内部类操作
         */
      class H extends T{
          @Override
          public int Ttest() {
              return 0;
          }
      }
      /*
      当方法返回值是一个抽象类的时候，不能直接创建抽象对象
      所以在该方法中，创建类继承自抽象类，
      然后return 该抽象类的子类对象
       */
      return  new H() ;
  }

    public Compare getCompare(){
        /*
        当方法返回值是接口的时候,不能直接new接口对象
        可以在方法中创建该接口的实现类，
        return 实现类对象
         */
        class Com implements  Compare{

            @Override
            public int compareTo() {
                return 0;
            }
        }
        return  new Com() ;
    }
}
interface Compare{//接口
    public int compareTo();//方法
}
abstract class  T{
   public abstract  int Ttest();
}

class Y{

}
```

```java
package day0124;
/*
demo02的两个方法做继承和实现？
为什么要继承抽象类？抽象类不能实例化---抽象类中有抽象方法，抽象方法不完整
  继承抽象类之后，重写了抽象方法
为什么要实现接口？接口不能实例化---接口中都是抽象方法，抽象方法不完整
  实现接口之后，重写了接口中的抽象方法

  匿名内部类
   接口名/类名  引用变量=new   接口/类名(){
                        重写的方法;
                    };
 */
public class Demo03 {
    public Compare test01(){
        return new Compare() {
            @Override
            public int compareTo() {
                return 0;
            }
        };
        /*
          class Com implements  Compare{
                //成员内部类
            @Override
            public int compareTo() {
                return 0;
            }
         }
         return  new Com() ;
         */
    }
}
```

#### 6、instanceof的用法

```java
public class Demo04 {
    public static void main(String[] args) {
       Animal[] as=new Animal[6];
       as[0]=new Cat();
       as[1]=new Dog();
       as[2]=new Cat();
       as[3]=new Dog();
       as[4]=new Cat();
       as[5]=new Dog();
       /*
       如何调用猫和狗的特有的方法？
        */
       //instanceof:是 Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。,左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。 
        1.类的实例包含本身的实例，以及所有直接或间接子类的实例
		2.instanceof左边显式声明的类型与右边操作元必须是同种类或存在继承关系，也就是说需要位于同一个继承树，否则会编译错误
        /*
           A instanceof B
           返回true的情况：
              A是B类型的对象
              A是B类型的子类对象
              A是B类型的实现类对象

         */
      /*
      需要判断对应的对象是狗类还是猫类型，
      然后做强转才能调用
       */
//        Cat c=(Cat)as[0];
//        c.catPlay();
//        Cat d=(Cat)as[1];
//        d.catPlay();
        if (as[0] instanceof  Cat){
            //如果as[0]对象是Cat类型对象，则返回true
            Cat c=(Cat)as[0];
            c.catPlay();
        }
        if(as[1] instanceof Cat){
            //如果as[1]对象是Cat类型对象，则返回true;不是返回false
            Cat d=(Cat)as[1];
            d.catPlay();
        }
        System.out.println(as[2] instanceof  Animal);//true

        System.out.println(new Aoo() instanceof Boo);

        System.out.println(new To() instanceof  Hoo);
    }
}
class Cat extends Animal{
    @Override
    void step() {
    }
    public void catPlay(){
        System.out.println("抓老鼠");
    }
}
class Dog extends Animal{
    @Override
    void step() {
    }
    public void dogPlay(){
        System.out.println("看守门");
    }
}
abstract  class Animal{
   abstract  void step();
}
class Aoo{

}
class Boo extends Aoo{

}
interface  Hoo {

}
interface  Too extends Hoo{

}
class  To implements  Too{

}
```

### 3、java 高级

#### 1、String类

##### 1、基本知识

```java
/*
1.String的概念: String 类代表字符串,java程序中所有用双引号引起来都是字符串对象"abc"
    1.String类是在java.lang包中,(java.lang包中的类不需要导包的)
    2.String底层原理其实就是char数组
    3.char数组也是用final修饰,所以字符串的内容不可变
    4."常量池"用于存放通过字面量("abc")创建的String对象
	5.String使用final修饰
 */
public class Demo01 {
    public static void main(String[] args) {
        /**
         * == 用于判断引用地址是否相同
         */
        String s1="abc";//底层就创建char数组用于存放"abc"
        String s2="abc";//底层就创建char数组用于存放"abc"
        /*
        s1创建"abc"字符串对象,并放入常量池
        s2直接拿常量池中的"abc"用即可
        所以s1==s2,地址相同,内容也相同
         */
        System.out.println(s1==s2);//true
        
        s2=s2+"d";//在s2后加入一个d字符
        System.out.println(s1==s2);//false

        String s3="abcd";
        /*
          s2=s2+"d"---不是存在常量池中的
          s3="abcd"---常量池中的
          所以不相等
         */
        System.out.println(s2==s3);//false
        /*
        str是通过new 的Sting对象,不在常量池("abcd"是在常量池的)
        s3在常量池中,
        所以不相等
         */
        String str=new String("abcd");
        System.out.println(str==s3);//
    }
}
```

##### 2、构造方法

```java
package day0216;
/*
String 构造方法
    public String();--创建一个空白字符串对象,不含任何内容
    public String(char[] chs)--根据字符数组内容,来创建字符串对象
    public String(byte[] bys)--根据字节数组内容,来创建字符串对象
    public String(String s) ---直接根据s创建字符串对象
    public String(StringBuffer buffer)分配一个新的字符串，其中包含当前包含在字符串缓冲区参数中的字符序列。 字符串缓冲区的内容被复制; 字符串缓冲区的后续修改不会影响新创建的字符串。 
    public String(StringBuilder builder)分配一个新的字符串，其中包含当前包含在字符串构建器参数中的字符序列。 字符串构建器的内容被复制; 字符串构建器的后续修改不会影响新创建的字符串。 提供此构造函数以便迁移到StringBuilder 。 通过toString方法从字符串构建器获取字符串可能运行速度更快，通常是首选。 

 */
public class Demo02 {
    public static void main(String[] args) {
        // 1.
        String str1=new String();
        System.out.println(str1==null);//false  str1是空白的字符串对象 null是空的指向
        System.out.println(str1=="");//false ""放在常量池中 str1肯定不是在常量池中
        // 2.
        char[] chs={'a','b','c'};
        String str2=new String(chs);//根据chs中内容创建字符串对象
        System.out.println(str2);
        // 3
        byte[] bys={99,100,101};
        /*
          99  100 101当成字符所对应的码.
          实际上就是将99 100  101这几个码所对应的字符串拼接起来
         */
        String str3=new String(bys);
        System.out.println(str3);//cde
        //4
        String str4=new String("hgm");//"hgm"--常量池  new String()--堆内
        System.out.println(str4);
        //StringBuffer和StringBulider后面补充
    }
}

```

##### 3、equals方法

```java
package day0216;
/*
1.String 基本操作方法
    字符串比较方法equals(),用来比较两个字符串中内容是否相同
2.== 和 equals()的区别
	1.==:
    	情况一:是比较两个变量的值，如果是基本数据类型，那么就是比较的基本数据的大小值,==比较的就是下面两个内存块中的值，都是1，所以是true
    		int a=1;
            int b=1;
            System.out.println(a==b);
    	情况二:但是如果存储的是引用类型，其实比较的还是变量本身所存储的值，我们都知道，变量存储引用类型其实存储的只是引用对象的地址作为值存储到变量中，那么当用==判断时，比较的就是这两个地址值了，所以说==比的是两个变量所存储的值，至于这个值是什么类型的，就看放什么了, a和b存的就是一个引用对象，在这时判断a==b时，比较的也是a和b所存储的值，可以看出，a里面存的是0x1234，b里面存放的是0x5874,很明显不相等，所以是false	   		
            User a = new User();
            User b = new User();
            System.out.println(a==b);
    	情况三:而当使用==比较字符串时,这时，a和b存储的是同一个常量字符串，地址也一样，所以是true。
            String a="abcd";
            String b="abcd";
            System.out.println(a==b);
		情况四:如果通过创建对象的方式创建字符串，那么流程就会向上图一样，a和b里面所存放的值就不一样了，a和b 比较就是false
			String a=new String("abcd");
            String b=new String("abcd");
            System.out.printlnl(a==b);
     2.equals()
     	equals是属于Object的方法，在默认实现下其实就是==,也就是说和==是一样的，但是该方法可以被重写，至于被重写后比较的是什么就看实现的逻辑了，在这之中String就是对equals重写了，String重写的逻辑就是比较字符串内容。下图就是String重写的equals方法
 */
public class Demo03 {
    public static void main(String[] args) {
        String str1="123456";
        String str2=new String("123456");
        System.out.println(str1==str2);//false, "123456"存放常量池,new String不在常量池
        System.out.println(str1.equals(str2));
    }
}
/*
两个String类型的对象什么情况会返回true
     1.内容一致
     2.地址相同
 public boolean equals(Object anObject) {
            //2.地址相同
        if (this == anObject) {//比较两个对象是否是同一个对象
            return true;//如果是则返回true
        }
            //1.内容一致
            //指this和anObject对象的内容;this是String类型   anObject是Object(超类,所有类的父类)
            //如果要比较需要将anObject转为String
            //两个String去比较内容
        if (anObject instanceof String) {//判断anObject是否可以转为String
            //如果可以则直接转为String对象
            String anotherString = (String)anObject;
            //获取当前anotherString对象的value数组的长度
            int n = value.length;
            判断this的value数组长度和anotherString中数组的长度
            if (n == anotherString.value.length) {
              //如果两个字符数组的长度相同,则比较内容
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
 */
```

##### 4、字符串获取方法

```java
package day0216;
/*
字符串获取方法
    1.获取字符串长度,
    	public int length()
    2.获取指定索引处的值(字符),索引的范围:0-(length-1)
     	public char charAt(int index)
    3.获取指定字符或者字符串首次出现的位置
     	public int indexOf(int ch);查找首次出现ch的位置
     	public int indexOf(int ch,int fromIndex);查找从fromIndex后首次出现ch的位置
     	public int indexOf(String str);查找首次出现str的位置
     	public int indexOf(String str,int fromIndex);查找从fromIndex后首次出现str的位置
    4.获取指定字符或者字符串最后一次出现的位置(同上)
    	public int lastIndexOf(int ch)
     	public int lastIndexOf(int ch,int fromIndex)
     	......
    5.测试当前字符串是否以指定字符串进行开头和结尾
     	public boolean startsWith(String str)
     	public boolean endsWith(String str)
 */
public class Dmeo04 {
    public static void main(String[] args) {
        //1
        String str="123tt456qwett1";
        System.out.println("str的长度为"+str.length());
        //2
        System.out.println(str.charAt(8));
        //3
        System.out.println(str.indexOf('1'));//首次出现1的位置
        System.out.println(str.indexOf('1',7));//从下标为7之后查找首次出现1的位置
        System.out.println(str.indexOf("tt"));//首次出现"tt"的位置
        System.out.println(str.indexOf("tt",7));//从下标为7之后查找首次出现"tt"的位置
        //4
        System.out.println(str.lastIndexOf("tt"));
        //5.
        System.out.println(str.startsWith("123"));//true
        System.out.println(str.endsWith("123"));//false
    }
}
```

##### 5、字符串的截取

```java
package day0216;
/*
字符串截取
   public String subString(int beginIndex);从beginIndex下标开始截取字符串到末尾,返回截取之后的字符串
   public String subString(int beginIndex,int endIndex);从beginIndex下标开始截取到endIndex
   public String trim();去掉字符串的"前后"的空格,中间的空格不能去掉
 */
public class Demo05 {
    public static void main(String[] args) {
        String url="https://www.baidu.com";
        //1.先找到baidu前面的这个点位置
        int beginIndex=url.indexOf(".");
        //2.找到baidu后面这个点的位置(从上面.的位置后面开始第二个.)
        int endIndex=url.indexOf(".",beginIndex+1);
        //3.传入两个下标(通过下标截取的时候"含头不含尾"--包含第一个点不包含第二个点)
        //System.out.println(url.substring(beginIndex,endIndex));  ==.baidu
        System.out.println(url.substring(beginIndex+1,endIndex));  ==baidu

        String s="  ss  ss  ";
        System.out.println(s.length());//10
        System.out.println("---"+s.trim()+"---");//通过trim方法去掉前后空格
    }
}
```

##### 6、字符串的分割和替换

```java
package day0216;
/*
字符串分割和替换
   1.将字符串按照指定字符regex(正则表达式)去进行拆分,然后就没有regex了
     public String[] split(String regex);

   2.将字符串中oldStr替换成newStr
     public String replace(String oldStr,String newStr);
 */
public class Demo06 {
    public static void main(String[] args) {
        String str="111:222:333:444";
        String[] ss=str.split(":");
        for(int i=0;i<ss.length;i++){
            System.out.println(ss[i]);//111  222  333  444
        }

        String str2="你是不是大SB!!SB";
        String str3="你TMD是不是大SB!!";
        System.out.println(str2.replace("SB","**"));//你是不是大**!!**(所有的都会替换)
        System.out.println(str3.replace("SB","**"));//你TMD是不是大**!!
        System.out.println(str3.replace("TMD","**"));//你**是不是大SB!!
        /*
        正则表达式,可以实现同时替换多个字符串
         */
    }
}

```

#### 2、StringBuffer,Builder

```java
package day0218;
/*
1.String 是一个不可变的字符串,做频繁的拼接,性能比较差,可变字符串StringBuffer  StringBuilder
2.三种的异同点
     类名       String      StringBuilder    StringBuffer
   对象类型     字符串常量      字符串变量       字符串变量
   线程安全性    不安全          不安全            安全       (要求数据准确)
   执行效率       低              高              中
   (不安全指的就是多个对象可以操作;安全指的是只能一个对象操作完了,另外才可以操作)
3.与String的区别:可变字符串和不可变字符串本质上就是底层char数组有没有加final的区别
4.使用场景:后续开发中频繁做字符串的增删改插,则选择可变字符串;一般情况选择String
5.可变字符串StringBuffer和StringBuilder这两种类型方法和功能完全相同,不一样的就是StringBuffer中的方法采用加锁效果,线程安全,而StringBuilder没有加锁,线程不安全,但是效率高
 */
public class Demo03 {
    public static void main(String[] args) {
        /*
        StringBuilder的构造方法:
        	StringBuilder()  空的可变序列
        	StringBuilder(String str) 根据指定字符串创建可变序列
         */
        StringBuilder sb1=new StringBuilder();
        StringBuilder  sb2=new StringBuilder("abc");
        System.out.println("sb1:"+sb1);//
        System.out.println("sb2:"+sb2);//
        /*
        StringBuilder常用方法
            1.增:append(xxx); 提供了很多append方法用于进行各种类型的字符串拼接
            2.删:delete(int start,int end) 删除指定位置的内容,用下标表示区间,含头不含尾
            3.改:
              	setCharAt();设置指定下标的内容
              	repalce(int start,int end ,String str);用下标表示区间,含头不含尾
            4.插:
              	insert(int offset,XXX) 在指定下标处,插入任意内容
         */
        sb1.append(5.14);
        sb1.append(false);
        System.out.println("sb1:"+sb1);
        
        sb1.delete(2,5);//用下标表示区间,含头不含尾
        System.out.println("sb1:"+sb1);//5.alse
        
        sb1.replace(2,4,"yyy");//把下标为2 3 的内容替换成yyy
        System.out.println("sb1:"+sb1);//5.yyyse
        sb2.setCharAt(0,'Y');
        System.out.println("sb2:"+sb2);//Ybc
        
        sb2.insert(1,"HH");
        System.out.println("sb2:"+sb2);//YHHbc
            }
}
```

```java
package day0218;
public class Demo02 {
    public static void main(String[] args) {
        long startTime=0L;//记录开始时间
        long endTime=0L;//记录结束时间
        String s1="";
        /*
        System.currentTimeMillis()  获取系统时间(以毫秒值为单位时间)
         */
        startTime=System.currentTimeMillis();
        for(int i=0;i<50000;i++){
            //字符串拼接 从0一直拼接到20000
            s1=s1+i;
        }
        endTime=System.currentTimeMillis();
        System.out.println("String拼接所花时间:"+(endTime-startTime));

        //创建StringBuffer空可变字符串对象
        StringBuffer sb1=new StringBuffer();
        //记录循环开始时间
        startTime=System.currentTimeMillis();
        for(int i=0;i<50000;i++){//循环拼接
            sb1.append(i);
        }
        //记录循环结束时间
        endTime=System.currentTimeMillis();
        System.out.println("StringBuffer拼接所花时间:"+(endTime-startTime));

        //创建StringBuilder空可变字符串对象
        StringBuilder sb2=new StringBuilder();
        //记录循环开始时间
        startTime=System.currentTimeMillis();
        for(int i=0;i<50000;i++){//循环拼接
            sb2.append(i);
        }
        //记录循环结束时间
        endTime=System.currentTimeMillis();
        System.out.println("StringBuilder拼接所花时间:"+(endTime-startTime));
    }
}
```



#### 3、正则表达式

```java
package day0218;
/*
正则表达式概念:描述了一种字符串匹配的模式,可以检查一个字符串中是否含有某种子串,将匹配的字符串替换或者从某个串中取出符合条件的子串

正则表达式组成:是由普通字符(a-z)以及特殊的字符(*,$,+...)组成的文字模式

   1. \转义字符 将下一个字符标记为特殊字符(表示一个\要写两个\\)
   "d"表示匹配小写"d"    "\d" 表示匹配一个数字

   2.^ 用法1:限定开头
            ^a 会匹配开头是否是a,但是不会匹配最后
       用法2:取反
           [^abc] 取除了abc以外的字符
        只要"^"这个符号是放在[]里面使用就表示取反,如果不是,则表示限定开头
   3.$ 限定结尾
"(^|&)" + name + "=([^&]*)(&|$)"
   4.自定义匹配
       [abc]:表示匹配abc中其中一个
       [a-zA-Z0-9]:表示匹配 a-z 或者A-Z或者0-9其中一个
       [^abc]:除了abc以外的任意一个字符
	   [\u4e00-\u9fa5] :匹配汉字的区间
	   
   5.关于数量写法
      ?:{0,1} 表示1个或者0个  \\d?--表示一个或者零个数字
      +:{1,n} 表示1到多个     \\d+--表示一个以上的数字
      *:{0,n} 表示0到多个     \\d*--表示零个以上的数字
      {n,m}   表示n到m个      \\d{n,m}--表示n到m个数字
      {n,}    表示n到多个     \\d{n,}--表示n到多个数字
      {n}     表示只有n个     \\d{n}--表示n个数字

   6.常见定义的字符类
      数字  \d  非数字\D
      空白字符 \s 非空白字符\S
      \w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_]
      . 表示任意字符
      \b 匹配一个单词边界，即字与空格间的位置。
	  \B 非单词边界匹配。

 */
public class Demo01 {
    public static void main(String[] args) {
        //replace()全匹配
        String str="TMD,你真是个DJB,SB!";
        System.out.println(str.replace("DJB","***"));

        //replaceAll()全匹配,支持正则表达式
        String str1="abcd123thad";
        System.out.println(str1.replaceAll("d","*"));//abc*123tha*
        System.out.println(str1.replaceAll("\\d","*"));//abcd***thad

        // boolean matches(String regex)  判断指定字符串是否满足regex正则表达式
        String str2="123456";
        System.out.println(str2.matches("\\d"));//false \\d表示匹配一个数字.
        System.out.println(str2.matches("\\d+"));//true  \\d+表示匹配一个以上的数字

        System.out.println(str2.matches("^\\d+"));//true,以数字开头,数字1到多个

        String  str3="a123";
        System.out.println(str3.matches("^a"));//false,^a判断开头是否是a,后面123没有写相应的表达式

        String  str4="a";
        System.out.println(str4.matches("[abc]"));//true,是否有abc中的任意一个

        String str5="y";
        System.out.println(str5.matches("[^abc]"));//true 匹配str5是否是非abc的任意一个字符
        System.out.println(str5.matches("^[yzh]"));//true 匹配str5是否是yzh

        String str6="111t";
        System.out.println(str6.matches("\\d+[a-z]$"));//\\d+表示1到多个数字,[a-z]$表示小写字母结尾,所以上述判断为true
        
        String str9="TMD,你真是个DJB,SB!";
        System.out.println(str9.replaceAll("(TMD|DJB|SB)","***"));//(TMD|DJB|SB)表示字符串中出现该三者中的任意一个都用***替换

        /*
            手机号(国内)
           (13|14|15|16|17|18|19)\\d{9}
            密码只能有6个数字+字母组成
            [a-z0-9A-Z]{6}
         */
        String strs="yy123abc456eda123eds";
        String[] ss =strs.split("\\d+");//以多个数字进行分割
        for (int i=0;i<ss.length;i++){
            System.out.println(ss[i]);
        }
    }
}

```

#### 4、包装类

```java
package day0221;
/*
包装类
    因为基本类型不能参与面向对象的开发(基本类型不能创建对象,也不能调用方法),所以将基本类型数据封装成一个对象,可以在对象中定义更多的功能和方法去操作该数据(这里封装的对象就是包装类对象)

基本类型对应的包装类
基本数据类型              包装类
byte                     Byte
short                    Short
int                      Integer
long                     Long
float                    Float
double                   Double
char                     Character
boolean                  Boolean

1.常用的操作一: 用于基本数据类型与字符串之间转换
    每个包装类都有 两个构造+两个静态方法都能用于获取包装类对象,结论:
       1.两个构造(过时)
           public 包装类名(对应基本类型  变量名)
           public 包装类名(String  s)
       2.两个静态方法
           public static 包装类名 valueOf(对应的基本类型  变量名)
           public static 包装类名 valueOf(String  s)
 */
public class Demo01 {
    public static void main(String[] args) {
		//Integer i3= new Integer("zt");zt不是一个数字,字符串必须是可以装换为数字的
        Boolean b=new Boolean("true");
        System.out.println(b);//只要字符串不是true,都是默认为false
        //1.
        Integer i3=Integer.valueOf(10);//根据10 创建一个Integer实例并返回到i3
        System.out.println(i3);
        //2.
        Integer i4=Integer.valueOf("888");//rrr888需要使用字符串的分割,rrr去掉,再把888转为int
        System.out.println(i4);      
    }
}
```

##### int和String相互装换

```java
package day0221;
/*
int和String 类型的互相转换
   	String ---> int  :调用的方法是int 的包装类中的静态方法parseInt(String s)方法
   	int ---> String  :调用的方法时String的静态方法valueOf(int i)
 */
public class Demo02 {
    public static void main(String[] args) {
       //int ---> String
       int num=100;
       //方法1:直接在int值的后面加空字符串
       String s1=num+"";
       //方法2:String类中有一个静态方法public static String valueOf(int i)
       String s2=String.valueOf(num);

       //String--->int
       //方法1:String---Integer--int
       //String-Integer
       String s3="1234";
       Integer i1=Integer.valueOf(s3);
       //Integer-int
       //Integer中有一个方法可以获得int类型值, public int intValue()
       int a=i1.intValue();
        
       //方法2:
       //public static int parseInt(String s)
       int b=Integer.parseInt(s3);
       System.out.println(b);
       /*
        String ---double
        */
        String s7="6.47";
        double d=Double.parseDouble(s7);
        /*
        自动拆装箱
         装箱:把基本类型数据转换为对应的包装类
         拆箱:把包装类转换为对应的基本类型

         自动装箱:自动把基本类型数据转换为对应的包装类
         自动拆箱:自动把包装类转换为对应的基本类型
         */
         Integer i8=600;//自动装箱,把600自动装箱为Integer对象
          i8+=200;
          //i8=i8+200;//i8自动拆箱为600,与200做加法运算得到int类型的800
                      //i8=800; 800自动装箱为Integer对象
    }
}

```

#### 5、日期相关类

>##### Java中的日期日期类型,的几种表现形式:
>
>​	 1.Date类型的时间,仅作为一个日期类型表示:Date date = new Date();
>
>​	 2.long类型的时间,系统时间到1970年的时间毫秒数值
>
>​	 3.Calendar类型的时间(抽象类),当需要对日期进行add  set等相关操作时，选用Calendar: 
>
>​				Calendar c1 = Calendar.getInstance();//通过静态工厂获取子类对象
>
>​				Calendar c2 = new GregorianCalendar();//实例化其子类对象
>
>##### SimpleDateFormat日期的格式化和解析
>
>​	 1.格式化(Date转为String)  	public final String format(Date date)
>
>​	 2.解析parse(String转为Date)  	public Date parse(String source)

##### 1、Date类

```java
package day0221;
import java.util.Date;
/*
Date日期类型
    Date类:代表一个特定的时间,精确到毫秒;从起始时间到现在的毫秒值
        计算机起始时间---1970.1月1日 00:00:00
		东八区时间要+8
		0表示一月,1表示二月...
		一个星期的第一天是周日
   	Date的构造方法:
        public Date();创建一个Date对象,并初始化为当前时间
        	底层调用了有参构造,参数为System.currentTimeMillis()
        	public Date() {
        		this(System.currentTimeMillis());
    		}
        public Date(long date); 创建一个Date对象,并将其初始化为从起始时间到指定date毫秒值的时间
 */
public class DateDemo01 {
    public static void main(String[] args) {
        //1.
        Date date=new Date();
        System.out.println(date);//默认格式的时间:Thu Feb 24 08:53:57 CST 2022
        //2.
        long l=3600000;//一小时的毫秒值:1000*60*60
        Date date2=new Date(l);//1970 1月 1日 1:0:0--东八区+8时
        System.out.println(date2);//1970 1月 1日 9:0:0
    }
}

package day0221;
import java.util.Date;
/*
    Date 常用方法
     	getYear()--弃用,存在千年虫问题

     	long getTime()  获取的日期对象从1970年1月1日0:0:0到现在的毫秒值
     	void setTime(long time)  设置时间为给定毫秒值

 */
public class DateDemo02 {
    public static void main(String[] args) {
        Date d=new Date();
        /*
        千年虫问题:
           计算机用于表示年份使用的是两位十进制表示的,如果设置跨世纪处理运算的,就会出现千年虫问题
         */
        System.out.println(d.getYear()+1900);
        System.out.println(d.getMonth()+1);

        Date date1=new Date();
        System.out.println(date1.getTime());//获取的date1时间从1970年到现在的毫秒值
        //将date1设置毫秒值为3600000,现在的date1为
        date1.setTime(3600000);//1970.1.1  9:0:0
        System.out.println(date1.getTime()); //Thu Jan 01 09:00:00 CST 1970

    }
}

```

##### 2、SimpleDateFormat类

```java
package day0221;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
/*
SimpleDateFormat类:用于格式化和解析时间
  1.构造方法
     public SimpleDateFormat();构造一个SimpleDateFormat对象,使用默认日期格式
     public SimpleDateFormat(String pattern);使用给定格式pattern,格式化的日期(常用)
            y-年 M-月 d-月份中天数 E-星期中的天数
            H-一个天中的小时数  m-小时中的分数  s-分钟中的秒数
            W-月份中的周数   F-月份中的星期
            例如pattern:"yyyy/MM/dd HH:mm:ss E","yyyy年MM月dd日 HH时mm分ss秒 E"

  2.常用用法
      1.格式化(Date转为String)
      	public final String format(Date date)
      2.解析(String转为Date)
      	public Date parse(String source)
    */
public class SDFDemo01 {
    public static void main(String[] args) throws ParseException {
        /*
        格式化
        */
        //调用SimpleDateFormat无参构造创建对象,
        SimpleDateFormat sdf1=new SimpleDateFormat();//22-2-21 下午9:47
        //创建Date对象
        Date d1=new Date();
        System.out.println("Date类型对象时间:"+d1);
        //1.调用format方法传入一个Date对象进行默认格式化
        String str1=sdf1.format(d1);
        System.out.println("使用sdf无参构造格式化后:"+str1);//默认格式22-2-24 上午8:53
        
        //2.自定义格式化样式"yyyy/MM/dd HH:mm:ss E"
        SimpleDateFormat sdf2=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss E");
        String str2=sdf2.format(d1);
        System.out.println("使用sdf有参构造格式化后:"+str2);//2022/02/24 08:53:57 星期四

        /*
        解析
         */
        SimpleDateFormat sdf3=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        String str3="2021/01/21 19:23:09";
        //对上述的时间进行解析(针对于sdf3格式解析的),将字符串转为Date类型
        Date d=sdf3.parse(str3);
        System.out.println("通过对str3字符串解析后得到一个时间是"+sdf2.format(d));//输出时按照sdf2输出的
    }
}
```

##### 3、Calendar类

```java
package day0221;
import java.util.Calendar;
import java.util.GregorianCalendar;
/*
Calendar类: 提供操作日历字段的方法
     1.是一个抽象类,如果要创建的对象需要通过其子类对象来创建
         Calendar cal=new GregorianCalendar();
     2.也可以使用静态方法获取对象
         Calendar cal2=Calendar.getInstance();

     常用方法:
       1.public int  get(int field) 返回给定日历字段的值
       2.public abstract void add(int field,int amount);
       3.public Date getTime() 将Calendar时间类型转为Date并返回
       4.public final void set(int year,int month,int date)
 */
public class CalendarDemo01 {
    public static void main(String[] args) {
        //假设要把时间设置为2.15号.
        //1.计算出1970.1.1 0:0:0到2022年2月15日的毫秒值
        //2.用今天减去6天,
        //1
        Calendar cal=new GregorianCalendar();
        //2
        Calendar cal2=Calendar.getInstance();
        //获取年份
        System.out.println(cal2.get(Calendar.YEAR));//输出的是年份,Calendar.YEAR用于表示年份
        System.out.println(cal2.get(1));
        //获取月份(在月份基础上+1才是实际月份)
        System.out.println(cal2.get(Calendar.MONTH)+1);
        System.out.println(cal2.get(2)+1);
        //获取天数
        System.out.println(cal2.get(Calendar.DATE));
        System.out.println(cal2.get(Calendar.DAY_OF_MONTH));
        System.out.println(cal2.get(5));
        //获取周几(周日是第一天)
        System.out.println(cal2.get(Calendar.DAY_OF_WEEK));
    }
}
```

```java
package day0223;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
/*
Calendar中常用方法
    1.public int  get(int field)// 返回给定日历字段的值
    2.public abstract void add(int field,int amount);//根据日历的规则，将指定时间字段添加或者删除给定的amount值
    3.public Date getTime() //将Calendar时间类型转为Date并返回,因为Calendar表示时间是一大长串
    4.public final void set(int year,int month,int date)//设置年月日
 */
public class CalendarDemo01 {
    public static void main(String[] args) {
        Calendar c1=Calendar.getInstance();
        System.out.println(c1);//格式化和解析
        //SimpleDateFormat是将Date类型的日期，转为String,所有将Calendar转为Date
        Date d1=c1.getTime();
        //格式化是将Date的时间转为字符串
        SimpleDateFormat sdf=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        System.out.println(sdf.format(d1));

        c1.add(Calendar.DAY_OF_MONTH,-1);//月份减一
        Date d2=c1.getTime();
        System.out.println(sdf.format(d2));

        c1.add(Calendar.YEAR,1);//年份加一
        Date d3=c1.getTime();
        System.out.println(sdf.format(d3));

        c1.set(2000,1,27);//月份从0开始，1表示2月
        Date d4=c1.getTime();
        System.out.println(sdf.format(d4));
       }
}
```

```java
package day0223;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class CalendarTest01 {
    public static void main(String[] args) {
        //如何使用Calendar来实现判断某一年某一个月有多少天（2000.2)
        //1.调用Calendar中set设置年月日，设置为2000年3月1
        Calendar c1=Calendar.getInstance();
        c1.set(2000,2,1);//2000.3.1
        ///2.对天数进行减1
        c1.add(Calendar.DATE,-1);
        Date d3=c1.getTime();
        SimpleDateFormat sdf=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
        System.out.println(sdf.format(d3));
        //3.直接获取天数并输出即可
        System.out.println("该月有:"+c1.get(Calendar.DATE));
    }
}
```

##### 4、三种日期类型间的转换

```java
package day0223;
import java.util.Calendar;
import java.util.Date;
/*
总结:各日期类型间的转换
1.Date和String间的转换
    1.Date-->String:
        格式化使用的是SimpleDateFormat下的:
            public final String format(Date date)
    2.String-->Date:
        解析使用的是SimpleDateFormat下的:
            public Date parse(String source)

2.long和Date间的转换
    1.long-->Date:
        1.使用的Date有参构造转换:
            Date date=new Date(long time);
        2.使用Date下的public void setTime(long time):
            Date date = new Date();
            date.setTime(3600000);
            System.out.println(date);//Thu Jan 01 09:00:00 CST 1970
    2.Date-->long:
        使用的是Date的getTime()	

3.Date和Calendar间的转换
    1.Date-->Calendar:
    	使用的是Calendar中的setTime
    2.Date<--Calendar:
    	使用的是Calendar中的getTime

4.long和Calendar间的转换
    long-->Calendar:
    	操作方式:long-->Date-->Calendar
    Calendar-->long:
    	操作方式:Calendar-->Date-->long

 */
public class CalendarDemo02 {
    public static void main(String[] args) {
        //long-->Date:使用的是Date构造转换的！
        long l=3600000;
        Date d1=new Date(l);
        //Date-->long:使用的是Date的getTime()
        long l2=d1.getTime();
    }
}

```

#### 6、Exception异常类

```java
package day0223;
import java.text.SimpleDateFormat;
import java.util.Date;
/*
异常 :程序出现了不正常的情况
异常体系
    1.Error：严重问题，不需要处理(Java虚拟机无法解决的严重问题,资源耗尽，jvm系统内部出错)
    2.Exception:异常类，它表示本身可以处理的问题(编译期:.java---.class,运行期：执行.class)
         1.RuntimeException(运行时异常)
			 1.NullPointException -空指针异常
       			String str=null;
        		System.out.println(str.trim());
             2.NumberFormatException--数据转换异常
       			Integer i1=new Integer("anc");
        		System.out.println(i1);
             3.ClassCastException---类型转换异常
			 ......
         2.非RuntimeException(编译时异常), 在编译时必须处理，否则程序不能通过编译，就更不能运行了！

    3.异常处理机制一:try-catch-finally:捕获异常--可以自己处理
         try{
         	捕获异常的第一步，将可能出现异常的代码都放在try中
         }catch(Exception e){
         	在catch中对异常进行处理
         }finally{
         	捕获异常的最后一步,finally中的代码，不管上try中是否发生异常都会执行 
         }
     4.异常处理机制二:throws(抛出:自己不处理，给调用者处理)
         throws Exception 写在方法的声明处，指明方法在执行时，可能会出现异常
         一旦方法体执行，出现这个异常，调用者需要处理这个异常
 */
public class ExceptionDemo01 {
    public static void main(String[] args) {
		try{//可能会出现异常的代码
            String str="1987/01/09 13:14:52";
             SimpleDateFormat sdf=new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
             Date date= sdf.parse(str);
             throw  new RuntimeException();
     	}catch (ParseException e){//对上述代码中可能出现的异常进行描述
         	System.out.println("出了parseException啦！");
       		e.printStackTrace();//打印异常到控制台
        }catch (RuntimeException e){
            System.out.println("Runtime");
        }catch (Exception e){
            //多个异常时，如果异常没有关系,则谁在前在后没关系,如果异常有父子关系则，子在前后，父在后
        }
        finally {//永远都会被执行，
            System.out.println("finally");
        }
    }
}
```

#### 7、Object类

```java
package day0225;
import java.util.Date;
/*
Object类是java所有类的祖先类,每个类都是有它扩展而来的,但是不需要这样写class eoo extends Object,因为没有
明确指出父类的时候,默认Object是这个类的最终父类
1.toString()
    作用:用于返回表示对象的字符串,当输出对象时，默认调用的是toString方法；默认输出toString方法返回的值
      	根据源码可知,默认toString方法返回的是 "类名+@+16进制的hashCode"

      	建议:自定义类型的时候,重写toString
2.equals()
    作用:比较两个对象是否相同
     public boolean equals(Object obj) {
        return (this == obj);//比较的地址相同
     }
     根据源码可知,Object类中的equals比较的是两个对象是否是同一个对象
     
     注意:若需要实现比较内容,则需要重写该方法
3.hashCode(散列码)
    作用:是由对象导出的一个整数值,
    因为hashCode定义在Object类中,所以每个对象都有一个默认的散列码,其值为对象的存储对象
    建议:自定义类型的时候,重写hashCode();
 */
public class ObjectDemo {
    public static void main(String[] args) {
        System.out.println(new Date().hashCode());
        System.out.println(new Student("菜菜",18));
    }
}

```

#### 8、集合

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Collection单列集合系统框架.png)

>集合中是不能存放基本数据类型的,都是应用类型,看起来是存放的基本数据类型,实际上有自动装箱和自动拆箱的过程

##### 1、Collection接口(单列集合)

```java
package day0225;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
/*
Collection接口中的方法
   1.添加
       add(Object o);将元素o添加到集合中
       addAll(Collection c);将集合c中所有元素添加到当前集合中
   2.获取集合长度
       size();获取集合元素的个数
   3.清空集合元素
       clear();清空集合中所有的元素
   4.判断集合是否为空
       isEmpty();
   5.删除
       1.remove(Object o);调用o所在类的equals方法,比较集合中的每个元素,若返回为true则删除该元素,如果不判断为都false,则不删除任何元素;如果有多个相同元素,只会删除找到的第一个
       2.removeAll(Collection c); 去当前集合的差集(去掉当前集合与c集合中相同的元素)
   6.判断当前集合是否包含指定的元素
       1.contains(Object o);在判断的时候,会调用o的对象所在类的equals方法
       2.containsAll(Collection c);判断当前集合是否包含指定集合
   7. 数组和集合间的转换
       1.集合---数组:通过Collection中toArray将指定的集合转为数组
            Collection c1=new ArrayList();
            Object[] os= c1.toArray();
       2.数组---集合:通过Arrays中的asList()将指定的数组转为集合
     		Arrays.asList(arr);
 */
public class CollectionDemo01 {
    public static void main(String[] args) {
        Collection c1=new ArrayList();
        c1.add(10);
        c1.add(5.67);
        c1.add(false);
        c1.add(new Date());
        c1.add("代代");
        System.out.println("c1:"+c1);//默认调用toString()方法
        Collection c2=new ArrayList();
        c2.addAll(c1);
        c2.add('a');
        System.out.println("c2:"+c2);
        System.out.println("c2集合中元素的个数为:"+c2.size());
        c1.clear();
        System.out.println("c1清空后元素的个数为:"+c1.size());
        System.out.println("c1是否为空:"+c1.isEmpty());
    }
}

```

###### 1、Iterator迭代器

```java
package day0225;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
/*
集合的遍历
    迭代器Iterator:仅用于遍历集合,本身不提供存储对象的能力,(迭代器初始是指向集合前一位的位置)
       1.Object next() ;1.指针下移,2.将下移之后集合位置上的元素返回
       2.boolean hasNext();判断是否有下一个元素
       3.remove
         可以在遍历的时候删除集合中的元素
         如果还没有调用next或者调用next之后已经remove一次了
         再次调用remove会报错

    ListIterator用于list集合的迭代...

 */
public class CollectionDemo05 {
    public static void main(String[] args) {
        Collection c1=new ArrayList();
        c1.add("勇哥");
        c1.add("海子");
        c1.add("菜菜");
        Iterator i1=c1.iterator();
        /*
        Collection:
         Iterator iterator();用于获取指定的迭代器对象
         */
        while(i1.hasNext()){//判断是否有下一个元素
            //下移，并获取下一个元素
            Object o=i1.next();
            i1.remove();
            //i1.remove();
            System.out.println(o);
        }
        System.out.println(c1);
    }

}

```

###### 2、List接口,有序可重复

```java
1.ArrayList/LinkedList/Vector的异同
   1.线程安全:ArrayList/LinkedList两者都是线程不安全的,执行效率高
             Vector线程安全的
   2.底层实现
           ArrayList和Vector底层是基于动态数组的数据结构
           LinkedList基于双向链表的数据结构存储的
   3.功能性
           随机访问get和set ,ArrayList效率是优于LinkedList的,因为LinkedList要移动指针
           新增(特指插入)和删除操作,LinkedList效率会由于ArrayList，因为ArrayList要移动元素

2.ArrayList&Vector区别
   1.线程安全:ArrayList是线程不安全的,效率高;Vector线程不安全的,效率低
   2.底层创建数组长度问题,
            Vector创建对象的时候,底层就直接创建长度为10的数组
            ArrayList当JDK1.7的时候,创建对象底层会直接创建长度为10的数组
            ArrayList当JDK1.8的时候,当第一次调用add的时候,才会创建长度为10的数组
   3.扩容
     ArrayList扩容为1.5
     Vector扩容为2
```

>1.ArrayList:
>
>​			1.作为List接口的主要实现类，线程不安全的,效率高，**底层使用是数组**Object[] elementDate
>
>​			2.JDK7及以前:ArrayList list=new ArrayList();//底层创建一个长度为10的数组Object[] elementDate=new Object[10]; 如果添加导致数组容量不够了，则自动扩容并且将原数组中的内容复制过来默认情况下，每次扩容是原来容量的1.5倍   10*1.5;
>
>​			3.JDK8以后:ArrayList list=new ArrayList();底层创建一个数组Object[]  elementDate={};先不分配内存,等到第一次调用add添加元素时，底层才会给数组长度为10,并且elementDate[0]=111;扩容和后续操作与7一致

```java
package day0228;
import java.util.ArrayList;
/*
ArrayList新增的方法
    void add(int index,Object element);在指定的下标index处添加元素element
    boolean addAll(int index,Collection c);在指定的下标index处将集合添加进去,作为一个元素,size+1
    Object get(int index);用于返回指定下标处的元素
    int indexOf(Object obj);用于返回集合中第一次出现obj的位置.底层根据equals方法比较元素是否相同
    int lastIndexOf(Object obj);用于返回集合中最后一次出现obj的位置,...
    Object remove(int index);删除指定下标的元素,并返回删除的对象
    boolean remove(Object o);删除指定的元素o,并返回是否删除成功
    subString---截取字符串的(通过下标)
    subList--截取集合(通过下标)
    	List subList(int fromIndex,int toIndex);截取fromIndex到toIndex位置集合,并返回
 */
public class ArrayListDemo {
    public static void main(String[] args) {
        ArrayList list=new ArrayList();
        list.add(111);
        list.add(222);
        list.add(333);
        list.add(111);
        list.add(444);
        System.out.println(list);
        list.add(2,"AAA");//使用数组做的插入
        System.out.println(list);
        ArrayList list2=new ArrayList();
        list2.add("ttt");
        list2.add("ooo");
        list.add(3,list2);
        System.out.println("添加集合list2之后:"+list);
        System.out.println("list长度为:"+list.size());
        System.out.println("list中下标为2的元素是:"+list.get(2));
        System.out.println("list中第一次出现111的位置:"+list.indexOf(111));
        System.out.println("list中最后一次出现111的位置:"+list.lastIndexOf(111));
        System.out.println("list中删除444:"+list.remove(new Integer(444)));
        System.out.println("list中下标为2的元素删除:"+list.remove(2));
        System.out.println(list);
        System.out.println(list.subList(2,4));//截取的2,3(含头不含尾)
    }
}

```



>2.LinkedList:**底层使用双向链表**来存储，对于频繁的插入/删除操作，使用该类效率会比ArrayList高

```java
package day0228;
import java.util.LinkedList;
/*
LinkedList
   双向链表,内部没有声明数组的,而是定义Node类first和last,用来标记首末元素
    private static class Node<E> {
        E item;//本身这个元素
        Node<E> next;//表示下一个元素
        Node<E> prev;//表示上一个元素

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
 */
public class LinkedListDemo01 {
    public static void main(String[] args) {
        LinkedList list=new LinkedList();
        list.add(123);
        list.add("小泽玛利亚");
        System.out.println(list);
        /*
        常用方法:
           void addFirst()在集合开头插入元素
           void addLast()在集合的末尾追加元素
         */
        list.addFirst(111);
        System.out.println(list);
        list.addLast(666);
        System.out.println(list);
        /*
        Object getFirst();获取集合中第一个元素
        Object getLast();获取集合中的最后一个元素
         */
    }
}
```



>3.Vector:从JDK1.0就有,作为List接口的古老的实现类；线程安全的,效率低;**底层使用数组**
>
>​		1.Vector是一个古老的集合类型;JDK1.0就有了,大多数操作与ArrayList相同,区别就在于Vector是线程安全的(加锁synchronized);导致效率会比ArrayList低
>
>​		2.Vector在创建集合对象的时候,底层就直接创建长度为10的数组,Vector扩容问题,默认扩容为原来数组长度的2倍



###### 2、Set接口,无序不重复

>1.Set：Set接口是Collection子接口,Set没有提供额外的方法，和 List同级的接口--->List:有序可重复，Set:无序不可重复(无序指的是Set底层不是按照插入顺序存储的)
>
>​		Set（接口）------>HashSet（实现类） ---->LinkedHashSet（实现类）
>
>​		Set （接口）------>SortedSet（接口）---->TreeSet（实现类）
>
>2.HashSet: 是set接口的典型实现类,大多数使用set集合的时候,都会选择该类，HashSet底层:数组+链表，hashSet按照Hash算法算出存储位置的!		底层数组的初始长度16，当使用率超过原来长度的0.75;当第一次超过12的时候就会自动扩容到原来的两倍;16--->32--->64....
>
>3.HashSet不存入重复元素的规则：使用hashcode和equals。 那么HashSet是如何检查重复？其实原理：HashSet会通过元素的hashcode()和equals()方法进行判断，当试图将元素加入到Set集合中，HashSet首先会使用对象的hashcode()发放来获得该对象的HashCode值来判断对象加入的位置。同时也会与其他已经加入的对象的hashcode进行比较，如果没有相等的hashcode，HashSet就认为这个对象之前不存在，如果之前存在同样的hashcode值，就会进一步的比较equals()方法，如果equals()比较返回结果是true，那么认为该对象在集合中的对象是一模一样的，不会将其加入；如果比较返回的是false,那么HashSet认为新加入的对象没有重复，可以正确加入。 
>
>4.LinkedHashSet是HashSet的子类:  LinkedHashSet他使用双向链表来维护元素的顺序，使得元素看起来是按照插入顺序保存的

```java
package day0302_Set.inClass;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;

public class SetDemo01 {
    public static void main(String[] args) {
       Set hs=new HashSet();
       hs.add("小志");
       hs.add("iu");
       hs.add("海子");
       System.out.println( hs.add("iu"));//false,表示插入失败,代码编译是不会出错的!
       System.out.println(hs);//输出顺序：[小志, 海子, iu]

       HashSet<Student> hs1=new HashSet();
       hs1.add(new Student("小泽玛利亚",18));
       /*
        当向集合中添加'小泽玛利亚'这名学生对象的时候,先调用'小泽玛利亚'学生对象所在类的hashCode方法,计算出当前对象的hash值，此时hash值经过某种算法(比如%4)算出该元素在hashSet底层数组存储的下标(索引)，如果该下标处没有元素,则此时'小泽玛利亚'添加成功
        */
       hs1.add(new Student("波多野结衣",19));
       /*
       前提'小泽玛利亚'和'波多野结衣'两个对象通过某种特定算法得出下标一致，当'小泽玛利亚'添加成功,再添加'多波野结衣'我们就会发现指定的下标处有元素'小泽玛利亚'，当发现下标相同的元素时,需要判断两个元素是否是同一个对象,如果是则添加失败,反之添加成功
              1.比较两个元素的hash值
                 如果hash值不相同,则元素添加成功
                 如果hash值相同,则通过equals比较两个对象
              2.比较两个元素的equals方法
                 如果equals方法返回false,则'多波野结衣'添加成功
                 如果equals方法返回true,则添加失败

             七上八下（后添加的元素和先添加的元素的位置）
                JDK7:'波多野结衣'在'小泽玛利亚'上面
                JDK8:'波多野结衣'在'小泽玛利亚'下面

        */
       hs1.add(new Student("苍#null",17));

       /*
       LinkedHashSet是HashSet的子类:
            LinkedHashSet他使用双向链表来维护元素的顺序,
              是的元素看起来是按照插入顺序保存的,
        */
        Set hs2=new LinkedHashSet();
        hs2.add("小志");
        hs2.add("iu");
        hs2.add("海子");
        System.out.println( hs2);

    }
}

class Student implements  Comparable{
    String name;
    int age;
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age && Objects.equals(name, student.name);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
    /*
    需要学生类按照什么顺序排序
      根据名字或者年龄
      this当前对象: o对象
     */
    @Override
    public int compareTo(Object o) {
        if(o instanceof  Student){//o能够转为Student类则,比较内容
            //1.将o强转为Student
            Student s=(Student) o;
            //2.如果只想按照名字排序
           // return this.name.compareTo(s.name);默认升序
            // return -this.name.compareTo(s.name);//加-号表示降序
            //3.如果只根据年龄排序
            //return Integer.compare(this.age,s.age);//默认升序
           // return -Integer.compare(this.age,s.age);
            //4.如果先根据名字,再根据年龄排序
            int num=this.name.compareTo(s.name);//获取名字比较结果
            if(num==0){//判断名字比较结果是否为0,如果为0则表示名字相同,这个才会比较年龄
                return -Integer.compare(this.age,s.age);
            }else {
                return  num;
            }

        }else {//o如果不能转为Student类,则不需要比较
            throw  new RuntimeException("类型不匹配,无法比较");
        }
    }
}
```

>5.TreeSet: TreeSet是SortedSet的实现类,SortedSet是Set的子接口(TreeSet的查询速度比List还快)

```java
package day0302_Set.inClass;

import java.util.TreeSet;
/*
TreeSet是SortedSet的实现类,SortedSet是Set的子接口(查询速度比List还快,)
   1.TreeSet底层使用红黑树结构存储的
   2.TreeSet可以确保集合元素处于排序状态
   3.TreeSet两个排序方法:自然排序和定制排序
        自然排序:
           1.先让自定义类型实现自Comparable
           2.重写compareTo方法,根据自己需求去对不同属性进行排序
        定制排序
 */
public class SetDemo02 {
    public static void main(String[] args) {
        String str="";
        TreeSet set1=new TreeSet();
        set1.add("777");
        set1.add("333");
        set1.add("111");
        set1.add("222");//String实现了比较器接口
        System.out.println(set1);//[111, 222, 333, 777]会对元素排序

        TreeSet<Student> set2=new TreeSet();
        set2.add(new Student("333",20));
        set2.add(new Student("333",18));
        set2.add(new Student("333",19));
        System.out.println(set2);//因为Student没有实现比较器Comparable接口
    }
}
```

```java
package day0302_Set.inClass;

import java.util.Comparator;
import java.util.TreeSet;
/*
定制排序:Comparator
       1.创建Comparator定制排序的实例
 */
public class SetDemo03 {
    public static void main(String[] args) {
        //字符串定制降序排序
        //1.使用匿名内部类创建Comparator实例
        Comparator c1=new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //1.先判断o1和o2能否转为String
                if(o1 instanceof String && o2 instanceof String){
                    //2.强转
                    String s1=(String)o1;
                    String s2=(String)o2;
                    //3.做降序
                    return  -s1.compareTo(s2);
                }
                return 0;
            }
        };
        //需要将上述定制排序的实例传入TreeSet
        TreeSet set1=new TreeSet(c1);
        set1.add("777");
        set1.add("333");
        set1.add("111");
        set1.add("222");
        System.out.println(set1);
    }
}
```



##### 2、Map接口(双列集合)

>**Map接口**:双列数据,保存具有映射关系的"key-value"的集合(用于存储一对一对的数据)

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Map双列集合系统框架.png)

```java
package day0304;
import java.util.HashMap;
import java.util.Map;
/*
     HashMap:是map的主要实现类,线程不安全的,效率高
     Hashtable:是一个古老的map实现类,jdk1.0就有了,线程安全的,效率低,实现原理和功能都和HashMap相同
     TreeMap:
 */
public class MapDemo01 {
    public static void main(String[] args) {
       /*
        map常用方法
        1.添加
            Object put(Object key,Object value);  向集合去添加"ket-value"
        2.添加多个元素
            void putAll(Map map)   向当前集合中添加map集合的所有元素
        3.删除
            Object remove(Object key) 删除指定key对应的key-value键值对，并且返回value
            boolean remove(Object key,Object value)删除集合中指定的key和value对应的键值对,回返是否删除成功
        4.修改
         	1.可以通过put修改对应key的value值
         	2.Object replace(Object key,Object value);//返回被替换的value
         	3.boolean replace(Object key,Object oldValue,Object newValue)//返回是否替换成功
        5.元素的查询
         	Object get(Object key) 获取指定key所对应的value
        */
        Map map1=new HashMap();
        map1.put("波多野结衣",18);//key 和value组成对象加入
        map1.put("波多野结衣",20);//key 和value组成对象加入
        map1.put("苍#null",17);
        System.out.println(map1);
        Map map2=new HashMap();
        map2.putAll(map1);
//        System.out.println( map2);
//        System.out.println(map2.remove("波多野结衣"));
//        System.out.println(map1.remove("苍#null",22));
        System.out.println(map1.get("苍#null"));
    }
}
```

```java
package day0304;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
    6.获取map集合中的keys或者values
       Set keySet();key是不能重复的，所有用Set接收，返回map集合中所有的key
       Collection values();value可以重复，返回map集合中所有的value
       Set entrySet();返回集合中所有的key-value键值对构成的集合
 */
public class MapDemo02 {
    public static void main(String[] args) {
        Map map1=new HashMap();
        map1.put("波多野结衣",18);
        map1.put("小泽玛利亚",20);
        map1.put("苍#null",17);
        System.out.println("==========获取map1中所有的key");
        Set s=map1.keySet();
         for(Object o:s){
             System.out.println(o);
         }
        System.out.println("==========获取map1中所有的value");
         Collection c=map1.values();
         for (Object o:c){
             System.out.println(o);
         }
        System.out.println("==========获取map1中所有的key-value");
         Set s2=map1.entrySet();
         for(Object o:s2){
             System.out.println(o);
         }
    }
}
```

###### 1、HashMap

```java
package day0304;
import java.util.HashMap;
/*
HashMap底层实现原理
   底层结构
       1.JDK7：hashMap底层采用的是数组+链表
       2.JDK8：hashMap底层采用的是数组+链表+红黑树
       		同时二者的初始化时机不同，7在创建的时候就给出长度，8在第一次添加的时候才指定
   hashMap：当hashMap中添加元素超过数量大小的0.75自动扩容为原来的2倍
        
   HashMap有个子类叫LinkedHashMap;底层维护一个链表，用来使集合看起。来像是按照插入顺序存储的
 */
public class HashMapDemo {
    public static void main(String[] args) {
        HashMap hm=new HashMap();
        hm.put("多波野结衣",16);
        hm.put("苍#null",16);
        hm.put("多波野结衣",20);
        /*
           先调用‘波多野结衣’(key)所在类的hashCode()方法，计算出其hash值
           此时hash值经过某种特定的算法，计算出在数组中存放的位置
             如果指定位置没有元素，"多波野结衣"添加成功
             如果指定位置有元素，那么就去比较两个key所在类的hash值
                   如果hash值相同,比较两个对象的equals方法
                        如果equals方法比较返回false，则"多波野结衣"-16添加成功
                        如果equals方法比较返回true，则使用当前key对应value去替换原始value
                   如果hash值不相同,"多波野结衣"-16添加成功
         */
        System.out.println(hm);
    }
}
```

###### 2、Hashtable

>1.Hashtable是古老的map实现类，JDK1.0的时候就提供了，不同于HashMap
>  	Hashtable是线程安全的，效率低
>2.Hashtable与HashMap实现原理与功能相同。底层都是使用哈希表结构,查询速度会快,可以互相使用,因为HashMap不考虑线程是否安全，所有hashMap中可以使null作为key和value
>		HashMap hm=new HashMap();
>		hm.put(null,null);
>		System.out.println(hm);//hashMap中可以使null作为key和value
>		Hashtable ht=new Hashtable();
>		ht.put(null,null);//Hashtable中不可以是null作为key和value
>		System.out.println(ht);//

###### 3、Properties

```java
package day0304;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Properties;
/*
Properties作为Hashtable的子类，该类的对象用于处理属性文件
   由于属性文件里面的key和value都是String类型的，所以

key   value
 name=root
 pwd=123456
 url=jdbc：mysql...
 */
public class HashtableDmeo {
    public static void main(String[] args) throws Exception {
        //使用io流读取指定的配置文件(IO输入输出)
        //使用输入流读取指定的配置文件中的内容
        FileInputStream fis=new FileInputStream("jdbc.properties");
        //创建Properties对象用来读取配置文件
        Properties p=new Properties();
        //使用Properties对象加载指定的配置文件
        p.load(fis);
        //根据指定的key获取文件中的value
        /*
        String getProperty(String key);根据key获取配置文件中当前key对应的value
         */
        String username=p.getProperty("username");
        String password=p.getProperty("password");
        System.out.println(username+""+password);
    }
}
```

```java
package day0304;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.Properties;

public class HashtableDemo02 {
    public static void main(String[] args) throws Exception {
        //给指定文件创建输出流
        FileOutputStream fos=new FileOutputStream("jdbc.properties");
        //创建Properties对象
        Properties p=new Properties();
        //先设置key和value
        p.setProperty("url","jdbc");
        p.setProperty("username","root");
        //加载对用文件到Properties对象中
        //将设置key和value写出到文件中
        p.store(fos,"hashtable");
    }
}

```

###### 4、TreeMap

```java
package day0304;

import java.util.TreeMap;
/*
  自然排序
 */
public class TreeMapDemo {
    public static void main(String[] args) {
        TreeMap tm=new TreeMap();
        tm.put("444",10);
        tm.put("555",11);
        tm.put("111",12);
        System.out.println(tm);
        TreeMap tm2=new TreeMap();
        tm2.put(new User(20,"444",20),60);
        tm2.put(new User(2,"666",19),50);
        tm2.put(new User(6,"888",21),80);
        System.out.println(tm2);
    }
}
class User implements Comparable{
    int id;
  String name;
  int age;

    public User(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Object o) {
          if(o instanceof  User){
              User u=(User)o;
             // return -Integer.compare(this.id,u.id);id的降序
              return -this.name.compareTo(u.name);
          }else{
              throw  new RuntimeException("类型不匹配");
          }

    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

##### 3、Collections工具类

```java
package day0307;

import java.util.ArrayList;
import java.util.Collections;
/*
操作数组的工具类:Arrays;Array数组
操作集合的工具类:Collections;Collection集合
   Collections是一个操作set list map等集合的工具类
   Collections中提供了一系列静态的方法对集合进行排序 查询等操作
   排序操作:
      sort(List);根据元素的自然排序对指定的list集合按照顺序排序
      sort(List,Comparator);根据指定Comparator产生的顺序对list集合进行排序
      reverse(List);反转list集合中的元素顺序
      shuffle(List);对list集合的元素进行随机排序
 */
public class CollectionsDemo01 {
    public static void main(String[] args) {
        ArrayList list=new ArrayList();
        list.add("666");
        list.add("333");
        list.add("222");
        list.add("444");
        System.out.println("排序之前的list:"+list);
        Collections.sort(list);//根据元素的自然排序对指定list集合按照升序排序
        System.out.println("排序之后的list"+list);;
        Collections.reverse(list);
        System.out.println("反转之后的list"+list);
        Collections.shuffle(list);
        System.out.println("随机之后的list"+list);
//        ArrayList list2=new ArrayList();
//        list2.add(new Student("333",30));
//        list2.add(new Student("222",18));
//        Collections.sort(list2);//因为Student没有自然排序
//        System.out.println(list2);
//        //Collections.sort
    }
}
class  Student{
    String name;
    int age;
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

#### 9、File类

>File类(文件类)
>    	java.io.File类:**"文件"**和**"文件路径"**的抽象表现形式(一个File对象可以用来**表示一个文件或者目录**)
>    	File能新建/删除/重命名文件或者目录,但是不能访问文件中的内容,如果**需要访问文件内容**本身,需要**使用IO流**
>
>绝对路径:包含盘符在内的文件或者目录的路径
>相对路径:相较于某个路径下指明的路径

##### 1、File构造方法

```java
package day0307;
import java.io.File;
/*
File构造方法
   1.File(String filepath);以filepath为路径创建File对象,可以是绝对路径也可以是相对路径
   2.File(String parentPath,String childPath);以parentPath为父路径,以childPath为子路径创建对象
   3.File(File file,String childPath);根据一个父file对和一个子文件路径创建File对象
 */
public class FileDemo01 {
    public static void main(String[] args) {
        //1. File(String filepath);
        File f1=new File("D:\\vip09\\demo.txt");//不会考虑路径是否正确,在操作时才会检查路径是否正确
        File f2=new File("vip09.txt");//指的是项目路径下的vip09.txt文件对象
        //2.
        File f3=new File("D:\\vip09","demo.txt");
        //3.
        File f4=new File("D:\\vip09");
        File f5=new File(f4,"demo.txt");
    }
}

```

##### 2、创建对应的文件或目录

```java
package day0307;
import java.io.File;
import java.io.IOException;
/*
File普通方法
   1.创建对应的文件或者目录
       boolean createNewFile();创建文件;若指定路径下文件存在,则不创建返回false;若指定路径下文件不存在,则创建并返回true;指定文件的父级目录必须存在;否则报IOException提示父级目录找不到!!!!!!!
       boolean mkdir();创建文件目录,如果此文件目录的上层目录不存在,则创建失败,返回false
       boolean mkdirs();创建文件目录,如果此文件目录的上次目录不存在,一并创建,并返回true
   2.删除硬盘中相对应的文件或者目录
       boolean delete();如果file对象的路径表示的是一个文件,那么直接删除该文件,返回true,反之返回false,如果file对象的路径表示的是一个目录,那么先判断目录下是否有其他文件或者目录
            如果有则删除失败,返回false
            如果没有则删除成功,返回true
 */
public class FileDemo02 {
    public static void main(String[] args) throws IOException {
        //File f1=new File("D:\\vip09\\vip09_1.txt");
        File f2=new File("vip09.txt");
        //System.out.println("使用createNewFile创建f1:"+f1.createNewFile());报错,指定路径找不到
        System.out.println("使用createNewFile创建f2:"+f2.createNewFile());//2
        System.out.println("马上删除f2:"+f2.delete());//true,删除指定文件

        File f3=new File("D:\\vip09_mkdir\\aa\\dd\\cc");
        File f4=new File("D:\\vip09_mkdirs\\aa\\dd\\cc");
        System.out.println("使用mkdir创建目录:"+f3.mkdir());//false
        System.out.println("使用mkdirs创建目录:"+f4.mkdirs());//true
        System.out.println("使用delete删除f4:"+f4.delete());//一定是空的目录才可以删除!!!
    }
}
```

##### 3、获取路径或名字

```java
package day0307;
import java.io.File;
import java.io.IOException;
/*
3.获取
   获取绝对路径 String getAbsolutePath()
   获取路径String getPath()---获取的是创建File对象填入的路径
   获取名字String getName()---获取文件或者目录的名字
   获取上层文件目录的路径String getParent()--根据创建对象时填入路径
   获取文件长度(不能获取目录长度) long length();
 */
public class FileDemo03 {
    public static void main(String[] args) throws IOException {
        File f2=new File("vip09.txt");
        f2.createNewFile();
        File f4=new File("D:\\vip09_mkdirs\\aa\\dd\\cc");
        System.out.println("f2的绝对路径"+f2.getAbsolutePath());//获取绝对路径
        System.out.println("f2的路径:"+f2.getPath());
        System.out.println("f4的路径:"+f4.getPath());
        System.out.println("f2的名字"+f2.getName());
        System.out.println("f4的名字"+f4.getName());
        System.out.println("f2的上层目录:"+f2.getParent());
        System.out.println("f4的上层目录:"+f4.getParent());
        System.out.println(f2.length());
    }
}
```

##### 4、判断是否存在

```java
package day0307;
import java.io.File;
/*
4.判断
   判断文件是否存在  boolean isFile()
   判断目录是否存在  boolean isDirectory()
   判断是否存在      boolean exists()
 */
public class FileDemo04 {
    public static void main(String[] args) {
        File f2=new File("vip09.txt");
        File f4=new File("D:\\vip09_mkdirs\\aa\\dd\\cc");
        //判断文件是否存在  boolean isFile()
        System.out.println("判断f2文件是否存在:"+f2.isFile());//因为f2是一个文件所以返回true
        System.out.println("判断f4文件是否存在:"+f4.isFile());//f4是一个目录,所以返回false
       // 判断目录是否存在  boolean isDirectory()
        System.out.println("判断f2目录是否存在:"+f2.isDirectory());//f2是一个文件,所以返回false
        System.out.println("判断f4目录是否存在:"+f4.isDirectory());//f4是一个目录,所以返回true
        //判断是否存在      boolean exists()
        System.out.println("判断f2是否存在:"+f2.exists());//f2文件存在,所以返回true
        System.out.println("判断f4是否存在:"+f4.exists());//f4目录存在,所以返回true
    }
}
```

##### 5、获取子目录

```java
package day0307;
import java.io.File;
/*
5.获取子目录
    String[] list();获取指定目录下所有文件或者目录的名称
    File[] listFiles();获取指定目录下所有的文件或者目录对象
 */
public class FileDemo05 {
    public static void main(String[] args) {
        File f=new File("D:\\daijing");
        //String[] list获取指定目录下所有文件或者目录的名称
//        String[] names=f.list();
//        System.out.println("获取daijng目录下所有文件的名字:");
//        for(String s:names){
//            System.out.println(s);
//        }
        File[] fs=f.listFiles();
        System.out.println("获取daijing目录下所有文件对象");
        for(File file:fs){
            System.out.println(file.getAbsolutePath());
        }
    }
}
```

##### 6、删除指定目录

```java
package day0307;
/*
 删除指定目录:删除不经过回收站,慎删!!!!!!!!
        1.判断File对象对应的路径是否存在,不存在不删!
        2.如果存在,判断File对象是目录还是文件
              3.如果是文件则直接删除
              4.如果是目录,获取目录下所有的文件或者目录
                 5.遍历上述所有文件或者目录
                    6.判断遍历的File对象是否存在
                      7.如果存在则,判断遍历的File对象是文件还是目录
                       */
   //递归:程序自己调用自己的一种编程技巧

import java.io.File;
public class Test {
    public static void main(String[] args) {
        File f=new File("D:\\test");
        deleteFile(f);
    }

    public  static void deleteFile(File file){
        // 1.判断File对象对应的路径是否存在,不存在不删!
        if(!file.exists()){//file.exists()返回false表示不存在,不存在则方法结束,不删
            return;//
        }
        //2.如果存在,判断File对象是目录还是文件
        if(file.isFile()){// 3.如果是文件则直接删除
            file.delete();
        }else if(file.isDirectory()){//4.如果是目录,获取目录下所有的文件或者目录
            //获取目录下所有的内容
            File[] fs=file.listFiles();
            // 5.遍历上述所有文件或者目录
            for(File f:fs){
                deleteFile(f);
            }
        }
        /*
        当把目录下所有文件删除后,该目录也删除
         */
        file.delete();
    }
}

```



#### 10、I/O流

>1. IO流(Input输入/Output输出): 用来操作文件内容的技术,输入输出**都是针对程序**来说的
>
> >1.假设需要将D盘中的dd.txt文件中的内容读取到java程序中来(Input输入)
> >2.假设程序需要将字符串等内容写入到D盘中的dd.txt文件(output输出)
> >3.**I(input):**从文件中读取内容到程序, **O(output):**将数据写出到文件中
>
>1.  IO的分类
>
>	> 1.按照数据流向分:**输入流和输出流**
>	>
>	> > 1.输入流:将文件中的内容读取到程序中
>	> > 2.输出流:将程序中的数据写出到文件中
>	>
>	> 2.按照数据类型: **字节流和字符流**
>	>
>	> >1.字节流:以字节为单位进行的
>	> >2.字符流:以字符为单位进行的,操作中文字符更方便
>	>
>	> ​     输入流       输出流
>	> ​    字节流       字符流
>	> ​    字节输入流InputStream       字节输出流 OutputStream
>	> ​    字符输入流Reader            字符输出流 Writer
>	>
>	> 3.按照流的角色:节点流  处理流
>	>
>	> > 1.节点流:程序用于直接操作目标设备所对应的流
>	> > 		1.**文件流**是一种直接用于**操作文件的节点流**
>	> >   		  	文件字符输入流FileReader   文件字符输出流FileWriter  
>	> >       	  	文件字节输入流FileInputStream  文件字节输出流FileOutputStream
>	> >
>	> > ​		2.**数组流** ：对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）
>	> > ​                 字节数组:**ByteArrayInputStream、 ByteArrayOutputStream、**
>	> > ​				字符数组:**CharArrayReader、CharArrayWriter**
>	> >
>	> > ​		3.**字符串流**：对字符串进行处理的节点流
>	> > ​				StringReader、 StringWriter 
>	> >
>	> > ​		4.**管道流**：对管道进行处理的节点流
>	> > ​				PipedInputStream、PipedOutputStream、
>	> > ​				PipedReader、PipedWriter 
>	> >
>	> > 2.处理流:通过一个间接流去调用节点流,以达到更加灵活方法的读写操作,这个间接的流就是处理流
>	> >        **1.Buffered缓冲流:**是一种处理流,缓冲流不能直接操作文件,必须文件流访问,效率要比文件流效率高
>	> >    		 缓冲字符输入流 BufferedReader     缓冲字节输入流 BufferedInputStream
>	> >    		 缓冲字符输出流 BufferedWriter     缓冲字节输出流 BufferedOutputStream
>	> > 	   **2.对象流:**按照**对象或基本类型模式**往文件中写入读取内容,是一种**处理流**(使用的时候**需要创建节点流(文件流)**)
>	> > 			  对象输入流ObjectInputStream       对象输出流ObjectOutputStream
>	> > 	  **3.转换流:**提供字节流与字符流之间的转换
>	> > 				InputStreamReader:将字节输入流转换成字符输入流
>	> > 				OutputStreamWriter:将字节输出流转换成字符输出流
>	> > 	  **4.打印流:**将基本类型数据或者其他类型,**转化字符串**输出
>	> > 			  **字符打印流PrintWriter:**可以按行写出字符串到**文件**或者控制台(System.ou),并且可以自动刷新
>	> > 			  **字节打印流PrintStream:**打印的所有字符都是使用平台默认字符编码转为字节(不常用)					



##### 1、文件字符流FileReader/Writer

>1.输入流中的方法:
>            int read();返回读入的一个字符(返回是字符对应码),如果达到文件末尾,返回-1
>			int read(char[] chs);返回每次从文件读取输入到数组中字符的个数,如果返回值为-1则表示读到文件末尾
>
>2.输出流中的方法:
>            void write(int c);向文件中写入一个字符
>      	  void write(char[] chs,int off,int length);写入字符数组中chs的一部分,off表示从那个位置开始写,length表示长度

```java
ackage day0309;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
/*
    将一个test.txt文件中的内容,读到程序,然后通过程序写出到另一个test_copy.txt文件中
    因为文件内容中涉及中文,建议字符流
    案例使用:文件字符流FileReader/FileWriter
    字符流一般用于处理文本文件  txt java word .c
 */
public class FileIODemo01 {
    public static void main(String[] args) {
        FileReader fr=null;
        FileWriter fw=null;
        try {
            //1.创建文件对象
                File scrFile=new File("D:\\test.txt");//源文件
                File descFile=new File("D:\\test_copy.txt");//目标文件
            //2.创建流(源文件进行读,目前进行写)
                fr=new FileReader(scrFile);//针对源文件创建输入流,因为要读取源文件中的内容
                fw=new FileWriter(descFile);//针对目标文件创建输出流,因为要想目标文件中写出内容
            //3.数据的读写
                //方法一:循环单个字符读取源文件中的内容,如果没有读到末尾,就将读到的内容写出到目标文件
                int data;//用于存储读取到的内容
                while((data=fr.read())!=-1){//如果读到内容不等于-1表示没有到文件末尾,
                    //则需要向目标文件中写入读取到内容
                    fw.write(data);
                }
            
                //方法二:利用字符数组容器来读取和写入;提高速率
                char[] chs=new char[10];//容器,用来装字符
                int length;//用于存储每次读取到数组中的字符的个数
                while((length=fr.read(chs))!=-1){//每次读取个数不等于-1,表示没有读到文件末尾
                    //将字符数组中的内容写出到目标文件
                    fw.write(chs,0,length);
                }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }finally {
           //4.流的关闭()
           if(fr!=null){//防止空指针异常
               try {
                   fr.close();
               } catch (IOException e) {
                   e.printStackTrace();
               }
           }
           if (fw!=null){
               try {
                   fw.close();
               } catch (IOException e) {
                   e.printStackTrace();
               }
           }
        }
    }
}
```

##### 2、文件字节流FileInput/OutputStream

>1.输入流中的读取方法
>		int read()读取一个字节并返回,若为-1表示读到文件末尾
>		int read(byte[] bs )返回每次输入数组中的字节个数,如果到文件末尾则返回-1
>
>2.输出流的写入方法
>		void write(int data)写入一个字节,
>        void write(byte[] bs,int off,int length);写入字节数组bs的一部分,off表示从哪里开始写 length表示写多长

```java
package day0309;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
/*
 字节流一般用于处理非文本文件(.png .mp3 .mp4 .avi)
    案例:复制demo.mp4到demo_copy.mp4
 */
public class FileIODemo02 {
    public static void main(String[] args) throws Exception {
        //1.创建文件对象
        File srcFile=new File("D:\\demo.mp4");
        File descFile=new File("D:\\demo_copy.mp4");
        //2.创建流
        FileInputStream fis=new FileInputStream(srcFile);
        FileOutputStream fos=new FileOutputStream(descFile);
        //3.读写
        byte[] bs=new byte[10];
        int length;
        while((length=fis.read(bs))!=-1){
            fos.write(bs,0,length);
        }
        //4.关闭流
       	fis.close();
        fos.close();
    }
}
```

##### 3、缓冲字节流BufferedInput/OutputStream

```java
package day0309;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
/*
	在使用文件字节流做复制的时候,速度很慢,使用缓冲字节流来实现赋值
 */
public class BufferedIODemo01 {
    public static void main(String[] args) throws Exception {
        //1.创建文件
        File srcFile=new File("D:\\demo.mp4");
        File descFile=new File("D:\\demo_copy.mp4");
        //2.创建流(最终使用的是缓冲流)
            //2.1先创建文件流(文件字节流)
            FileInputStream fis=new FileInputStream(srcFile);
            FileOutputStream fos=new FileOutputStream(descFile);
            //2.2再根据文件流创建缓冲流(缓冲字节流)
            BufferedInputStream bis=new BufferedInputStream(fis);
            BufferedOutputStream  bos=new BufferedOutputStream(fos);
        //3.读写
        byte[] bs=new byte[10];
        int length;
        while((length=bis.read(bs))!=-1){
            bos.write(bs,0,length);
        }
        //4.关闭流
        //直接关闭外层流
        bos.close();
        bis.close();
    }
}
```

##### 4、随机流RandomAccessFile

```java
package day0309;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets;
/*
随机流:
     1.RandomAccessFile类支持随机访问,程序可以直接跳到文件的任意地方来读/写文件
     		RandomAccessFile对象包含一个记录指针,用于标记当前读写的位置,并且可以自由的移动记录指针
     2.关于指针的方法:
         long getFilePointer();获取文件记录指针的当前位置
         void seek(int pos);将文件记录指针定位到pos位置
     3.构造器
         public RandomAccessFile(File file,String mode);
         mode参数:该参数指定RandomAccessFile的访问模式
            r:以只读方式打开
            rw:以读写的方式打开
            rwd:以读写的方式打开,同步文件内容更新
            rws:以读写的方式打开,同步文件和元数据内容更新
 */
public class RandomIODemo01 {
    public static void main(String[] args) throws Exception {
        //1.创建文件
        File file=new File("D:\\test.txt");
        //2.创建流
        RandomAccessFile raf=new RandomAccessFile(file,"rw");
        //3.读写
        //3.1移动记录指针到4位置
        raf.seek(4);
        //3.2将4以后的内容存储起来,
        //需要读取文件中内容,然后将内容拼接;字符串拼接
        //3.2.1创建StringBuilder对象用来存储后续内容
        StringBuilder sb=new StringBuilder();
        //3.2.2读取4以后文件内容
        byte[] bs=new byte[10];
        int length;
        while((length=raf.read(bs))!=-1){
            //3.2.3将读取到的内容转换成字符串
            String str=new String(bs,0,length);
            // 3.2.4将读取到的内容拼接到sb中
            sb.append(str);
        }
        //3.3再将指针移到4的位置
        raf.seek(4);
        //3.4将0写入
        raf.write('0');
        //3.5将存储到sb中内容写入到文件中
        //3.5.1现将sb中的内容转为String
            String s=sb.toString();
        //3.5.2再把String转为byte数组
            byte[] s_bs=s.getBytes();
        //3.5.3再把byte数组写入到文件中
            raf.write(s_bs);
        //4.关闭流
        raf.close();
    }
}
```

##### 5、对象流(ObjectInput/OutputStream)

>1.对象流:按照**对象或基本类型模式**往文件中写入读取内容,是一种**处理流**(使用的时候**需要创建节点流(文件流)**)
>		对象输入流ObjectInputStream  
>		对象输出流ObjectOutputStream
>
>2.序列化:用ObjectOutputStream类保存对象的机制;自定义对象写入到文件时,该类要实现序列化接口(Serializable)
>3.反序列化:用ObjectInputStream类读取对象的机制;
>
>注意:文件内的内容还是乱码的;属于正常,不影响读写

```java
package day0311;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Date;
import java.util.Objects;

//序列化的案例
public class ObjectDemo01 {
    //java程序--->文件  ObjectOutputStream
    public static void main(String[] args) throws IOException {
        //1.创建文件对象
        File f=new File("D:\\test.txt");
        //2.创建流
        //2.1创建节点流(因为对象流是字节流,所以需要创建文件字节输出流作为节点流)
        FileOutputStream fos=new FileOutputStream(f);
        //2.2通过节点流创建对象流
        ObjectOutputStream oos=new ObjectOutputStream(fos);
        //上述操作结合
        //ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(new File("D:\\test.txt")));
        //3.写
        oos.writeInt(10);
        oos.writeBoolean(true);
        oos.writeDouble(7.18);
        oos.writeObject(new Date());
        oos.writeObject(new User("小泽",19));//写入自定义类型的对象
        //4.关流
        oos.close();
        
        //读取,反序列化的案例
        //1.创建文件对象
        //2.创建对象流
ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File("D:\\test.txt")));
        //3.读
        int a=ois.readInt();
        System.out.println(a);
        boolean b=ois.readBoolean();
        System.out.println(b);
        double d=ois.readDouble();
        System.out.println(d);
        Date date=(Date)(ois.readObject());
        System.out.println(date);
        User u=(User)ois.readObject();
        System.out.println(u);
        //读取时,应该按照写入顺序读取,否则会破坏编码结构
        //4.关闭流
        ois.close();
    }
}
//实现序列化接口Serializable
class User implements Serializable {
    String name;
    int id;

    public User(String name, int id) {
        this.name = name;
        this.id = id;
    }
}

```

```java
package day0311;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
/*
如果采用一个对象一个对象的写,非常复杂,有没有什么办法可以这些一个个对象存起来,然后一次性写入?
    答:集合,因为集合本身就是一个对象
 */
public class ObjectDemo03 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //1创建文件 //2创建流
        ObjectOutputStream oos=new ObjectOutputStream(
                new FileOutputStream(new File("D:\\test.txt")));
        //3写
        ArrayList list=new ArrayList();
        list.add(1);
        list.add(false);
        list.add(new User("波多",19));
        list.add("蕾好呀");
        oos.writeObject(list);
        //4关流
        oos.close();

        //读
       ObjectInputStream ois = new ObjectInputStream(
                                new FileInputStream(new File("D:\\test.txt")));
        ArrayList arrayList=(ArrayList) ois.readObject();
        for(Object o:arrayList){
            System.out.println(o);
        }
        ois.close();
    }
}

```

##### 6、转换流(Input/OutputStreamReader/Writer)

>1.转换流: 转换流提供了字节流与字符流之间的转换; java api 中提供两个转换流:
>	InputStreamReader:将InputStream转为Reader;实现将字节输入流**按照指定字符集编码**转为字符输入流
>	OutputStreamWriter:将Writer转为OutputStream;实现将字节输出流按**照指定字符集编码**转为字符输出流
>
>**编码**:字符 -->字节 （是字符转字节的过程）
>**解码**:字节–>字符（是字节转字符的过程）
>**乱码的原因：**①编码与解码的字符集不统一;②解码的字符数与编码的字符数不一样

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\转换流原理图.png)

```java
package day0311;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

public class ISR_OSW_Demo01 {
    public static void main(String[] args) throws IOException {
        //1.创建文件
        File f=new File("D:\\test.txt");
        File ff=new File("D:\\test_copy.txt");
        //2.创建流
        //2.1创建节点流
        FileInputStream fis=new FileInputStream(f);
        FileOutputStream fos=new FileOutputStream(ff);
        //2.2创建转换流
        InputStreamReader isr=new InputStreamReader(fis,"gbk");//按照gbk解码读数据
        OutputStreamWriter osw=new OutputStreamWriter(fos,"utf-8");//按照utf-8编码写数据

        //3.读写
         char[] chs=new char[10];
         int length;
         while((length=isr.read(chs))!=-1){
             osw.write(chs,0,length);
         }
        //4.关流
        isr.close();
         osw.close();
    }
}

```

##### 7、打印流(PrintWriter/Stream)

>**打印流:**将基本类型数据或者其他类型,**转化字符串**输出
>    	字符打印流PrintWriter:可以按行写出字符串到**文件**或者控制台(System.ou),并且可以自动刷新
>    	字节打印流PrintStream:打印的所有字符都是使用平台默认字符编码转为字节(不常用)
>
>如果启用了**自动刷新**，则只有在调用 `println`、`printf` 或 `format` 的其中一个方法时才可能完成此操作。如果没有启用自动刷新，则需要手工调用flush()方法才能完成刷新。
>
>```java
>//打印到控制台,需要手动刷新缓存
>PrintWriter printWriter = new PrintWriter(System.out);
>printWriter.print("你好啊");
>printWriter.flush();
>```

```java
package day0311;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Scanner;

public class PWDemo01 {
    public static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException {
        //1.创建文件
        File f=new File("D:\\大锤.txt");
        //2.创建流
       // PrintWriter pw=new PrintWriter(f);
        //2.1节点流(操作字节)
        FileOutputStream fos=new FileOutputStream(f,true);
        //2.2转换流(操作字符)
        OutputStreamWriter osw=new OutputStreamWriter(fos,"utf-8");
        //2.3缓冲流(提高效率)
        BufferedWriter bw=new BufferedWriter(osw);
        //2.4打印流(可以自动刷新功能)
        //autoFlush表示是否自动刷新
        PrintWriter pw=new PrintWriter(bw,true);
        //3.做输出
        //pw.println("good good study ,day day up");
        //
        System.out.println("请输入要存入大锤文件中的内容:");
        Scanner scan=new Scanner(System.in);
        while(true){
            String line=scan.nextLine();
            if("eixt".equals(line)){
                break;
            }
            //打印到文件中
            pw.println(line);
        }
        //4.关闭流
        pw.close();
    }
}
```

#### 11、Thread线程(兴趣班的课)

Thread实现了Runnable接口,并重写了run()方法(具体实现如下),target是在通过有参构造方法创建Thread时传入的Runnable实现类对象,我们实现Runnable的时候就必须实现接口的抽象类

```java
//Thread实现的类Runnable接口的run()方法
public void run(){
	if(target != null){
		target.run();
	}
}
```

>程序: 为了某个特定任务,用某种语言编写的一组指令.就是一段**静态**的代码
>进程: 程序的**一次执行**过程,是一个**动态**的过程:有开始 存在 和死亡----生命周期
>线程: 进程可以分为多个线程
>
>并发: 一个cpu同时执行多个任务;比如秒杀,
>并行: 多个cpu同时执行多个任务
>
>多线程, 多线程优点:
>      1.效率高:提高应用程序的响应
>      2.提高计算机系统的cpu利用率
>      3.改善程序结构

##### 1、创建线程的方法

​		1.Thread在java中用来表示线程类的,里面包含了用来表示线程运行过程的方法run(),需要当前线程运行时执行什么操作就在run方法中写上就行,启动线程调用的是start(), 在启动线程之后,当**线程分配到系统资源和时间片**后会自动调用run()

​		2.在jdk 的api 中明确说明了创建线程的方式有两种:
​				a.声明一个类去继承 Thread 类,同时重写 run 方法 
​				b. 声明一个类去实现 Runnable 接口,同时实现 run 方法
​				其他的像Callable,线程池创建线程等等的方式都是在这二者之上进行了封装

###### 1、继承Thread,重写run();

```java
package day0314;
/*   
	1.java如何实现多线程:方法一
        1.写一个自定义类型,继承Thread        2.重写run方法
        3.创建对象                         4.启动线程
   	2.弊端:
        1.限制类的继承关系 		2.数据没有办法共享
 */
public class ThreadDemo01 {
    public static void main(String[] args) {
        //创建多个线程对象
        ThreadTest test1=new ThreadTest();
        ThreadTest test2=new ThreadTest();
        //手动启动线程
        test1.start();
        test2.start();
    }
}
class ThreadTest extends Thread{
    int i=10;
    @Override
    public void run(){
        for(;i>=0;i--){
            System.out.println(getName()+":"+i);
        }
    }
}
```

###### 2、实现Runnable接口,实现run();

>1.实现Runnable接口比继承Thread所有具有优势
>  	1.可以避免java中**类的单一继承**的限制,一个类可以实现多个接口
>  	2.增加程序强壮性,**代码可以被多个线程共享**(使用同一个Runnable实例对象做为参数的话)
>  	3.适合多个相同的程序代码的线程处理同一个资源,
>  	4.线程池只能放入实现Runnable接口的线程,不能直接放继承Thread的线程
>  

```java
package day0314;
/*
创建多线程方法二,实现接口Runnable:因为Runable类型可以做为Thread类构造方法的参数,创建线程
      1.写一个类,实现Runnable接口
      2.重写run方法
      3.创建实例
      4.调用start方法
 */
public class ThreadDemo02 {
    public static void main(String[] args) {
        //3.创建实例
        //3.1创建Runnable实例
        RunnableTest test1=new RunnableTest();
        //3.2将Runnable实例当做参数传入Thread对象中
        Thread t1=new Thread(test1);
        Thread t2=new Thread(test1);
        Thread t3=new Thread(test1);
        Thread t4=new Thread(test1);
        //通过上述不管创建少次,都可以看出t1还是t2...都是根据test1创建的线程对象
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
//  1.写一个类,实现Runnable接口
class RunnableTest implements  Runnable{
    int i=10;
    //  2.重写run方法
    @Override
    public void run() {
        for(;i>=0;i--){
            //currentThread()获取当前线程
System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}
```

###### 3、匿名内部类

```java
new Thread(new Runnable() {
    @Override
    public void run() {
                
    }
}).start();

new Thread(){
    @Override
    public void run() {
                
    }
}.start();
```

###### 4、通过Callable和Future创建线程

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Callable的继承图.jpg)

```java
/*
java实现多线程方法一
    继承Thread类
java实现多线程方法二
   实现Runnable接口
   第二种的变种:匿名内部类
java实现多线程方法三
    实现Callable接口
java实现多线程方法四
    线程池的方式

 实现callable方式和Runnable方式的优势
    1.Call可以有返回值
    2.Call可以抛出异常,可以被调用者捕获异常,从而获取更多的异常信息
    3.Callable支持泛型
 */
public class ThreadDemo03 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //3.创建Callable实例对象
        CallTest ct=new CallTest();
        //4.创建FutureTask对象，讲上述callable实例传入到构造中
        FutureTask ft=new FutureTask(ct);
        //5.创建Thread对象，将上述FutureTask实例传入到构造中
        Thread t=new Thread(ft);
        //6.启动线程
        t.start();
     /*
      在call方法中返回值是通过FutureTask对象调用get方法获取的
      */
        System.out.println("call方法的返回值是:"+ft.get());
    }
}
//1.创建一个类实现Callable接口
class CallTest implements Callable{
        //2.重写call方法
    @Override
    public Object call() throws Exception {
        int sum=0;
        for(int i=0;i<=100;i++){
            sum+=i;
        }
        return sum;
    }
}
```

###### 5、线程池

```java
package day0323;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingDeque;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/*
java实现多线程方法一
    继承Thread类
java实现多线程方法二
   实现Runnable接口
   第二种的变种:匿名内部类
java实现多线程方法三
    实现Callable接口
java实现多线程方法四
    线程池的方式

    线程池背景
      经常在创建和销毁线程,如果使用量特别大,会影响性能
    思路
      提前创建好多个线程,放入到线程池中,使用的时候直接从线程池中获取;
      使用完了之后放回线程池中,可以避免频繁的创建和销毁,实现重复利用

   java中的线程池
    JDK5.0提供了线程池相关api ExecutorService和Executors
    ExecutorService:线程池接口,常见子类ThreadPoolExecutor
    可以通过构造方法线程池
     使用给定的参数和默认的饱和策略,默认的工厂方法创建线程池
    public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue

   void execute(Runnable command);执行任务/命令,没有返回值一般用于执行Runnable


    Executors    :线程工具类,用于创建并返回不同类型的线程池

 */
public class ThreadDemo01 {
    public static void main(String[] args) {
        //队列
        BlockingQueue<Runnable> queue=new ArrayBlockingQueue<>(10);
        //通过构造方法自定义线程池
        ThreadPoolExecutor pool=new ThreadPoolExecutor(3,
                5,60, TimeUnit.MICROSECONDS,queue);

        /*
        Thread:是线程类型

        Runnable是线程类型?
        //1.创建Runnable实例,
        //2.将Runnable实例传入到Thread构造中,通过Thread构造创建线程对象
         */
        //循环创建10个线程,通过线程池去启动
        for (int i=0;i<10;i++){
            PoolTest pt=new PoolTest(i);
            //
            pool.execute(pt);
        }
        //关闭线程池
        pool.shutdown();
    }
}
class PoolTest implements  Runnable{
    int num;//表示任务的编号

    public PoolTest(int num) {
        this.num = num;
    }

    @Override
    public void run() {
        System.out.println("当前是第"+num+"号任务:"+Thread.currentThread().getName());
    }
}
```

```java
package day0323;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/*
 Executors    :线程工具类,用于创建并返回不同类型的线程池
     创建一个可以根据需要创建新线程的线程池,会回收空的线程
       newCachedThreadPool()
     创建一个固定长度的线程池，当达到线程池最大数量，线程池中规模是不会会发生变化
       newFixedThreadPool(int)
     创建一个单线程的线程池
        newSingleThreadExecutor()
 */
public class ThreadDemo02 {
    public static void main(String[] args) {
       // test01();
        test02();
    }

    //创建一个可以根据需要创建新线程的线程池
    public static void test01(){
        //1.根据工厂类型创建需要的线程池
        ExecutorService service=Executors.newCachedThreadPool();
        //2.执行10个Runnable任务
        for(int i=1;i<=10;i++){
            PoolTest pt=new PoolTest(i);
            service.execute(pt);
        }
        //3.关闭线程池
        service.shutdown();
    }
    //
    //创建一个单线程的线程池
    public static void test02(){
        //1.根据工厂类型创建需要的线程池
        ExecutorService service=Executors.newSingleThreadExecutor();
        //2.执行10个Runnable任务
        for(int i=1;i<=10;i++){
            PoolTest pt=new PoolTest(i);
            service.execute(pt);
        }
        //3.关闭线程池
        service.shutdown();
    }
}

```



##### 2、线程的生命周期

###### 1、生命周期状态一

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\线程的生命周期.PNG)

```java
/*
线程几种状态
1.新建状态(new)
   当使用new关键字创建线程实例后，该线程就处于新建状态，但是不会执行
   Thread t=new Thread();
2.就绪状态
   当调用start()方法时，该线程就处于就绪状态，表示可以执行，但是不一定会立即执行
   而是等待cpu分配时间片进行处理
   t.start();
3.运行状态
    当cpu为该线程分配到时间片，执行该线程的run()时，线程就处于运行状态
4.暂停状态（休眠。等待。阻塞）
   当线程调用sleep或者wait或者io阻塞，主动放弃cpu时间片，就进入暂停状态
5.死亡
  当线程run方法执行完，或者抛出异常，线程就死亡了~
 */

1. new（新建）：线程刚刚被创建，但并未启动          **实例化线程对象时的初识状态**
2. runnable（可运行状态）：线程可能正在运行，也可能没有，取决于是否占用了cpu    **启动线程（start方法）**
3. blocked（阻\堵塞）：当前没有获取锁，当该线程持有锁时，就从堵塞状态转为runnable状态
4. waiting（无限等待）：前面发生车祸，后面的车辆不知道何时可以运行，等着吧
5. timed waiting（超时等待）：红灯时等待，绿灯时运行      **线程调用sleep方法时发生**
  唤醒（通知）：notify( )  or  notifyAll( )
6. teminated（终止）：run方法正常结束后，当前线程死亡 
```

###### 2、生命周期状态二

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\线程生命周期.png)

```java
/**
* @author muzi@softeem.com
* @description 线程状态1
* @since 2021/4/15 16:09
*/
public class ThreadStatusDemo1 implements Runnable{
    public static void main(String[] args) {
        ThreadStatusDemo1 threadStatusDemo1 = new ThreadStatusDemo1();
        Thread thread1 = new Thread(threadStatusDemo1);
        Thread thread2 = new Thread(threadStatusDemo1);
        thread1.start();
        thread2.start();
        try {
        	Thread.sleep(10);
        } catch (InterruptedException e) {
        	e.printStackTrace();
        }
        //TIMED_WAITING 因为thread1在sleep(1000)
        System.out.println("线程1处于:"+thread1.getState());
        //BLOCKED 因为thread2想获得synchronized锁
        System.out.println("线程2处于:"+thread2.getState());
        try {
        	Thread.sleep(1200);
        } catch (InterruptedException e) {
        	e.printStackTrace();
        }
        System.out.println("===============");
        //WAITING 因为thread1在wait()
        System.out.println("线程1处于:"+thread1.getState());
        //TIMED_WAITING 因为thread2在sleep(1000)
        System.out.println("线程2处于:"+thread2.getState());
	}
    @Override
    public void run() {
        test();
    }
    
    private synchronized void test(){
        try {
            System.out.println(Thread.currentThread().getName());
            //休眠1s
            Thread.sleep(1000);
            wait();
        } catch (Exception e) {
        	e.printStackTrace();
        }
    }
}
/**
* @author muzi@softeem.com
* @description 线程状态2
* @since 2021/4/15 16:28
*/
public class ThreadStatusDemo2 implements Runnable{
    public static void main(String[] args) {
        ThreadStatusDemo2 threadStatusDemo2 = new ThreadStatusDemo2();
        Thread thread = new Thread(threadStatusDemo2);
        //NEW
        System.out.println(thread.getState());
        thread.start();
        //RUNNABLE
        System.out.println(thread.getState());
        try {
        	Thread.sleep(1);
        } catch (InterruptedException e) {
        	e.printStackTrace();
        }
        //主线程休眠之后:RUNNABLE Ready + Running
        System.out.println("主线程休眠之后:"+thread.getState());
        try {
        	Thread.sleep(10);
        } catch (InterruptedException e) {
        	e.printStackTrace();
        }
        //TERMINATED 结束状态
        System.out.println("线程执行完run方法之后:"+thread.getState());
        }
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
        System.out.println("run:"+i);
        }
    }
}
```



###### 3、start方法源码分析

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\线程调用start方法后.png)

```java
/**
  * 无参启动线程
  */
public synchronized void start() {
    //判断线程状态,如果线程的状态不为0(0代表New),那么就会抛异常
    //验证:同一个线程调用两次start().就会抛出这个异常
    if (threadStatus != 0)
         throw new IllegalThreadStateException();
    //通知线程组(group)把当前线程加入其中
    group.add(this);
    boolean started = false;
    try {
        //调用start0()
        start0();
        //将标记设置为true
        started = true;
    } finally {
        try {
            //如果线程的标记为false,就将其移除线程组
            if (!started) {
                group.threadStartFailed(this);
                }
        	} catch (Throwable ignore) {
        }
    }
}
//native修饰的方法,也被叫做JNI(Java Native Interface)方法
//JNI方法是Java和其他语言交互的方法,比如java虚拟机是由C++和汇编写的
private native void start0();


/**
  * 有参启动线程
  */
//Runnable接口的实现类,在这个地方叫做target
public Thread(Runnable target) {
	init(null, target, "Thread-" + nextThreadNum(), 0);
}
private void init(ThreadGroup g, Runnable target, String name,
	//....
}
@Override
public void run() {
    if (target != null) {
    	target.run();
    }
}
```



##### 3、操作线程常见的方法

```java
package day0314;
/*
操作线程常见的方法
 1.休眠
    static void sleep(long millis)使当前线程休眠指定的毫秒值
 2.设置关于线程的优先级
    void setPriority(int 优先级别1-10 )
    优先级越高，只能保证获得cpu的机会越多（1-10 1最低  10最高  5使默认）,但是不能保证优先级高就能优先执行
 3.设置当前线程名字,有默认值
    setName(String name)
 4.获取当前线程名字
    getName()
 5.获取线程id
    getId()
 */
public class ThreadDemo05 {
    public static void main(String[] args) throws InterruptedException {
        ThreadTest tt0=new ThreadTest();
        tt0.setPriority(10);
        tt0.setName("线程1");
        System.out.println(tt0.getName()+tt0.getId());
        System.out.println("tt0-priority:"+tt0.getPriority());
        ThreadTest tt1=new ThreadTest();
        tt1.setPriority(1);
        System.out.println("tt1-priority:"+tt1.getPriority());
        ThreadTest tt2=new ThreadTest();
        System.out.println("tt2-priority:"+tt2.getPriority());
        tt0.start();
        tt1.start();
        tt2.start();
    }
}
```

##### 4、守护线程

```java
package day0314;
/*
  设置守护线程  setDaemon()
      守护线程也就是后台线程,默认创建的都是普通线程
      守护线程是同方法设置转变成守护线程,守护线程使用上与普通线程没有区别,区别在结束时间上
      当一个进程中所有的普通线程都结束后,进程就结束了,此时你的守护线程会被强制杀掉
 */
public class ThreadDemo06 {
    public static void main(String[] args) {
       Thread  ros= new Thread(){
           public void run(){
               for(int i=0;i<5;i++){
                   System.out.println("ros:jack,我要跳啦!");
                   try {
                       Thread.sleep(1000);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
               System.out.println("ros:jack,快来守护我!!!!");
               System.out.println("ros:扑通~~~~~");
           }
       };
       Thread  jack=new Thread(){
           @Override
           public void run() {
              while(true){
                  System.out.println("jack:ros,你跳我也跳!!!!");
                  try {
                      Thread.sleep(1500);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
           }
       };
       ros.start();
       //jack启动之前,将他设置为守护线程
       jack.setDaemon(true);
       jack.start();
    }
}

```

##### 5、yield(),让出cpu

```java
package day0316;
/*
让出当前cpu时间片:yield()
    当初当前cpu时间片,并不代表一定是另一个线程执行,而是多个线程公平等待分配cpu
 */
public class ThreadDemo01 {

    public static void main(String[] args) {
        YieldTest yt1=new YieldTest();//
        yt1.setName("代代");
        YieldTest yt2=new YieldTest();
        yt2.setName("果果");
        yt1.start();
        yt2.start();
    }

}
class YieldTest extends Thread{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println(getName()+"----"+i);
            if(i%10==0){
                yield();//当i取余10等于0的时候,让出当前线程的cpu时间片
            }
        }
    }
}
```

##### 6、join(),等待该线程结束 

```java
package day0316;
/*
   用于等待当前调用此方法的线程结束join(),才能执行其他
 */
public class ThreadDemo02 {
    //定义一个开关,用于表示下载线程是否正常结束
    public static boolean isFinish=false;
    //模拟图片的下载后显示
    public static void main(String[] args) {
        //图片下载线程
        Thread download=new Thread(){
            @Override
            public void run() {
                System.out.println("download:图片开始先下载");
                for(int i=0;i<=100;i++){
                    System.out.println("download:已下载"+i+"%");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("download:图片下载完成....");
                isFinish=true;//若run方法执行结束,会将该值改为true表示正确下载完成
            }
        };
        //图片显示线程
        Thread show =new Thread(){
            public void run(){
                try {
                    System.out.println("show:图片要显示啦.....");
                    System.out.println("show:正在等待下载.....");
                    //规定当下载线程执行完之后,才可以执行当前线程
                    //要等待下载线程结束
                    download.join();//表示download线程执行完之后,才可以执行当前线程
                    //判断是否发生异常
                    if(isFinish){
                        System.out.println("图片显示完成");
                    }else{
                        System.out.println("图片没有下载完成,请稍等....");
                     }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        download.start();
        show.start();
    }

}
```

##### 7、线程同步

>**线程同步:**是多个线程同时访问同一个资源,其他线程等待当前访问资源结束 (加锁,线程安全),浪费时间,效率不高
>
>**线程异步**:访问资源时,如果有空闲时间,则可空闲等待时间访问资源,实现多线程

````java
三种同步的方式：都是当前线程在对共享的资源进行访问时，不允许其他线程访问
1. 同步代码块
synchronized (this){
    if (num > 0){
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + "正在卖：" + num--);
    }
}
```
2. 同步方法，将方法声明同步的,将操作共享数据的代码放入这个方法即可
public synchronized void sell() throws Exception{
    if (num > 0){
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + "正在卖：" + num--);
    }
}
```
3. Lock锁,lock锁的性能和可扩展性比synchronized要更优
   while (true){
       lock.lock();
       if (tickets > 0){
           try {
               Thread.sleep(50);
               name = Thread.currentThread().getName();
               System.out.println(name + "正在卖：" + tickets );
               tickets--;
           }
           catch (Exception e){
               e.printStackTrace();
           }
       }
       lock.unlock();
   }
````

##### 8、线程通信

```java
package day0321;
/*
   线程通信的问题,例如: A  B  C
        A--1...5
        B--6...10
        C--11...15
        ...
        A--16...20

    wait():执行该方法,当前的线程就会进入等待(阻塞状态),并释放同步监视器(sleep(long)不会释放)
    notify():执行该方法,就会唤醒被wait阻塞的一个线程,如果有多个线程wait阻塞了,会优先唤醒优先级高的线程
    notifyAll();会唤醒所有被wait阻塞的线程
      说明:上述的三个方法都定义在Object类中
           上述的三个方法都必须在同步代码块或者同步方法中使用
           上述的三个方法调用者都必须是同步代码或者同步监视器

       sleep和wait有什么异同
        相同点:都可以是当前线程进入阻塞状态
        不同点:
           a.两个方法定义的位置不同,Thread中是sleep,Object中是wait
           b.调用要求不同,sleep任何地方都可以使用,wait必须在同步代码块或者同步方法中使用
           c.释放同步监视器:如果两个方法都在同步代码块中调用
                        sleep不会释放同步资源,wait会释放同步资源
 */
public class ThreadDemo01 {
    public static void main(String[] args) {
        Num n=new Num();
        Thread a=new Thread(n,"A");
        Thread b=new Thread(n,"B");
        Thread c=new Thread(n,"C");
        a.start();
        b.start();
        c.start();
    }
}
class Num implements Runnable{
  	int n=0;//计数器
    @Override
    public void run() {
        while(true){
            show();
            //Thread.sleep(1000);当前线程阻塞,其他线程抢到cpu资源执行
        }
    }
    public synchronized void show()  {
        notify();
        //每次执行累加
        n++;
        System.out.println(Thread.currentThread().getName()+"----"+n);
        //n%5==0的时候,就表示当前线程走了5次,需要让当前的线程阻塞,换成其他线程
        if(n%5==0){
            wait();//释放锁,进入阻塞状态等待被唤醒
        }
    }
}
```

##### 9、生产者消费者

```java
package day0321;
/*
生产者消费者模型
    生产者生产好的产品会交给店员,消费者从店员手中买走产品, 假设店员一次只能持有固定数量的产品(20),如果生产者试图生产更多产品,店员就会叫生产者等待一下,如果有消费者从店员手中买走产品,此时店员手中就有空的位置了,生产者就可以继续生产,如果店员手中没有产品,店员就会告诉消费者你等一下,等店员手中有了产品,再通知消费者来领取产品

    分析:
      1.存不存多线程问题?存在,生产者线程;消费者线程
      2.是否有数据共享问题?是,产品数量,店员
 */
public class ThreadDemo02 {
    public static void main(String[] args) {
        //店员对象
        Clerk dd=new Clerk();
        //生产者
        Productor dls=new Productor(dd);
        dls.setName("杜蕾斯");
        Productor jsb=new Productor(dd);
        jsb.setName("杰士邦");
        //消费者
        Consumer hz=new Consumer(dd);
        hz.setName("杨海");
        Consumer aw=new Consumer(dd);
        aw.setName("阿武");
        Consumer cc=new Consumer(dd);
        cc.setName("超超");
        //启动线程
        dls.start();
        jsb.start();
        hz.start();
        aw.start();
        cc.start();
    }
}
//店员
class Clerk{
    //产品数量
    int productCount=0;
    //店员要求生产者生产产品
    public synchronized void produceProduct(){
        //如果产品数量小于20就可以继续生产
        if(productCount<20){
            //开始生产,所以可以唤醒销售线程,因为当本次生成线程走完了,销售线程才能获得锁
            notifyAll();
            System.out.println(Thread.currentThread().getName()+
                    ":开始生产第"+productCount+"个产品");
            productCount++;
        }else {//如果产品数量大于等于20,就让生产者等待一下
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //店员的消费产品的方法
    public synchronized  void consumeProduct(){
        //如果产品数量大于0就可以消费
        if(productCount>0){
            //开始销售,所以可以唤醒生产线程,因为当本次销售线程走完了,生产线程才能获得锁
            notifyAll();
            System.out.println(Thread.currentThread().getName()+":开始消费第"
            +productCount+"个产品");
            productCount--;
        }else {//产品数量小于等于0,告诉消费者等一下
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
//生产者线程
class Productor extends  Thread{
    Clerk clerk;
    public Productor(Clerk clerk) {
        this.clerk = clerk;
    }
    @Override
    public void run() {
        System.out.println(getName()+"厂家:开始生产产品.....");
        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.produceProduct();
        }
    }
}
//消费者线程
class Consumer extends Thread{
    Clerk clerk;
    public Consumer(Clerk clerk){
        this.clerk=clerk;
    }
    @Override
    public void run() {
        System.out.println(getName()+"消费者:正在消费产品.....");
        while(true){
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}
```

#### 12、网络相关InetAddress

> 网络编程
>     计算机网络
>     把分布在不同地理区域的计算机与专门外部设备用通信线路互连成一个
>     规模大/功能强的网络系统;从而可以是众多的计算机互相传递信息/共享数据/软件等
>
>     Java来实现网络编程
>         目的：直接或者间接通过网络协议与其他计算机数据交互
>     
>         1.如何准确定位网络上的一台主机
>             IP：在Internet上计算机的唯一标识
>                本地回环地址:127.0.0.1/localhost
>                IP地址(hostAddress)  /域名(hostName)
>                域名容易记忆，当连接一个网络的时候输入一个域名，域名服务器(DNS)负责将域名转换为IP地址，这样才能进行主机连接-----域名解析
>                                                                                                                                                                             
>             IPv4:4个字节组成,4个0~255,大概40多亿;2011年IPv4已经不够使
>                 公网(万维网使用)和私网(局域)地址
>                                 192.168.开头的都是私有地址
>             IPv6:16个字节组成，128位,写成8个无符号整数,每个整数用4个16进制表示
>                                                                                                                                                                             
>            端口号，标识正在计算实际上运行的应用（进程/程序）
>            		不同的进程有不同的端口号
>            		16位无符号整数0~65535
>            		端口分类
>            公认端口:0-1023,被预先定义的服务占用(HTTP占用80 FTP占用21..)
>            注册端口:1024-49151,分配给用户进程或者应用程序(MySQL占用3306  Tomcat占用8080 Oracle占用1521)
>            动态/私有端口:49152-65535
>                                                                                                                                                                             
>            端口号与IP地址组合得出一个网络套接字：Socket

```java
package day0323;

import java.net.InetAddress;
import java.net.UnknownHostException;

public class Demo01 {
    /*
    java提供ip的封装类，InetAddress,这个类在java.net
     */
    public static void main(String[] args) throws UnknownHostException {
        /*
        静态方法获取地址对象
        static InetAddress getLocalHost();获取本地主机地址对象
        static InetAddress getByName(String hostName);根据指定域名获取地址对象
        static InetAddress getAllByName(String hostName);根据指定域名获取所有地址对象
                 */
        //获取本地地址对象
        InetAddress id1=InetAddress.getLocalHost();
        System.out.println(id1);
        //获取指定域名主机地址对象
        InetAddress id2=InetAddress.getByName("www.baidu.com");
        System.out.println(id2);
        //
        InetAddress[] ids=InetAddress.getAllByName("www.baidu.com");
         for(InetAddress id:ids){
             //获取id地址getHostAddress()
              System.out.println(id.getHostAddress());
              //获取域名getHostName()
             System.out.println(id.getHostName());
        }

    }
}

```

##### QQ群聊模拟

```java
package day0325;
/*
  qq群聊
    一个服务器端和多个客户端聊天
       思路:采用多线程的方式,收消息的时候可以同时发送数据
      1.服务器端创建ServerSocket,循环调用accept()等待客户端连接
      2.当有客户端连接进入的时候,就单独为一个客户端创建线程
      3.在线程中做输入输出

      1.创建Socket
      2.使用多线程,分别创建读写线程
 */
public class QQ_ServerDemo {
    //客户信息(用于存储客户名以及对应输出流)
    static  Map<String, PrintWriter> map=new HashMap<>();
    public static void main(String[] args) throws IOException {
        //创建ServerSocket
        ServerSocket server=new ServerSocket(8089);
        //循环等待客户端连接
        System.out.println("逃税群聊已开启,欢迎大家踊跃发言....");
        while (true){
            //获取连接socket对象
            Socket socket=server.accept();
            //根据socket创建线程
            new Thread(new ClientThread(socket,map)).start();
        }
    }
}
//根据服务器端获取到的客户端连接信息创建线程类型
class ClientThread implements  Runnable{
    Socket client;//与客户端连接的socket对象
    Map<String,PrintWriter> map;
    //构造方法
    public ClientThread(Socket client, Map<String, PrintWriter> map) {
        this.client = client;
        this.map = map;
    }
    @Override
    public void run() {
        try {
            //获取输入和输出流
            InputStream in=client.getInputStream();
            OutputStream out=client.getOutputStream();
            //套娃,方便读写
            BufferedReader reader=new BufferedReader(
                    new InputStreamReader(in,"utf-8"));
            PrintWriter pw=new PrintWriter(
                    new OutputStreamWriter(out,"utf-8"),true);
            //获取每个客户端的名字
            String name=reader.readLine();
            //欢迎语
            System.out.println("欢迎来逃税群聊已开启,欢迎大家踊跃发言...");
            //需要将name与pw存入到map中,
            synchronized (this) {
                map.put(name, pw);
            }
            //无限读取客户端发送过来的信息,然后群发
            String line;
            while((line=reader.readLine())!=null){
                System.out.println(line);//打印在服务器端
                //群发给所有人
                sendMsg(line,pw,name);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
    //服务器群发消息
    /*
      String line:数据
      PrintWriter pw: 输出流(可以代表自己,发送方)
      String name:客户端名字
     */
    private  void sendMsg(String line,PrintWriter pw,String name){
        //遍历map中value,如果pw表示的当前发送发,则不发送,否则就发送line内容过去
        for(PrintWriter writer:map.values()){
            if(!writer.equals(pw)){//如果writer不等pw,则表示不是发送发方
                writer.println(line);//服务器需要转发发送放的内容
            }
        }
    }
}
```

```java
public class QQ_ClientDemo {
    public static void main(String[] args) throws IOException {
        QQ_ClientDemo c1=new QQ_ClientDemo();
        c1.action();
    }

    public void action() throws IOException {
        //创建socket对象
        Socket socket=new Socket("localhost",8089);
        //获取输出流和输入流
        OutputStream out=socket.getOutputStream();
        InputStream in=socket.getInputStream();
        //给客户取一个名字
        Scanner scan=new Scanner(System.in);
        System.out.println("请问你是哪位大仙!");
        String name=scan.nextLine();
        //根据输出流和输入流创建线程对象,并且启动
        new ReadFromServer(name,in).start();
        new WriterToServer(name,out).start();
    }
}
//输入线程:读取服务器发送过来的消息
class ReadFromServer extends  Thread{
    String name;
    InputStream in;
    public ReadFromServer(String name, InputStream in) {
        this.name = name;
        this.in = in;
    }
    @Override
    public void run() {
        try {
            //套娃
            BufferedReader reader=new BufferedReader(
                    new InputStreamReader(in,"utf-8"));
            //循环读
            String line=null;
             while((line= reader.readLine())!=null){
                 //循环读取,读到不为空输出到控制台
                 System.out.println(line);
             }

        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//输出线程:发送数据给服务器端
class WriterToServer extends  Thread{
    String name;
    OutputStream out;
    public WriterToServer(String name, OutputStream out) {
        this.name = name;
        this.out = out;
    }
    @Override
    public void run() {
        try {
            //通过接收键盘输入的内容,然后发送给服务器
            Scanner scan=new Scanner(System.in);
            //套娃
            PrintWriter pw=new PrintWriter(
                    new OutputStreamWriter(out,"utf-8"),true);
            //先输出客户端名字
            pw.println(name);
            //循环接收键盘输入的内容并且发送到服务器端
            while(true){
                //循环接收键盘输入的内容
                String line=scan.nextLine();
                pw.println(name+"说:"+line);
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }
}
```

```java
public class Client2 {
    public static void main(String[] args) throws IOException {
        QQ_ClientDemo c2=new QQ_ClientDemo();
        c2.action();
    }
}
```

#### 13、原子类atomic



## 第三部分：数据库

### 1、关系型数据库

#### 1、MySql

>mysql是一个开放源代码的关系型数据库管理系统,将数据保存在不同的表中,而不是将数据放在一个仓 库里 可以增加速度和提高灵活性 mysql可以定制,可以修改源代码来开发自己的mysql系统 mysql是开源,句不需要支付额外的费用 mysql使用标准sql数据语言形式 mysql可以允许运行于多个平台,并且支持多种 语言
>
>mysql系统有四个自带数据库分别如下: 
>
>1. informaction_schema: 主要保存mysql数据库服务器的系统信息 比如:数据库名称/数据表名称/字段名称/存取权限/数据所在文件夹和系统使用文件夹等.... 
>2. mysql: 保存了mysql数据库服务器运行时需要的系统信息,比如数据文件夹 使用字符集 约束信息等... 
>3. perfromance_schema: 可以用来监控mysql的各项性能指标
>4.  sys: 以一种方便被理解的方式展示mysql数据库服务器的各项性能指标,帮助开发人员和管理人员监控技 术性能

##### 1、MySql的常用操作

>**1.查看所有DB**
>
>```sql
>show databases
>```
>
>**2.新建数据库**
>
>```sql
>#语法格式:create database 数据库名;例如#创建vip2109数据库
>create database vip2109;
>
>#判断数据库是否存在,如果不存在就创建;否则不创建
>create database if not exists 数据库名;
>
>#判断数据库是否存在,如果不存在就创建字符集为utf8的数据库;否则不创建
>create database if not exists 数据库名 default charset utf8;
>```
>
>**3.删除数据库**
>
>```sql
>drop database 数据库名
>```
>
>**4.进入数据库**
>
>```sql
>use 数据库名;
>```
>
>**5.查看数据库中的的表(得先进到数据库中)**
>
>```Sql
>show tables
>```
>
>### DDL((Data Definition Language):以下是数据定义语言)
>
>**6.新建表,删表,查看表结构**
>
>```sql
>CREATE TABLE 表名 (
>    ID INT,
>    NAME VARCHAR(20),
>    SCORE DOUBLE(4,2)
>);
>
>drop 表名;
>
>desc 表名;#查看表结构
>```
>
>**7.修改表名**
>
>```sql
>1.alter table 原表名 rename to 新表名;
>2.rename table 原表名 to 新表名;
>```
>
>**8.修改表中字段**
>
>```sql
>-- 例如:往表中添加性别字段
>alter table stu add(gender char(1));
>
>-- 例如:删除表中性别字段
>alter table stu drop gender;
>
>-- 修改表中字段名(可以同时修改字段类型)
>alter table 表名 change 原列名 新列名 数据类型;
>
>-- 修改表中字段类型
>alter table 表名 modify 字段名 字段类型;
>```
>
>### DMLL(Data Manipulation Language)数据操作语言:表数据的增加 删除 修改
>
>9.向表中插入数据
>
>```sql
>insert into stu values(1,'代代',99.9);
>insert into stu (id,username) values (2,'果果');
>```
>
>10.删除表中数据
>
>```sql
>delete from stu;   #删除表中所有数据
>delete from stu where username='果果';
>```
>
>11.修改表中数据
>
>```sql
>update 表名 set 字段名1=值1,字段名2=值2 where 条件
>update stu set score=99.9;#将stu表中每行score值改为了99.9
>update stu set SCORE=99 where username='果果';#将名字为'果果'的行中的分数改为99
>```
>
>### DQL(Data Query Language)数据查询语言:数据库的查询
>
>12.查询数据
>
>```sql
>select * from stu;-- 查询表中所有字段的值
>select id,username from stu;-- 查询表中id和username字段的值
>```

##### 2、SQL中的数据类型

###### 2.1.字符串

| 类型       | 范围                                               | 对应java类型 |
| ---------- | -------------------------------------------------- | ------------ |
| char(n)    | 固定n长度,最多255个字符                            |              |
| varchar(n) | 固定n长度,最多65535个字符                          |              |
| tinytext   | 可变长度,最多255(2的8次-1)个字符                   |              |
| text       | 可变长度,最多65535(2的16次-1)个字符;不可以有默认值 |              |
| mediumtext | 可变长度,最多2的24次-1个字符                       |              |
| longtext   | 可变长度,最多2的32次-1个字符                       |              |

###### 2.2.整数类型

| 类型         | 范围                  | 对应java类型 |
| ------------ | --------------------- | ------------ |
| tinyint(m)   | 1个字节(-128~127)     |              |
| smallint(m)  | 2个字节(-32768~32767) |              |
| mediumint(m) | 3个字节(              |              |
| int(m)       | 4                     |              |
| bigint(m)    | 5                     |              |

m表示查询的时候,结果集中显示的长度,并不会影响取值范围

###### 2.3.浮点型

| 类型        | 范围                                    | 对应java类型 |
| ----------- | --------------------------------------- | ------------ |
| float(m,d)  | 单精度浮点型 8位精度 m总个数,d小数位数  |              |
| double(m,d) | 双精度浮点型 16位精度 m总个数,d小数位数 |              |

m和d表示查询的时候,结果集中显示的长度,并不会影响取值范围

###### 2.4.日期类型

| 类型      | 范围                          | 对应java类型 |
| --------- | ----------------------------- | ------------ |
| date      | 日期'2022-03-30'              |              |
| time      | 时间'20:30:30'                |              |
| datetime  | 日期时间'2022-03-30 20:30:30' |              |
| timestamp | 时间戳,自动存储记录时间       |              |

##### 3、关键字

###### 3.1.between and

```sql
#####between and :表示范围
##查询id从1-6的数据(条件就是id>=1 and id<=6)
select * from student where id>=1 and id<=6;
select * from student where id>=1 && id<=6;
select * from student where id between 1 and 6;
##查询id不在1-6之间的数据
select * from student where id not between 1 and 6;
```

###### 3.2.order by

```sql
####order by
-- 语法结构: order by 列名 [排序方式:asc升序(默认)/desc降序]
#将查询的结果按照id的降序排序的
select * from student order by id desc;
#先根据id升序排序,再根据分数降序排序
select * from student order by id asc,score desc;
```

###### 3.3.distinct

```sql
#distinct
#查询的时候去除id相同的数据
select distinct id from student;
#查询的时候根据id和score去重复
select distinct id,score from student;
#根据表中所有字段去重复
select distinct * from student;
```

###### 3.4.插入和查询结合使用

```sql
### 插入和查询结合使用
## 将查询到所有数据插入到自己表中
#语法格式
/*
insert into 目标表名（目标表中指定的字段）
select (查询的哪些字段) from 查询表名
*/
insert into student (id,name,score,updateTime)
select * from student;
```

###### 3.5.like模糊查询

```sql
/*
%:匹配0个或者多个占位符 %代%(有个代就匹配成功) %代(最后一个字代就行)
_:占位符，每一个下划线占一个位置 _代%(第二字是代)
*/
######like ：模糊查询
#查询名字第一个字是‘祖’的学生
select * from student where name like '祖%';
#查询名字第二个字是‘祖’的学生
select * from student where name like '_祖%';
#查询名字中含有‘祖’的学生
select * from student where name like '%祖%';
```

###### 3.6.in

```sql
######in：判断是否在列表中
-- 语法规则 in (列表)
#查询id等于6 和10的
select * from student where id in(6,10);
#查询id不等于6和10的
select * from student where id not in(6,10);
#查询name等于'阿武'或者'吴彦祖'的
select * from student where name in('阿武','吴彦祖');
```

###### 3.7.limit:实现分页查询

```sql
/*
语法规则：limit [偏移量],行数
偏移量:从几开始,(0表示第一行数据)
行数：显示条数，当前页显示多少条
*/
#查询student中前4条数据(1 2 3 4 )
select * from student limit 0,4;
#查询student中5678条数据
select * from student limit 4,4;#4=(页数-1)*每页行数
#查询student中9 10 11 12条数据（第三页）
select * from student limit 8,4;#8=(页数-1)*每页行数
/*
第几页 pageNo 每页的长度pageSize
select * from student limit (pageNo-1)*pageSize,pageSize;
*/
#按照上述公式，如果要显示第2页，每页5行数据
#根据第几页和每页多少行去算出偏移量
#得出一个值:limit 5,5
select * from student limit 5,5;
```

##### 4、聚合函数

###### 4.1.count()函数

```sql
##count()函数
######as可以给字段取别名
######(不会修改表中字段名，只是修改查询显示时的字段名)
######也可以不加，直接空格隔开
##返回表中总行数
select count(*) '总数' from student;
##返回表中id等于10的总行数
select count(*) 'id等于10的总人数' from student where id=10;
##返回表中name的行数(返回的是非空的行数)
select count(name) as 'name总行数' from student;
```

###### 4.2.max()和min()

```sql
##查询id最大的数据
select max(id) as '最大id' from student;
##查询id最小的数据
select min(id) '最小id' from student;
```

###### 4.3.avg()和sum()

```sql
##求id的平均值
select avg(id) '平均' from student;
##求id的和
select sum(id) as 'id和为' from student;
select sum(id)/count(*) as '平均' from student;
insert into user (name) value('zs');
insert into user (name,age) value('zs',10);
#对user表中age求和/求平均
##求和没有问题,null不加就完了
select sum(age) from user;
##求平均
select avg(age) from user;
#恒等于 select sum(age)/count(age) from user
#age中有null的值,
#解决方法一:
select sum(age)/count(*) '平均值' from user;
#解决方法二:
##ifnull(列名,值)
select avg(ifnull(age,0)) '平均值' from user;
```

##### 5、分组group by

```sql
####分组使用group by
#group by 字段名:按照指定的字段进行分
#gruop by 通常情况跟count等聚合函数使用
#####按照mode进行分组
select * from hero group by mode;
##查询每个分组中，一共有几个hero
select mode,count(*) 'hero总数' from hero group by mode;
##查询每个分组中，总的增长系数
select mode,sum(growth) from hero group by mode;
##having子句(筛选)
#####有group by 才能用having ,只有满足条件才能输出
# 查询mode等于打野的总增长系数
select mode,sum(growth) from hero group by mode having mode=2;
```

##### 6、子查询

```sql
####
#1.where型子查询(把内层的查询结果当作外层查询的条件,内层查询结果只能由一条)
#####查询跟赏金的增长系数一样的英雄
##1.查询赏金的增长系数
select growth from hero where name='赏金'
##2.再根据上述查询的结果作为条件
#select * from hero where growth=("赏金的增长系数")
select * from hero where growth=(select growth from hero where name='赏金')
#2.in型子查询(先查内层的数据,再和外面条件进行比对,内层查询可以有多条数据)
#查询增长系数为3.3的modeId,并且找出跟这些modeId一样的英雄
#1.查询增长习数为3.3的modeId(查询到了3条数据,简单的where满足不了)
select modeId from hero where growth='3.3';
#2.再根据上述查询的结果作为条件
## select * from hero where modeId in("3.3的几种modeId")
select * from hero where modeId
in(select modeId from hero where growth='3.3');
#3.from型子查询(把内层的查询结果当做临时的表,提供给外层再次查询,临时表示需要给一个别名)
#1.查询 id和name
select id,name from hero;
#2.将上述查询结果当成一个临时的表,然后取个别名
select h.id from (select id,name from hero) h ;
##查询豹女的modeName以及 name 和id 等
##modeName属于mode表
##name /id属于hero表
select * from hero,mode;
```

##### 7、多表查询

```sql
select * from hero;#查询hero表中的数据 6
select * from mode;#查询mode表中的数据 5
select * from hero,mode;#查询hero和mode表的数据 30
##笛卡尔积,是一种数学思想,他的结果就是两个表组合的数量之和
##第一个表中 123456 第二表中 abcde
#1a 1b 1c 1d 1e 2a 2b 2c 2d 2e....30条
##查询结果发现数据冗余和重复,而且数据的关系是错误的!!!
#####解决数据冗余的问题
##1.可以通过where条件进行限定
select * from hero,mode where hero.modeId=mode.modeId;#不给表取别名
select * from hero h,mode m where h.modeId=m.modeId;#给表取别名
###查询id name 和 modeName
select h.id,h.name,m.modeName from hero h,mode m where h.modeId=m.modeId;
##2.使用内连接--等值连接
#语法格式 表1 inner join 表2 on 表1的条件和表2的条件进行判定
select * from hero h inner join mode m on h.modeId=m.modeId;
##3.使用外连接
###驱动表:里面的数据不管是否满足,都要显示出来的
###匹配表:里面的数据只有和驱动表匹配上才显示出来
##1.左外连接
#语法格式: 驱动表 left join 匹配表 on 条件
select * from mode m left join hero h on m.modeId=h.modeId;
#mode是驱动表,只有hero中的数据与mode匹配,才会显示出来#例如如果mode中没有'辅助'这个数据,那么hero中的'风女'的数据就不会显示
##2.右外连接
#语法格式: 匹配表 right join 驱动表 on 条件
select * from mode m right join hero h on m.modeId=h.modeId;
#hero是驱动表,不管mode中是否有,hero中所有的数据都会显示,
#hero中没有的数据,mode中的数据是不会显示的
```

##### 8、约束

```sql
#约束分类
    ##列级约束:
        ###主键 外键 唯一 检查 默认 非空/空
    ##表级约束:
        ###主键 外键 唯一 检查
#表级约束和列级约束异同点:        
    ##相同:
    	###都可以完成对字段的约束
    ##不同:
        ###1.位置不同：列级约束写在列的后面,表级约束写在所有字段的后面
        ###2.支持的约束类型不同:列级约束可以支持所有的约束，表级约束不能支持非空和默认
        ###3.列级约束不可以取约束名，标记约束可以取约束名
        ###4.删除:列级约束只能通过删除列来删除约束，表级约束通过约束名删除

```

###### 8.1.主键约束

```sql
#primary key主键约束(不能重复+不能为空)
#当给某一列设置主键之后,再设置该主键的自动增长,防止用户输入错误或忘记输入
create table test(
    ##列级约束 id int primary key auto_increment
    id int auto_increment,
    name varchar(20) not null,#名字不可以为空
    nickname varchar(20) null,#名字可以为空
    gender varchar(1) default '女',
    #表级约束:语法规则 constraint 约束别名 primary key(约束的列)
    constraint primary_id_key primary key(id)
)
select * from test;#查询表格中的数据
show tables;#查询数据库中表格
drop table test;#删除表格
```

###### 8.2.外键约束

```sql
-- 部门表
-- 部门表中部门编号是主键
CREATE TABLE DEPT(
DEPTNO INT PRIMARY KEY, -- 部门编号
DNAME VARCHAR(14) , -- 部门名称
LOC VARCHAR(13) -- 部门地址
) ;
-- 员工表
-- 员工表中员工编号是主键
CREATE TABLE EMP
(
EMPNO INT PRIMARY KEY, -- 员工编号
ENAME VARCHAR(10), -- 员工名称
JOB VARCHAR(9), -- 工作
MGR DOUBLE, -- 直属领导编号
HIREDATE DATE, -- 入职时间
SAL DOUBLE, -- 工资
COMM DOUBLE, -- 奖金
DEPTNO INT, -- 部门号
#表级约束
#语法规则
# constraint 约束别名 foreign key(子表中的列) references 主表(列)
# 可以:FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO));
constraint emp_foreign_key_deptno foreign key(deptno) references dept(deptno)
);
###员工表中部门号,与部门表中部门编号是同一个内容
####外键约束
#外键约束是发生在两个表中间的,用来维护两个表的关系
#外键所在的表就是子表
#子表已引用的关键字段所在表叫主表
#子表的外键列引用的是主键的主键列
######删除表格时:先删子表,再删主表


alter table 表 add constraint 约束名 foreign key(作为外键的列) reference 哪个表(哪个字段)
```

###### 8.3.唯一约束

```sql
##唯一约束 unique
create table test(
id int auto_increment,
##列级约束
# name varchar(20) not null unique,#名字不可以为空
name varchar(20) not null,
nickname varchar(20) null,#名字可以为空
gender varchar(1) default '女',
constraint primary_id_key primary key(id),
##表级约束
#语法格式:constraint 约束别名 unique (约束列名)
constraint name_unique unique(name)
)
insert into test(name) values('阿武');
select * from test;
drop table test;
```

```sql
###联合唯一
create table stu(
id int,
name varchar(20),
major varchar(20),
constraint name_major_unique unique(id,name,major)
##按照上述写法,只有当id name major都相同,才不允许插入,
##只要有一个不同都可插入
)
drop table stu;
select * from stu;
insert into stu values(1,'果果','计算机网络')
insert into stu values(2,'果果','计算机网络')
```

###### 8.4.检查约束

```sql
##检查约束
create table stu(
id int,
name varchar(20),
major varchar(20),
#列级约束
age int check(age>=18),
#表级约束
#语法规则 constraint 约束别名 check (条件)
gender char(1),
constraint stu_gender_check check (gender in('男','女'))
)
insert into stu values(2,'果果','计算机网络',16)#数据插入不成功，16违反检查约束
insert into stu values(2,'果果','计算机网络',61)
insert into stu values(2,'果果','计算机网络',61,'怪')
##数据插入不成功，因为‘怪’违反了检查约束
insert into stu values(2,'果果','计算机网络',61,'女')
select * from stu;
```

##### 9、视图

```sql
###视图
#创建视图
###在单表上创建视图
create view view_emp as select * from emp;
##查看视图基本信息
desc view_emp;
##查看视图中的数据
select * from emp;
select * from view_emp;##查看视图中数据
##更新视图(通过视图做插入,删除,更新)
##insert插入
INSERT INTO view_emp VALUES
(8888,'MILLER','CLERK',7782,'1982-01-23',1300,NULL,10);
##update更新
##delete删除
##因为视图时一个虚拟的表，其中没有数据
##通过视图更新的时候，都是转为基本表来更新
##更新视图的时候，基本表也有更新
##删除视图
##删除视图指删除数据库存在的视图，不会删除数据
drop view if exists view_emp;
```

##### 10、索引

```sql
#对建立索引的列使用二叉树进行排序
```

#### 2、SQL Server

#### 3、JDBC

JDBC(java Data Base Connectivity,java数据库连接)是一种执行SQL语句的java api,可以为多种关系数 据库提供统一访问,它是由java语言的类和接口组成的,使数据库开发人员能够编写数据库的应用程序.提 供的是一组标准.

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\jdbc作用位置.JPG)

```sql
#mysql是运行在本地电脑上一个数据库管理系统
#可以通过idea等工具连接数据库,然后操作数据库
#在通过工具连接数据库的时候,需要哪些参数
#主机 端口 database 参数
#username:
#password:
#url:
```

##### 3.1.获取数据库连接

```java
package day0411;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
/*
连接数据库的工具类
Arrays:操作数组的工具类
Collections:操作集合的工具类
工具类可以通过类名直接调用,
*/
public class DBUtils {
    //用户名
    public static String username="root";
    //密码
    public static String password="123456";
    //url
    public static String url="jdbc:mysql://" +
    "localhost:3306/vip2109?serverTimezone=UTC" +
    "&characterEncoding=utf8&useUnicode=true" +
    "&useSSL=false&allowPublicKeyRetrieval=true";
    //驱动
    public static String driver="com.mysql.cj.jdbc.Driver";
    //返回数据库连接的方法
    public static Connection getConn(){
        Connection conn=null;
        try {
            //加载驱动类
            Class.forName(driver);
            //通过驱动管理对象根据参数获取连接
            conn= DriverManager.getConnection(url,username,password);
        } catch (ClassNotFoundException e) {
        	e.printStackTrace();
        } catch (SQLException throwables) {
        	throwables.printStackTrace();
        }
        return conn;
    }
}
```

##### 3.2.执行SQL语句

###### 3.2.1.Statement

```java
/*
Statement使用过字符串的拼接实现SQL语句的,所以存在sql注入式攻击的危险:
	select * from t_user where username='ss' or 1=1;
	where后条件永远成立,永远都会有结果集返回,
*/
/*
根据用户名查询用户
*/
public User findUserByName(String username){
    User u=null;
    //1.获取连接
    conn= DBUtils.getConn();
    //2.sql语句
    String sql="select * from t_user where username='"+username+"'";
    try {
        //3.获取语句处理对象
        state= conn.createStatement();
        //4.执行查询操作
        /*
        boolean execute(sql) 可能会返回多个结果集对象
        ResultSet executeQuery(sql)一般用于执行select语句，返回单个结果集对象
        int executeUpdate(sql) 一般用于执行insert update delete
        */
        rs=state.executeQuery(sql);
        //5.迭代结果集
        while(rs.next()){
            //游标执行当前行,解析当前行的对象
            // String name=rs.getString("username");
            int id=rs.getInt("id");
            String pwd=rs.getString("pwd");
            u=new User(id,username,pwd);
    	}
    } catch (SQLException e) {
    	e.printStackTrace();
    }finally {
        try {
        	//6.关闭数据库连接
        	conn.close();
        } catch (SQLException e) {
        	e.printStackTrace();
        }
    }
    return u;
}
```

###### 3.2.2.PreparStatement

```java
//PreparedStatement是Statement的子接口
//是一种预编译的语句处理对象,使用?占位符类对参数进行严格检测验证,避免了注入式的攻击
public boolean add(User u){
    //1.获取数据库连接
    conn=DBUtils.getConn();
    //2.sql语句
    String sql="insert into t_user(username,pwd) values(?,?)";
    try {
    //3.获取语句处理对象
    ps=conn.prepareStatement(sql);
    //4.传入参数
    //将第一个?的位置赋值为user的username
    ps.setString(1,u.getUsername());
    //将第二个?的位置赋值为user的password
    ps.setString(2,u.getPassword());
    //5.执行操作
    int num=ps.executeUpdate();
    return num>0;//num大于0表示插入成功
    } catch (SQLException e) {
    	e.printStackTrace();
    }
    return false;//否则插入失败
}
```

###### 3.2.3.查询结果集ResultSet

```java
//接收方法返回的结果集对象
rs=state.executeQuery(sql);
//可以获取多行的数据,需要迭代每一行,从而获取每一行中每列的数据
/*
next用于判断当前结果集是否有下一个行
*/
while(rs.next()){
    //游标指向当前行,解析当前行的对象
    // String name=rs.getString("username");
    int id=rs.getInt("id");
    //数据类型是什么调用的就是get什么方法，然后需要传入在数据库中当前列的字段名
    String pwd=rs.getString("pwd");
    u=new User(id,username,pwd);
}
```

##### 3.3.批处理

###### 3.3.1.构建DBUtils

>properties文件

```properties
username=root
password=123456
url=jdbc:mysql://localhost:3306/vip2109?
serverTimezone=UTC&characterEncoding=utf8&useUnicode=true&useSL=false&allowPubli
cKeyRetrieval=true
driver=com.mysql.cj.jdbc.Driver
```

>DBUtils

```java
package day0413.com.ruandy.util;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;
/*
数据库链接工具类
1.当前类被加载的时候，就需要读取配置文件中的属性值
*/
public class DBUtils {
    public static String username;
    public static String url;
    public static String password;
    public static String driver;
    static {
        //类被加载static代码块就执行,使用io流读取配置文件中的内容
        // //1.创建文件
        // File file=new File("db.properties");//找的是项目下的db
        //InputStream in=new InputStream(file);
        //2.创建流
        InputStream in=DBUtils.class.getResourceAsStream("db.properties");
        Properties prop=new Properties();
        try {
            //3.通过load加载配置文件
            prop.load(in);
        } catch (IOException e) {
        	e.printStackTrace();
        }
        //4.读取
        url=prop.getProperty("url");
        username=prop.getProperty("username");
        password=prop.getProperty("password");
        driver=prop.getProperty("driver");
        //5.关闭流
    }
    //获取链接
    public static Connection getConn(){
        try {
            Class.forName(driver);
            return DriverManager.getConnection(url,username,password);
        } catch (ClassNotFoundException e) {
        	e.printStackTrace();
        } catch (SQLException throwables) {
        	throwables.printStackTrace();
        }
        return null;
    }
    //关闭连接
    public static void CloseConn(Connection conn){
        if(conn!=null){
            try {
            	conn.close();
            } catch (SQLException e) {
            	e.printStackTrace();
            }
        }
    }
    //关闭sql语句处理对象
    public static void CloseState(Statement state){
        if(state!=null){
            try {
            	state.close();
            } catch (SQLException e) {
            	e.printStackTrace();
            }
        }
    }
}
```

###### 3.3.2.使用Statement操作批处理

```java
/*
批处理:执行多个sql语句
使用Statement类批处理:执行多条sql
addBatch(sql):将需要执行的sql语句插入到批处理对象中
executeBatch():执行批处理
*/
public void saveBatch(){
    try {
        //1.获取数据库连接
        conn= DBUtils.getConn();
        //2.创建sql语句
        String sql1="insert into t_user(username,pwd) values('dd','123456')";
        String sql2="insert into t_user(username,pwd) values('gg','123456')";
        String sql3="insert into t_user(username,pwd) values('hz','123456')";
        String sql4="insert into t_user(username,pwd) values('st','123456')";
        //3.获取sql语句处理对象
        //3.1获取state对象
        state=conn.createStatement();
        //3.2将上述sql语句加入到state
        state.addBatch(sql1);
        state.addBatch(sql2);
        state.addBatch(sql3);
        state.addBatch(sql4);
        //4.执行sql,执行一个插入语句返回一个int值，请问执行一批插入语句返回一批int
        //executeBatch()用于执行多条sql语句
        int[] arrs= state.executeBatch();
        System.out.println("操作数据影响行数:"+arrs);
        //5.关闭流
        DBUtils.CloseConn(conn);
    } catch (SQLException e) {
    	e.printStackTrace();
    }
}
```

###### 3.3.3.使用PreparStatement操作批处理

```java
/*
PreparedStatement批处理:执行一条sql语句，参数是不同的
addBatch() :将预编译sql语句加入到批处理对象中
executeBatch() :执行批处理
*/
public void saveBatchP(){
    try {
        //1.获取数据库链接
        conn=DBUtils.getConn();
        //2.写sql语句
        String sql="insert into t_user(username,pwd) values(?,?)";
        //3.获取语句处理对象
        ps=conn.prepareStatement(sql);
        for(int i=0;i<5;i++){
            //4.设置参数
            //4.1设置参数,
            ps.setString(1,"yy"+i);
            ps.setString(2,"123456");
            //insert into t_user(username,pwd) values(‘yy0’,’123456‘)
            //4.2将预编译的sql语句加入到批处理对象中
            ps.addBatch();
        }
        //5.执行批处理
        int[] arr=ps.executeBatch();
        System.out.println("使用ps做批处理之后影响的行数:"+Arrays.toString(arr));
        //6.关闭流
        conn.close();
    } catch (SQLException e) {
    	e.printStackTrace();
    }
}
```

#### 4、事务

 一组逻辑操作单元，使数据从一种状态变为另外一种状态 
一组操作，要执行的都执行，不执行的都不执行 

**事务的特性(ACID)** 

1. 原子性(Atomicity) 原子性指的就是事务是一个不可分割的工作 单位，要么全部成功提交，要么全部失败回滚(回到原 始状态) 
2. 一致性(consistency) 数据从一个合法性的状态变为另一个合法性的状态，这种是语义上的而不是语法上的 例如： 代代余额1000，转账2000，此时代代余额-1000，因为定义一个状态余额大于等于0  例如： 代代余额1000，果果余额0：-----1000 代代给果果转500 在代代转出500的时候，程序出错了，导致500没有进入果果账户，代代余额500，果果0-----500 此时两人总额不一致 
3. 隔离性(Isolation) 事务的隔离性是指一个事务的执行不能被其他事务干扰 
4. 持久/永久性(Durability) 持久性是一个事务一旦被提交，他对数据的改变就是永久性

```java
package day0413.com.ruandy.test;
import day0413.com.ruandy.util.DBUtils;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
public class ChangeMoney {
    public static void main(String[] args) {
        Connection conn=null;
        try {
            // 1.获取数据库连接
            conn= DBUtils.getConn();
            // 2.新建sql
            String sql1="update test set salary=(salary-?) where name=?";//转出
            String sql2="update test set salary=(salary+?) where name=?";//转入
            // 3.获取语句处理对象
            PreparedStatement ps1=conn.prepareStatement(sql1);//转出的语句处理对象
            PreparedStatement ps2=conn.prepareStatement(sql2);//转入的语句处理对象
            // 4.设置参数
            //转出参数设置
            ps1.setInt(1,500);
            ps1.setString(2,"dd");
            //转入参数设置
            ps2.setInt(1,500);
            ps2.setString(2,"gg");
            // 5.执行sql
            // //设如果没有设置手动提交的操作
            // ps1.executeUpdate();//执行完sql1自动提交，代代-500
            // int a=1/0;//出错了！
            // ps2.executeUpdate();//sql2没有执行，果果没有+500
            //设置事务的手动提交
            conn.setAutoCommit(false);//默认值true，表示自动提交
            ps1.executeUpdate();
            int a=1/0;//出错了！
            ps2.executeUpdate();
            //如果上述代码没有出错，
            //手动提交一下
            conn.commit();
        } catch (Exception e) {
            //只要上述程序出现异常，就回滚
            System.out.println("账号转出异常....."+e.getMessage());
            //将数据回滚
            try {
            	conn.rollback();
            } catch (SQLException ex) {
            	ex.printStackTrace();
            }
        }
    }
}
```



### 2、非关系型数据库

## 第四部分：java web

#### 1、XML(可扩展的标记语言)

>xml--**可扩展的标记语言**. **Extensible Markup Language**
>
>xml作用--用于**存储**与**传输**数据.------给框架做配置文件使用（配置文件是用来存储配置数据的）
>
>XML 标签**没有被预定义**（标签可以随便写，如果作为传输，通常是要结合**约束**使用的）,使用**约束**的XML文档设计具有自我描述性。

```xml
<!--存储数据-->
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<country>
         <province>
              湖北
         </province>
         <province>
              湖南
         </province>
         <province>
             江西
         </province>
</country>

```

>**在真实的开发中，xml它的作用：**
>
>1.做为一个载体，存储与传输数据（不同系统之间交换数据）
>
>**2.做为程序的配置文件(主要作用)。**

##### 1.**xml****的组成部分**

>1、文档声明（出现在xml文件的首行，必须是首行，必须顶格写）
>
><?xml version="1.0" encoding="utf-8"?>
>
>2、元素（标签:**必须有开始有结束**,且**对于一个xml文档，有且只有一个根元素**）
>
>3、属性（标签里面的属性）
>
>4、注释 <!--注释-->
>
>5、CDATA区(这是CDATA的声明，它的作用：在这个区域内的内容不会被解析，会按照原样输出。)
>
>6、处理指令（PI Processing instruction) 没人用了，主要的作用是为了让xml引入css样式,必须以“<?”作为开头，以“?>”作为结尾;例如**<?xml-stylesheet href="css.css" type="text/css"?>**
>
>7、特殊字符（和html一样）

##### 2.XML约束

>1、什么是xml约束，为什么使用约束？
>
>简单说，xml约束，它是**控制xml中可以写什么，不可以写什么**。使用约束的好处，可以方便xml的解析或配置。
>
>2、xml约束技术有**两种**,**Xml****定义使用说明书就是约束**
>
>​	1).**dtd** 早期应用 *DTD*，Document Type Definition ，用的并不多。
>
>​	2).**schema** 现阶段应用比较多。复杂，男
>
>3、怎么学约束？
>
>不是让咱们自己写约束，只要会引用，能够简单的读懂约束就行了。引用：把约束加到xml中来

###### 1、DTD约束快速入门

>一般xml文件叫什么名字，根文件就叫什么名字。
>
>- 使用内部DTD-----直接写在xml文件中
>- 使用外部DTD ----SYSTEM
>- 使用公共DTD------PUBLIC

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\XML的DTD公共约束.png)

![XML的DTD内部约束](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\XML的DTD内部约束.png)

![XML的DTD外部约束](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\XML的DTD外部约束.png)

###### 2、schema约束及引用

>**XML Schema** **是基于 XML 的 DTD 替代者。schema的出现是为了替代dtd,dtd太弱了**
>
>**XML Schema** **描述 XML 文档的结构。**
>
>**XML Schema** **语言也称作 XML Schema 定义（XML Schema Definition，****XSD****（schema约束文件的后缀名）****）。**
>
>**schema****它相对于dtd优点**
>
>1.schema它本身就是一套xml,相对于dtd，学习更方便，但学习成本更高！
>
>2.schema可以精确定义数据类型
>
>
>
>**schema****文件的后缀名**;schema文件的后缀名是.xsd
>
>模式文档 .xsd
>
>实例文档 .xml
>
><!--ns就是名称空间的意思-->
><!--xmlns xml的名称空间-->
><!--名称空间就是大名-->
><!--        xmlns:xsd="http://www.w3.org/2001/XMLSchema"  固定写法
>            schema,xsd文件本质上也是一个xml文档
>            自身使用的标签也是要从别的地方引入的
>
>            ******targetNamespace="http://www.ruandy.com/xml"**********
>            目标名称空间：就是将来你要引入当前这个shema约束的时候需要的名称
>            ******引入约束*****

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\XML的schema约束.png)

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\XML引入schema约束.png)

##### 3、XML约束的解析

>1.xml的解析:对xml进行读写操作（通过程序完成的）
>
>2.xml的解析方式
>	1).Dom（文档对象模型）**读写**
>	2).Sax (Simple api for xml 简单的操作xml的api)  **只能读** （一行一行的读，读一行丢一行，内存中永远只有一个元素的数据，基于事件驱动的形式进行xml操作的）
>
>通常情况下：客户端会用用sax解析，服务器端用dom
>    
>3.dom的解析方式(思想),w3c标准--官方给的。
>		dom解析是将整个xml文档，分析成dom树，放入内存中。
>		优点：可以操作任意一个节点。可以进行读写操作。增删改查都行
>		缺点：如果文件比较大，会占用比较多的内存，效率低。还有可能引起内存溢出。
>		Html/xml  ---->内存之后---体积会膨胀多少倍1000--3000
>    
>4.sax的解析方式,民间标准。它是一种只能进行读操作的解析。加载一行读取一行。它是一种比较轻量级的解析方式。
>		优点：读操作效率比较高。
>		缺点：只能读，不能写，并且编程比较困难。
>
>5.xml的解析包（对思想的实现）
>		1).jaxp--sun官方提供的，比较差劲。在javase中不需要导包（了解）
>		**2).dom4j(重点)dom  for java  (涵盖两种解析思想：dom,sax. 自动切换)**
>		3).Jdom (分歧，有一拨人离开了，离开的人就去搞了dom4j)
>
>6.dom4j解析方式	
>	dom4j要想使用首先要导入jar包。
>	在dom4j下有一个dom4j-1.6.1.jar文件，导入到我们的工程中。
>
>7.dom4j API 详解
>		1.elements()
>		得到所有的根元素下的所有子元素返回的是一个java.util.List对象。
>2.element(String name);
>		得到一个元素下指定名称的子元素。
>		返回的是一个Element.
>3.getText()
>		获取元素中的文本信息。
>4.DocumentHelper
>		这个是用来进行创建操作。
>		创建新元素
>		DocumentHelper.createElement("type")
>5.add()
>		添加操作
>6.添加属性
>		addAttribute(String name,String value);
>		如果属性存在，就是修改.
>7.获取属性
>		attribute(String name); 返回的是一个Attribute对象
>8.删除属性
>		remove(Attribute a);
>
>

``` java

// 1.获取一个解析器.
SAXReader reader = new SAXReader();
//2.读取一个xml，获取对应的Document.
Document document = reader.read(new File("books.xml"));
//3.获取根元素.
Element root=document.getRootElement();


dom4j回写操作:
	XMLWriter writer = new XMLWriter(new FileWriter(file));
	writer.write(document);
	writer.close();
	操作中会存在编码问题
	原因：xml文件如果是utf-8,FileWriter它使用的编码是系统默认，如果是中文系统，使用的是gbk编码。
	解决方案：
	1.XMLWriter writer = new XMLWriter(new OutputStreamWriter(new FileOutputStream(file),"utf-8"));
	使用可以指定编码的字符流。
	2.在dom4j中提供一个OutputFormat类，它可以指定编码。
	OutputFormat format=OutputFormat.createPrettyPrint(); //有格式
	format.setEncoding("utf-8");//指定编码
	XMLWriter writer = new XMLWriter(new FileOutputStream(file),format);
	writer.write(document);
	writer.close();

代码演示
students.xml
<?xml version="1.0" encoding="UTF-8"?>
<students> 
	<student id="a1003C"> 
		<name>李四</name> 
		<age>18</age> 
		<gender>female</gender> 
	</student> 
	<student id="a1003C"> 
		<name>张三</name> 
		<age>18</age> 
		<gender>female</gender> 
	</student> 
	<student id="a1003C">
		<name>张三</name>
		<age>18</age>
		<gender>female</gender>
	</student>
</students>

获取根元素
DemoTest
public class DemoTest {
public static void main(String[] args) throws Exception {
		SAXReader reader = new SAXReader();
		Document read = reader.read(new File("students.xml"));
		Element root = read.getRootElement();
		System.out.println(root.getName());//得到跟元素的名称
	}
}

获取某个/所有元素下的子元素----elements()
DemoTest2

public class DemoTest2 {
public static void main(String[] args) throws Exception {
        SAXReader reader = new SAXReader();
        Document read = reader.read(new File("students.xml"));
        Element root = read.getRootElement();
        // System.out.println(root.getName());
        // Element stu = root.element("student");
        // System.out.println(stu.getName());
        List<Element> list = root.elements();
        System.out.println(list.size());
        Element element = list.get(1);
        Element name = element.element("name");
        System.out.println(name.getText());
	}
}

添加一个带属性的节点，并将数据回写
public class DemoTest3 {

public static void main(String[] args) throws Exception {
        SAXReader reader = new SAXReader();
        Document read = reader.read(new File("students.xml"));
        Element root = read.getRootElement();
        List<Element> list = root.elements();
        Element ce = DocumentHelper.createElement("address");
        ce.setText("北京");
        ce.addAttribute("id", "10");
        list.get(1).add(ce);
        //数据回写
        XMLWriter writer = new XMLWriter(new FileOutputStream(new File("students.xml")),OutputFormat.createPrettyPrint());
        writer.write(read);
        writer.close();
    }

}

修改某个节点的内容（节点的文本内容和属性值）
public class DemoTest4 {

public static void main(String[] args) throws Exception {
        SAXReader reader = new SAXReader();
        Document read = reader.read(new File("students.xml"));
        Element root = read.getRootElement();
        List<Element> list = root.elements();
        Element student2 = list.get(1);
        Element address = student2.element("address");
        address.setText("天津");
        address.addAttribute("id", "20");
        //数据回写
        XMLWriter writer = new XMLWriter(new FileOutputStream(new File("students.xml")),OutputFormat.createPrettyPrint());
        writer.write(read);
        writer.close();
    }

}

删除某个节点
public static void main(String[] args) throws Exception {
    SAXReader reader = new SAXReader();
    Document read = reader.read(new File("students.xml"));
    Element root = read.getRootElement();
    List<Element> list = root.elements();
    list.get(1).remove(list.get(1).element("address"));
    //数据回写
    XMLWriter writer = new XMLWriter(new FileOutputStream(new File("students.xml")),OutputFormat.createPrettyPrint());
    writer.write(read);
    writer.close();
}


```

#### 2、web相关概念

>### 1.软件架构
>
>​    	 	1. C/S：客户端/服务器端 c:client 客户端 S:server
>
>   	  	**2. B/S**：浏览器**服务器**端 b:browser **浏览器 S**：server**（通过浏览器去访问服务器资源）**
>
>###  2.服务器端的**资源分类**
>
>​     		1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被**浏览器解析**。
>
>​       		* 如： html,css,JavaScript
>
>​     		2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器
>
>​      	    * 如：servlet/jsp,php,asp....
>
>### 3.网络通信三要素（B/C 通过网络）
>
>​    	 1. IP：电子设备(计算机)在网络中的唯一标识。
>
>​    	 2. 端口（2个字节 16位 ）：应用程序在计算机中的唯一标识。 0~65535
>
>   	  3. 传输协议：规定了数据传输的规则
>
>​         		1). 基础协议：
>
>​           	 		 1. tcp:安全协议，三次握手。 速度稍慢
>
>​             			2. udp：不安全协议。 速度快
>
>### 4.web服务器软件：
>
>服务器：安装了服务器软件的计算机。 mysql是数据库服务器软件
>
>服务器软件：接收用户的请求，处理请求，做出响应
>
>web服务器软件：接收用户的请求，处理请求，做出响应。（通过浏览器进行请求的服务器叫做web服务器）
>
>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目
>
> web容器（资源，可以是静态/动态servlet）
>
> 
>
>### 5.常见的java相关的web服务器软件：
>
>​     **webLogic**：oracle公司，大型的JavaEE服务器，支持所有的JavaEE(一套技术规范，这一套技术规范有13个类别)规范，收费的。
>
>​     **webSphere**：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
>
>​     **JBOSS**：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。
>
>​     **Tomcat**：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。
>
>### 6.JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范

#### 3、Tomcat(web服务器)

##### 1、tomcat服务器根目录介绍

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\tomcat根目录介绍.png)

##### 2、tomcat中三种项目部署方式

>#### 冷部署:1.2                热部署:3
>
>1.直接将项目放到webapps目录下即可。(需要重启tomcat)
>
>​                  \hello：项目的访问路径-->虚拟目录
>
>​                  简化部署：将项目打成一个war包，再将war包放置到webapps目录下。
>
>​                     war包会自动解压缩（先打zip，再改成war）
>
>2.配置conf/server.xml文件(需要重启)
>
>​                  在<Host>标签体中配置:
>
>​                  <Context docBase="D:\hello" path="/hehe" />
>
>​                  \* docBase:项目存放的路径
>
>​                  \* path：虚拟目录(项目访问路径)
>
>3.在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写(不需要重启)
>
>​                  <Context docBase="D:\hello" />
>
>​                  \* 虚拟目录：xml文件的名称就是访问路径

##### 3、项目结构

>静态项目的目录结构：
>
>​			文件夹（文件夹的名字就是项目名）--静态资源（html,jpg...）
>
>动态项目的目录结构:
>
>​                      -- 项目的根目录
>
>​                           -- WEB-INF目录：(下面的内容不能通过浏览器访问)
>
>​                               **-- web.xml****：web****项目的核心配置文件**
>
>​                               **-- classes****目录：放置字节码文件的目录**
>
>​                               -- lib目录：放置依赖的jar包（java的classpath目录）
>
>​           			--动态资源（jsp）
>
>​          			 --静态资源 

#### 4、Servlet

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\servlet体系结构.png)

##### 1、Servlet的概念

>#### **Servlet： server applet（application little）是javaEE 13种规范种的一种,运行在服务器端的小程序Servlet就是一个接口,定义了Java类被浏览器访问到(tomcat识别)的规则。将来我们自定义一个类，实现Servlet接口，复写方法。**

##### 2、Servlet的配置方法

>## 执行原理：
>
>​     \1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
>
>​     \2. 查找web.xml文件，是否有对应的<url-pattern>标签体内容。
>
>​     \3. 如果有，则在找到对应的<servlet-class>全类名
>
>​     \4. tomcat会将字节码文件加载进内存，并且创建其对象
>
>​     \5. 调用其方法service

``` xml
第一种:在web.xml中配置：
	    <!--配置Servlet -->
	    <servlet>
	        <servlet-name>demo1</servlet-name>
	        <servlet-class>com.ruandy.web.servlet.ServletDemo1</servlet-class>
	    </servlet>
	
	    <servlet-mapping>
	        <servlet-name>demo1</servlet-name>
	        <url-pattern>/demo1</url-pattern>
	    </servlet-mapping>
```

```java
第二种:Servlet3.0版本之后,注解配置:
	* 好处：
		* 支持注解配置。可以不需要web.xml了。
	* 步骤：
		1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
		2. 定义一个类，实现Servlet接口
		3. 复写方法
		4. 在类上使用@WebServlet注解，进行配置
			例如:@WebServlet("资源路径")
```

```xml
一个Servlet可以定义多个访问路径
1.在注解中:
        @WebServlet({"/d4","/dd4","/ddd4"})
        模糊匹配（*）
        路径定义规则：
            1. /xxx：路径匹配
            2. /xxx/xxx/*:多层路径，目录结构
            3. *.do：扩展名匹配
        注意：如果有精准的匹配路径，则以精准的为准（动态）。除了静态资源之外，静态资源的被访问权低于模糊匹配的！
        如果用模糊匹配，*号只能出现在开始和结尾，不能出现在中间。开始的话不能有/
2.在web.xml中
		<servlet-mapping>
	        <servlet-name>demo1</servlet-name>
	        <url-pattern>/demo1</url-pattern>
	       	<url-pattern>/demo2</url-pattern>
	        <url-pattern>/demo3</url-pattern>
	    </servlet-mapping>
```

##### 3、Servlet的生命周期

```xml
1. 被创建：执行init方法，只执行一次
	1)Servlet什么时候被创建？
		* 默认情况下，第一次被访问时，Servlet被创建
		* 可以配置执行Servlet的创建时机。
			* 在<servlet>标签下配置
				1. 第一次被访问时(默认)，创建
               		* <load-on-startup>的值为负数
		        2. 在服务器启动时，创建
		            * <load-on-startup>的值为0或正整数
	<servlet>
        <servlet-name>myServlet3</servlet-name>
        <servlet-class>com.ruandy.servlet.demo.MyServlet3</servlet-class>
		<!--让tomcat在启动的时候创建该servlet-->
		<!--参数:0或者正整数;数字越小创建的越早-->
        <load-on-startup>0</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>myServlet3</servlet-name>
        <url-pattern>/myServlet3</url-pattern>
    </servlet-mapping>
		* Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
		* 多个用户同时访问时，可能存在线程安全问题。
		* 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值

2. 提供服务：执行service方法，执行多次
		* 每次访问Servlet时，Service方法都会被调用一次。
3. 被销毁：执行destroy方法，只执行一次
		* Servlet被销毁时执行。服务器关闭时，Servlet被销毁
		* 只有服务器正常关闭时，才会执行destroy方法。
		* destroy方法在Servlet被销毁之前执行，一般用于释放资源

```

##### 4、Servlet的继承体系结构

HttpServlet抽象类------->GenericServlet抽象类------->Servlet接口

```
//GenericServlet抽象类 实现了 Servlet接口
//把除service方法之外的所有的方法都实现了
//自己还定义了一个init() 这个init方法没参数
//还定义了一个ServletConfig 成员变量，并且在servlet接口的init方法中 对这个变量进行赋值，之后再去掉init()方法
//为什么要自己定义一个init（）方方法
//因为原来的servlet接口的init方法 已经用了，已经给servletconfig赋值了。不能重写了
//如果想重写init方法 就不能重写servlet接口的init方法，而要重写GenericServlet的init()

//httpServlet抽象类 继承了GenericServlet抽象类
//把GenericServlet的service方法实现了
//在service方法内部对serviece的两个参数进行了强转
// ServletRequest  ----> HttpServletRequest
// ServletResponse ----> HttpServletResponse
// 之后去调用 HttpServlet自己的service方法service(HttpServletRequest HttpServletResponse)
// 根据请求对象(HttpServletRequest)，来判断请求类型（get/post）
//如果是get  --->doGet(HttpServletRequest HttpServletResponse)
//如果是post --->doPost(HttpServletRequest HttpServletResponse)

//以后写Servlet只需要继承HttpServlet即可
```

##### 5、中文乱码问题

```java
一、请求乱码		
    //乱码，只会是中文，因为有的编码方案里面没有中文,例如iso-8859-1,ascii都不包含中文
    //tomcat8以后GET请求不会有乱码问题，tomcat8已经帮咱们解决了
    //tomcat8之前GET请求是有的中文乱码问题的:
        String name = request.getParameter("username")
        //如果要解决乱码，第一步是还原原来的这个编码
        byte[] byts = name.getBytes("iso-8859-1");
        //第二步重新进行编码
        String str = new String(byts,"utf-8");

		//tomcat 8  之后的get请求，tomcat已经帮咱们处理的乱码问题了
	    String username = request.getParameter("username");
      	System.out.println(username);

        //但是POST请求还是会出现中文乱码问题
        //参数----请求体里面 iso-8859-1
        //只需要通过一个方法，设置请求体编码即可解决乱码问题
        request.setCharacterEncoding("utf-8");//一定要在获取请求参数之前设置
        String username = request.getParameter("username");
        System.out.println(username);

二、响应乱码
    1.方式一
    //设置响应数据的编码方式为"utf-8",但是中文浏览器默认编码是GBK,接收到响应后会用GBK解码,所以还是会乱码
        response.setCharacterEncoding("utf-8");
    //设置响应数据的编码方式为"GBK",又因为上面,所以编码和解码方式一致,且GBK有中文,所以不会乱码
        response.setCharacterEncoding("GBK");
	2.方式二
    	response.setContentType("text/html;charset=utf-8");//设置浏览器用utf-8的编码方式
三、控制台乱码    
	-Dfile.encoding=utf-8
```

##### 6、HTTP协议

>1.HTTP   -->Hyper Text Transfer Protocol 超文本传输协议; 传输协议定义了，客户端和服务器端通信时，发送数据的格式
>
>2.特点:
>
>​		\1. 基于TCP/IP的高级协议
>
>​         \2. 默认端口号:80
>
>​         \3. 基于请求/响应模型的:一次请求对应一次响应
>
>​         \4. 无状态的：每次请求之间相互独立，不能交互数据
>
>3.HTTP协议又分为请求协议和响应协议

##### 7、请求协议Request

```` 
请求消息数据格式（请求首行/请求行，请求头，请求空行，请求体）
注意：GET请求没有请求体
	1. 请求行
		请求方式 请求url 请求协议/版本
		GET /login.html	HTTP/1.1
		
		请求方式：
			* HTTP协议有7种请求方式，常用的有2种
				* GET：
					1. 请求参数在请求行中，在url后。
					2. 请求的url长度有限制的
					3. 不太安全
				* POST：
					1. 请求参数在请求体中
					2. 请求的url长度没有限制的
					3. 相对安全
	2. 请求头：客户端浏览器告诉服务器一些信息
		请求头名称:请求头值
		* 常见的请求头：
			1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
				* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题
			2. Referer：http://localhost/login.html
				* 告诉服务器，我(当前请求)从哪里来？
					* 作用：
						1. 防盗链：
						2. 统计工作：
	3. 请求空行
		空行，就是用于分割POST请求的请求头，和请求体的。
	4. 请求体(正文)：GET请求没有请求体，只有post有
		* 封装POST请求消息的请求参数的

	* 字符串格式：

		POST /login.html	HTTP/1.1       --->请求行
		Host: localhost
		User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
		Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
		Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
		Accept-Encoding: gzip, deflate
		Referer: http://localhost/login.html
		Connection: keep-alive
		Upgrade-Insecure-Requests: 1        http--->https 过度的时候有问题，需要用这个请求头处理
											--->请求空行
		username=zhangsan                   --->请求体(只有post请求有)			
````

##### 8、Request的API

>## request对象和response对象的原理
>
>​     \1. request和response对象是由服务器创建的。我们来使用它们
>
>​     \2. request对象是来获取请求消息，response对象是来设置响应消息

```java
一. 获取请求行数据: GET /WEB01/demo1?name=zhangsan HTTP/1.1
		//1. 获取请求方式:getMethod()
            String method = request.getMethod();
            System.out.println(method);
		//2. (*)获取虚拟目录(项目名):getContextPath()   /WEB03  项目名就叫虚拟目录
            String contextPath = request.getContextPath();
            System.out.println(contextPath);
		//3. 获取Servlet路径:getServletPath()  /myServlet
        	System.out.println(request.getServletPath());
		//4. 获取get方式请求参数：getQueryString()  name=zhangsan  
            //注意:该种方式只获取get请求的  后面会有通用的 get post都行 getParameter
            String queryString = request.getQueryString();//了解，以后不用他。他是把数据进行了url编码
            String decode = URLDecoder.decode(queryString,"utf-8");//因为会乱码,所有要解码如何重新编码,才不会出现中文乱码
            System.out.println(decode);
		//5. (*)获取请求URI:getRequestURI()   /day14/demo1
            //* URL:统一资源定位符 ： http://localhost/WEB01/demo1 互联网中的某个资源
            //* URI：统一资源标识符 : /WEB01/demo1  项目中的某个资源
            //uri:项目名+资源名
            System.out.println(request.getRequestURI()); // /WEB03/myServlet
            //url:主机地址+项目名+资源名
            System.out.println(request.getRequestURL());// http://localhost/WEB03/myServlet
		//6. 获取协议及版本：getProtocol()  HTTP/1.1
        	System.out.println(request.getProtocol());
		//7. 获取客户机的IP地址：getRemoteAddr()
        	System.out.println(request.getRemoteAddr());//客户端的ip地址

二. 获取请求头数据
		//1.String getHeader(String name):通过请求头的名称获取请求头的值
            String referer = request.getHeader("referer");
            String header = request.getHeader("user-agent");
            System.out.println(referer);
            System.out.println(header);
		//2.Enumeration<String> getHeaderNames():获取所有的请求头名称
       		//Enumeration====集合
            Enumeration<String> headerNames = request.getHeaderNames();
            while(headerNames.hasMoreElements()){
                String name = headerNames.nextElement();
                String value = request.getHeader(name);
                System.out.println(name+":"+value);
            }

三. 获取(POST)请求体数据:
        //1.BufferedReader getReader()：获取字符输入流，只能操作字符数据
            BufferedReader reader = request.getReader();
            String data = reader.readLine();
            System.out.println(data);
		//2.ServletInputStream getInputStream()：获取字节输入流，可以操作					   所有类型数据(在文件上传知识点后讲解)
			* 步骤：
				1. 获取流对象
					*  BufferedReader getReader()：获取字符输入流，只能操作字符数据
					*  ServletInputStream getInputStream()：获取字节输入流，可以操作					   所有类型数据(在文件上传知识点后讲解)
				2. 再从流对象中拿数据
                
四.获取请求参数通用方式(get和post请求方式都可以使用下列方法来获取请求参数)
		//1. 根据参数名称获取参数值:String getParameter(String name)
            String username = request.getParameter("username");
            System.out.println(username);
            String password = request.getParameter("password");
            System.out.println(password);
		//2. 根据参数名称获取参数值的数组:String[] getParameterValues(String name)
            String[] hobbies = request.getParameterValues("hobby");
            System.out.println(Arrays.toString(hobbies));
            System.out.println("----------");
		//3. 获取所有请求的参数名称:Enumeration<String> getParameterNames()
            Enumeration<String> names = request.getParameterNames();
            while(names.hasMoreElements()){//hasMoreElements()判断是否有数据
                System.out.println(names.nextElement());//nextElement遍历
            }
		//4. 获取所有参数的map集合:Map<String,String[]> getParameterMap()
            //把请求参数的名字和值全部得到！！！
            //注意：键是字符串,值是字符串数组String[]
            Map<String, String[]> map = request.getParameterMap();
            Set<String> keys = map.keySet();
            for(String key:keys){
                System.out.println(key+":"+Arrays.toString(map.get(key)));
            }
五.请求转发:一种在服务器内部的资源跳转方式
    1.步骤:
        1. 通过request对象获取请求转发器对象：RequestDispatcher requestDispatcher = request.getRequestDispatcher("/BServlet");//得到请求调度器对象
        2. 使用RequestDispatcher对象来进行转发：requestDispatcher.forward(request,response);
    	//上面的代码通常会写成一行
        request.getRequestDispatcher("/BServlet").forward(request,response);
	2.特点
        1. 浏览器地址栏路径不发生变化
        2. 只能转发到当前项目内部资源中。
        3. 转发是一次请求
    
        
```

##### 9、域对象(共享数据)

>域对象:一个有作用范围的对象，可以在范围内共享数据

###### 1、request

```java
一.request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
	方法：
		1. void setAttribute(String name,Object obj):存储数据
		2. Object getAttitude(String name):通过键获取值
		3. void removeAttribute(String name):通过键移除键值对
```

###### 2、Session

```java
1. Session会话技术概念:服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。
2. 快速入门
    session是个域对象，作用范围多大？
    Session作用范围是:一次会话(默认),什么时候会话结束？关闭浏览器
        1. 获取HttpSession对象：
            HttpSession session = request.getSession();
        2. 使用HttpSession对象：
            Object getAttribute(String name)  
            void setAttribute(String name, Object value)
            void removeAttribute(String name)  

3. Session会话技术的原理: Session的底层实现是依赖于Cookie的。
	tomcat服务器内部有一个map集合,这个map集合专门用来存session对象的,在Servelet中通过"HttpSession session = request.getSession();"这一步操作,服务器看你的请求的Cookie中是否有JSESSIONID,有的话就就根据该JSESSIONID到map集合中找到对应的session对象给我们,没有JSESSIONID时就创建一个session对象,同时分配一个JSESSIONID,然后再添加到map集合中去,同时服务器把JSESSIONID和JSESSIONID的值放到Cookie中响应到客户端,map集合由key和value组成,服务器就把session对象放在value中,然后key就是服务器生成的一个JSESSIONID的值,服务器会把JSESSIONID转换成一个Cookie(Cookie c = new Cookie("JSESSIONID","JSESSIONID的值")),此处的JSESSIONID的值就是我们创建session对象时服务器帮我生成的那个放在map集合中的key值,然后再把Cookie响应到客户端,然后再次访问时,客户端就会带着Cookie里面的JSESSIONID到服务端,根据这个在map集合中找到对应的session对象,

4. Session细节问题
	1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？
		* 默认情况下。不是。
    		默认情况下,cookie.setMaxAge(-1);就是关闭浏览器,Cookie失效
		* 如果需要相同，则可以自己手动创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。
			 Cookie c = new Cookie("JSESSIONID",session.getId());
	         c.setMaxAge(60*60);
	         response.addCookie(c);

	2. 客户端不关闭，服务器关闭后，重启两次获取的session是同一个吗？
        不是同一个，但是session里面的数据能不能保留? 能
        服务器帮咱们做了session的钝化（序列化）和活化（反序列化）操作
            * session的钝化：
				* 在服务器正常关闭之前，将session对象序列化到硬盘上
			* session的活化：
				* 在服务器启动后，将session文件转化为内存中的session对象即可。
        复活的sesseion对象和原来的session对象是同一个吗？
        不是同一个（内存地址不一样）, 但是里面的数据一样吗？是一样的

        Session的钝化和活化在idea上表现不出来？为什么？
        因为idea可以帮你钝化，但是当idea重启服务器的时候，他会把之前钝化的session删除，所以就没法活化！！
        真实的生成环境下，tomcat会去帮你做钝化和活化的操作的。
			
	3. session什么时候被销毁？
		1. 服务器关闭
		2. session对象调用invalidate() 。
		3. session默认失效时间 30分钟---->map集合（session的缓存）
			选择性配置修改, 在web.xml配置文件中:	
			<session-config>
		        <session-timeout>30</session-timeout>
		    </session-config>

5. session的特点
	 1. session用于存储一次会话的多次请求的数据，存在服务器端
	 2. session可以存储任意类型，任意大小的数据

6. session与Cookie的区别：
		1. session存储数据在服务器端，Cookie在客户端
		2. session没有数据大小限制，Cookie有
		3. session数据安全，Cookie相对于不安全

```



###### 3、pageContext

```
当前页面
```



###### 4、ServletContext

``` java
四.ServletContext域:和tomcat共生死,一个项目只有一个
    1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信
	2. 获取：
        1. 通过request对象获取
            request.getServletContext();
        2. 通过HttpServlet获取
            this.getServletContext();
    3. 功能：
        1. 获取MIME类型：(媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。)
    	向客户但响应数据的时候，response.setContentype(“text/html;charset=utf-8”)
            * MIME类型:在互联网通信过程中定义的一种文件数据类型
                * 格式： 大类型/小类型   text/html		image/jpeg
            * 获取：String getMimeType(String file) 
                //根据文件的后缀名来判断文件的mime类型
                String a = "a.txt";//text/plain
                String a_mimeType = ctx.getMimeType(a);
                System.out.println(a_mimeType);
        2. 获取文件的真实(服务器)路径
    	原来Tomcat WEB-INF目录下的文件，浏览器一般无法直接方法，只能通过重定向后才可以访问，如果需要直接访问，可以放在和WEB-INF同级目录下。通常把那些限制访问的资源（比如说jsp源代码）放到Web应用的WEB-INF目录下，对于/web-INF/及其子目录，不允许直接的公共访问，所以就可以起到保护这些代码未经授权的访问和窥视，更好的保护了源代码。为了减少风险，可以把这些页面文件移到WEB-INF 目录下。
            方法：String getRealPath(String path)  
                String b = context.getRealPath("/b.txt");//web目录下资源访问
                System.out.println(b);
                String c = context.getRealPath("/WEB-INF/c.txt");//WEB-INF目录下的资源访问
                System.out.println(c);
                String a = context.getRealPath("/WEB-INF/classes/a.txt");//src目录下的资源访问
                System.out.println(a);
        3. 域对象：共享数据--> ServletContext对象范围：所有用户所有请求的数据
            //获取的，tomcat创建的，咱们只能获取
            //获取ServletContext域对象
            ServletContext servletContext = request.getServletContext();
            ServletContext ctx = request.getServletContext();
            System.out.println(servletContext==ctx);//true;
            //域对象的属性操作 map
            servletContext.setAttribute("msg","zhangsan");
            servletContext.getAttribute("msg");
            servletContext.removeAttribute("msg");
            //获取web.xml配置文件中的初始化数据
            String address = ctx.getInitParameter("address");
            System.out.println(address);
```

```xml
<!--    定义应用的初始化参数，通过ServletContext可以获取-->
    <context-param>
        <param-name>address</param-name>
        <param-value>wuhan</param-value>
    </context-param>
```

##### 10、响应协议Response

```java
1. 请求消息：客户端发送给服务器端的数据
	* 数据格式：
		1. 请求行	2. 请求头	3. 请求空行	4. 请求体
2. 响应消息：服务器端发送给客户端的数据
		1.响应行   2.响应头   3.响应空行  4.响应体 
3. 响应消息数据格式（响应首行/响应行，响应头，响应空行，响应体）:
	1. 响应行
		1. 组成：(协议/版本 响应状态码 状态码描述)-->(HTTP/1.1 200 OK)
		2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。
			1. 状态码都是3位数字 
			2. 分类：
				1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
				2. 2xx：成功。代表：200
				3. 3xx：重定向。代表：302(重定向)，304(访问缓存)
				4. 4xx：客户端错误。* 代表：
					* 404（请求路径没有对应的资源） 
					* 405：请求方式没有对应的doXxx方法 get请求，但服务器这边只有post请求的处理，报405
				5. 5xx：服务器端错误。代表：500(服务器内部出现异常)
	2. 响应头：
		1. 格式：头名称： 值
		2. 常见的响应头：
			1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式,（内容类型，以及响应内容的编码 告诉浏览器以什么编码打开,中文浏览器默认编码方式是GBK）
			2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 下载的时候要用
				* 值：
					* in-line:默认值,在当前页面内打开
					* attachment;filename=xxx：以附件形式打开响应体。文件下载
			3.Content-Language: en  (英语)
			4.Content-Length: 1500  （内容的长度 字节）
			5.Date: Fri, 16 Jul 2021 12:29:05 GMT （响应的时间）
			6.Connection: close （连接已经关闭了）
		3. 响应空行
		4. 响应体:传输的数据
4. 服务器输出字符数据到浏览器, 响应字符数据 字符输出流 文字信息就是字符数据
	* 步骤：
		1. 获取字符输出流
		2. 输出数据
		response.getWriter().write("hello 字符数据"); //PrintWriter:字符输出流
	* 注意：
		* 乱码问题：
			1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1
			2. 设置该流的默认编码（response.setCharacterEncoding(“GBK”)）
			3. 告诉浏览器响应体使用的编码

			//简单的形式，设置编码，是在获取流之前设置
    		response.setContentType("text/html;charset=utf-8");
5. 服务器输出字节数据到浏览器, 响应字节数据 字节输出流  图片/音乐
	* 步骤：
    	1.获取字节输入流来读取文件内容
			FileInputStream fis = new FileInputStream("文件路径");
		2.获取字节输出流来向客户端写内容
			ServletOutputStream sos = response.getOutputStream();
		3.写到客户端,输出数据,输出流（通过响应对象得到）
            //复制文件  把服务器端的字节数据复制到客户端去
            int data;
            while((data=fis.read())!=-1){
                sos.write(data);
            }
            //关闭流
            fis.close();

6. 把图片响应给客户端，不让客户端打开，而是让他下载
    //有没有办法让他把所有的东西都下载呢？有的
    //怎么做到的呢？
    //服务器怎么指挥浏览器干事情？通过设置响应头！
	//Content-disposition：服务器告诉客户端以什么格式打开响应体数据 下载的时候要用
		//* 值：
			//* in-line:默认值,在当前页面内打开
			//* attachment;filename=xxx：以附件形式打开响应体。
			//response.setHeader("Content-disposition","in-line");//默认值，浏览器决定是打开还是下载
        String filename = "重定向.png";
		//DownLoadUtils工具类,详见下面代码
        filename =DownLoadUtils.getFileName(request.getHeader("user-agent"),filename);
        System.out.println(filename);
        response.setHeader("Content-disposition","attachment;filename="+filename);
        FileInputStream fis = new FileInputStream("E:\\ideaWorkspace\\vip202101\\WEB05\\web\\WEB-INF\\files\\重定向.png");
        ServletOutputStream sos = response.getOutputStream();
        //复制文件  把服务器端的字节数据复制到客户端去
        int data;
        while((data=fis.read())!=-1){
            sos.write(data);
        }
        //关闭流
        fis.close();
```

```java
public class DownLoadUtils {
    /*
    * agent:user-agent  请求的用户信息的头
    * filename:包含中文/不包含中文的文件名字,进行URL编码,把这个编码再传递给浏览器,浏览器就不会显示下划线了
    * */
    public static String getFileName(String agent, String filename) throws UnsupportedEncodingException {
        if (agent.contains("MSIE")) {
            // IE浏览器
            filename = URLEncoder.encode(filename, "utf-8");
            filename = filename.replace("+", " ");
        } else if (agent.contains("Firefox")) {
            // 火狐浏览器
            BASE64Encoder base64Encoder = new BASE64Encoder();
            filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?=";
        } else {
            // 其它浏览器
            filename = URLEncoder.encode(filename, "utf-8");
        }
        return filename;
    }
}
```



##### 11、Response的API

```java
Response对象
*1. 功能：设置响应消息
	1. 设置响应行
		1. 格式：HTTP/1.1 200 ok
		2. 设置状态码：setStatus(int sc) 
	2. 设置响应头：setHeader(String name, String value) 
		
	3. 设置响应体：
		* 使用步骤：
			1. 获取输出流
				* 字符输出流：PrintWriter getWriter()
				* 字节输出流：ServletOutputStream getOutputStream()
			2. 使用输出流，将数据输出到客户端浏览器
*2. 案例：
	1. 完成重定向
		* 重定向：资源跳转的方式
		* 代码实现：
			//1. 设置状态码为302
	        response.setStatus(302);
	        //2.设置响应头location
	        response.setHeader("location","/WEB01/responseDemo2");

			//简单的重定向方法
	        response.sendRedirect("/WEB01/responseDemo2");

*3. forward（转发的意思） 和  redirect（重定向的意思） 区别
		* 重定向的特点:redirect
			1. 地址栏发生变化
			2. 重定向可以访问其他站点(服务器)的资源/也可以访问本项目中的资源
			3. 重定向是两次请求。不能使用request对象（域）来共享数据
		* 转发的特点：forward
			1. 转发地址栏路径不变
			2. 转发只能访问当前服务器下的资源
			3. 转发是一次请求，可以使用request对象来共享数据
		
		

```

##### 12、会话技术

>**会话技术**:     从打开一个浏览器访问某个站点，到关闭这个浏览器整个过程，     成为一次会话，会话技术就是记录这次会话中客户端的状态与数据
>
>**会话技术分为Cookie**和**Session**:
>
>​     Cookie：数据存储在客户端本地，减少服务器端的压力，安全性能不好,  客户端可以清除cookie
>
>​     Session：将数据存储到服务器端，安全性相对好，增加服务器的压力
>
>1. 会话：一次会话中包含多次**请求**和**响应**。
>
>   ​     \* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止
>
>2. 功能：在一次会话的范围内的多次请求间，共享数据
>
>3. 方式：
>
>   ​     1. 客户端会话技术：Cookie
>
>   ​     2. 服务器端会话技术：Session 底层依赖Cookie
>
>

###### 1、Cookie

```java
1. 概念：客户端会话技术，将数据保存到客户端（浏览器）

2. 快速入门：
	* 使用步骤：
		1. 创建Cookie对象，绑定数据
			* new Cookie(String name, String value) 
		2. 发送Cookie对象到浏览器
			* response.addCookie(Cookie cookie) 
		3. 获取Cookie，拿到数据
			* Cookie[]  request.getCookies()  

3. 实现原理
	* 基于响应头set-cookie（response.addCookie(c1)）和请求头cookie实现

4. cookie的细节
	1. 一次可以发送多个cookie,创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。
	2. cookie在浏览器中保存多长时间？  
        cookie在浏览器中最终以文件的形式保存的/保存在浏览器的内存里
        cookie的存活时间/生命周期可以设置
            a. 默认情况下，当浏览器关闭后，Cookie数据被销毁（活在浏览器内存中的）
            b. 持久化存储：
                setMaxAge(int seconds/秒)
                    正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，							 cookie文件自动失效
                    负数：默认值（只存在内存中）
                    零：删除cookie信息
	3. cookie能不能存中文？
		(有的tomcat版本可以存中文，有的不能。如果不能，就要有对应的解决方法（使用URL编码）)
		* 在tomcat 8 之前 cookie中不能直接存储中文数据。
			* 需要将中文数据转码---一般采用URL编码(%E3)
		* 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析
                String key = "消息";
                String value = "你好Cookie";
                //url编码的方式解决cookie不让存中文问题
                key = URLEncoder.encode(key,"utf-8");
                value = URLEncoder.encode(value,"utf-8");
                Cookie c = new Cookie(key,value);
                response.addCookie(c);
				//在取Cookie时,使用url解码输出
                String name = cookie.getName();//key
                String value = cookie.getValue();//value
                name = URLDecoder.decode(name,"utf-8");
                value = URLDecoder.decode(value,"utf-8");

	4. cookie共享问题？
		a. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
			* 默认情况下cookie不能共享
			* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录
			* 如果要共享，则可以将path设置为"/"
                Cookie c = new Cookie("key","value");
                c.setPath("/");
                //响应给客户端浏览器
                response.addCookie(c);
				//然后在同一服务器的其他项目中可以获取到该Cookie
		b. 不同的tomcat服务器间cookie共享问题？ 				
			* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
			* setDomain(".baidu.com"),那么tieba.baidu.com和news.baidu.com中cookie可以共享
   
     5. Cookie的特点和作用
        1. cookie存储数据在客户端浏览器
        2. 浏览器对于单个cookie 的大小有限制(4kb) 以及对同一个域名下的总cookie数量也有限制(20个)
        * 作用：
            1. cookie一般用于存出少量的不太敏感的数据
            2. 在不登录的情况下，完成服务器对客户端的身份识别
```

###### 2、Session

##### 13、路径问题

```java
1. 什么是客户端路径？什么是服务器端路径？
	客户端路径：就是跳转过后能显示目标资源的url的就是客户端路径
	服务器端路径：跳转后不显示目标资源的url就是服务器端路径

2. 路径分类
	1. 相对路径：相对路径指的就是资源当前路径,通过相对路径不可以确定唯一资源
		*直接写资源名称
            * 不以/开头，以 ./ 或 ../ 开头路径,如：./index.html
            * 规则：找到当前资源和目标资源之间的相对位置关系
                * ./：当前目录
                * ../:上一级目录
    2. 绝对路径：通过绝对路径可以确定唯一资源（web阶段）
       	*以http开头或以/开头都是绝对路径
            * 如：http://localhost/WEB01/responseDemo2				    
                 /WEB01/responseDemo2                                                
            * 以/开头的路径
                * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出
                    * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)
                        * 建议虚拟目录动态获取：request.getContextPath()
                        * <a> , <form>, 响应重定向的路径...
response.sendRedirect("http://localhost:8080/WEB05/myServlet");//地址给客户端用 
response.sendRedirect("/WEB05/myServlet");//因为此处/开头代表：http://localhost:8080  虚拟主机                            
                    * 给服务器使用：不需要加虚拟目录,因为此处/代表/WEB05
                        * 请求转发的路径
request.getRequestDispatcher("/myServlet").forward(request,response);//地址给服务器看			
3.问题：服务器端的/和客户机端的/代表什么（绝对路径开始）
    //这里的斜杠代表什么？代表项目的虚拟目录：/WEB05 项目名称 (可以用request.getContextPath()获取)    
    request.getRequestDispatcher("/myServlet").forward(request,response);//地址给服务器看

    <!--下面的斜杠开头代表什么：http://localhost:8080  虚拟主机-->
    <a href="/WEB05/myServlet">myServlet</a>
```

#### 5、JSP

##### 1、JSP基础

```jsp
1. JSP概念: * Java Server Pages： java服务器端页面
	* 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码
	* 用于简化书写！！！
2. jsp组成：
	1. html 
    2. jsp指令（控制jsp的各种功能）
    3. java脚本（java代码）
3. 原理
	* JSP本质上就是一个Servlet, 也就是jsp最终会被转换成一个servlet	
4. 注释
	Jsp页面有两种注释，一种是html：这种注释最终会被当做html标签，被out.writer(“<!--这里是html注释-->”)，另一种是jsp注释（jsp注释会被当做java注释，java注释是不会被输出到页面的）
	1. html注释：
		<!-- -->:只能注释html代码片段
	2. jsp注释：推荐使用
		<%-- --%>：可以注释所有

```

##### 2、JSP的指令

``` java
1. 指令（控制页面）
	* 作用：用于配置JSP页面，导入资源文件
	* 格式：<%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>
	* 分类：
		1. page： 配置JSP页面的
			* contentType：等同于response.setContentType()
				1. 设置响应体的mime类型以及字符集
				2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）
	    	* pageEncoding="UTF-8" 和上面的contentType是一样的，两个写一个就行
			* import：导包
			* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面
			* isErrorPage：标识当前也是是否是错误页面。
				* true：是，可以使用内置对象exception
				* false：否。默认值。不可以使用内置对象exception

		2. include	： 页面包含的。导入页面的资源文件
			* <%@include file="top.jsp"%>
		3. taglib: 导入资源  import: 导入的是标签库
			* <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
				* prefix：前缀，自定义的
```

##### 3、JSP的脚本

```jsp
JSP的脚本：JSP定义Java代码的方式
	1. <%  代码 %>：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。
		<%
            //在这里写的java脚本就相当于写在servlet service方法中
            System.out.println("哈哈");
            request.getCookies();
            response.getWriter();
    	%>
	2. <%! 代码 %>：定义的java代码，在jsp转换后的java类的成员位置。
		<%!
            //写在这里的代码，相当于写在servlet的成员位置
            int i=100;//servlet的成员变量
            public void add(){ //servlet的成员方法
            }
        %>
	3. <%= 代码 %>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。
    	<%="写在这里的代码依旧相当于写在service方法中，只不过相当于调用了response.getWriter().write('这里的内容')"    %>
```

##### 4、JSP的内置对象

| 变量名      | 对应的真实类型      | 作用                                        |
| ----------- | ------------------- | ------------------------------------------- |
| pageContext | PageContext         | 当前页面共享数据,还可以获取其他八个内置对象 |
| request     | HttpServletRequest  | 一次请求访问的多个资源(请求转发)            |
| session     | HttpSession         | 一次会话的多个请求间                        |
| application | ServletContext      | 所有用户间共享数据                          |
| response    | HttpServletResponse | 响应对象                                    |
| page        | Object              | 当前页面(Servlet)的对象,this                |
| out         | JSPWriter           | 输出对象,数据输出到页面上                   |
| config      | ServletConfig       | Servlet的配置对象                           |
| exception   | Throwable           | 异常对象                                    |

```jsp
JSP的内置对象：在jsp页面中不需要获取和创建，可以直接使用的对象
	* jsp一共有9个内置对象。
	* 今天学习3个：
		* request
		* response
		* out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似
			* response.getWriter()和out.write()的区别：
				* 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。
				* response.getWriter()数据输出永远在out.write()之前
				* 二者类型不同:
                    PrintWriter（字符流） pw = Response.getWriter();
                    Out 的类型是 JspWriter(字符输出流);

域对象：request,(一次请求)
session,（一次会话）
servletContext,（整个应用）
pageContext（整个页面）

```

##### 5、EL*(表达式语言)*

```jsp
1. 概念
	Expression Language 表达式语言
2. 作用
	替换和简化jsp页面中java代码的编写
3. 语法
	${表达式}
4. 注意
	* jsp默认支持el表达式的。如果要忽略el表达式
		1. 设置jsp中page指令中：isELIgnored="true" 忽略当前jsp页面中所有的el表达式
		2. \${表达式} ：忽略当前这个el表达式
5. 使用
	1. 运算：
		* 运算符：
			1. 算数运算符： + - * /(div) %(mod)
			2. 比较运算符： > < >= <= == !=
			3. 逻辑运算符： &&(and) ||(or) !(not)
			4. 空运算符： empty
				* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
				* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
				* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0
	2. 获取值
		1. el表达式只能从域对象中获取值
		2. 语法：
			1. ${域名称.键名}：从指定域中获取指定键的值
				* 域名称：
					1. pageScope		--> pageContext
					2. requestScope 	--> request
					3. sessionScope 	--> session
					4. applicationScope --> application（ServletContext）
				* 举例：在request域中存储了name=张三
				* 获取：${requestScope.name}
            2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。
            3. 获取对象、List集合、Map集合的值
                            1. 对象：${域名称.键名.属性名}
                                * 本质上会去调用对象的getter方法
                            2. List集合：${域名称.键名[索引]}
                            3. Map集合：
                                * ${域名称.键名.key名称}
                                * ${域名称.键名["key名称"]}
            3. 内置对象：
                    * el表达式中有11个内置对象,掌握上面4个域对象和pageContext即可
                    * pageContext：
                        * 获取jsp其他八个内置对象
                            * ${pageContext.request.contextPath}：动态获取虚拟目录


```

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\EL隐含对象.png)

##### 6、JSTL*(JSP标准标签库)*

```jsp
1. JSTL的概念: JavaServer Pages Tag Library  (JSP标准标签库)
	是由Apache组织提供的开源的免费的jsp标签		<标签>
	以后咱们会把el和jstl结合到一块儿使用
2. JSTL的作用
	用于简化和替换jsp页面上的java代码		
	
3. JSTL的使用步骤
	1. 导入jstl相关jar包:
		javax.servlet.jsp.jstl.jar
        jstl-impl.jar
	2. 引入标签库：taglib指令：  <%@ taglib %>
		<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
	3. 使用标签
        常用的JSTL标签
            1. if:相当于java代码的if语句
                1. 属性：
                    * test 必须属性，接受boolean表达式
                        * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
                        * 一般情况下，test属性值会结合el表达式一起使用
                 2. 注意：
                     * c:if标签没有else情况，想要else情况，则可以再定义一个c:if标签
                         <c:if test="${false}">
                            这里是jstl的if标签
                         </c:if>
            2. choose:相当于java代码的switch语句
                1. 使用choose标签声明         			相当于switch声明
                2. 使用when标签做判断         			相当于case
                3. 使用otherwise标签做其他情况的声明    	相当于default
					<%
        				request.setAttribute("msg","10");
    				%>
                    <c:choose>
                        <c:when test="${msg=='1'}">星期一</c:when>
                        <c:when test="${msg=='2'}">星期二</c:when>
                        <c:otherwise>
                            啥也不是！！！
                        </c:otherwise>
                    </c:choose>
            3. foreach:相当于java代码的for语句
        		1.相当for(int i=0;i<10;i++){}
                	<c:forEach begin="1" end="10" step="1">
       					<h1>这里是循环的内容<h1>
   					</c:forEach>                      
                2.相当for(Object o : objects){}   
                    <c:forEach items="${list}" var="i"><%-- i最终会放到page域里面去--%>		
        				${i}
    				</c:forEach>
				3.第三种形态
                    <%
                        ArrayList<String> list = new ArrayList<String>();
                        list.add("赵松松");
                        list.add("李志远");
                        list.add("李亚杰");
                        request.setAttribute("list",list);
                    %>
                    <c:forEach items="${list}" varStatus="s">
                		<%-- var 和varStatus是有关联的--%>
                		<%-- varStatus比var强大 包含var--%>
                        <c:if test="${s.first}">这里是第一个</c:if>
                        <c:if test="${s.last}">这里是最后一个</c:if>
                        这里是第${s.count}个（从1开始）
                        这里是第${s.index}个索引（从0开始）
                        当前循环到的元素是：${s.current} (和var=i是一样的)
                        <br>
                    </c:forEach>       
```

#### 6、Filter过滤器

```xml
1. Filter概念
	* 生活中的过滤器：净水器,空气净化器，土匪、
	* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。
	* 过滤器的作用：
		* 一般用于完成通用的操作。如：登录验证、统一编码处理
	*过滤器会什么时候创建? 服务器启动的时候
	*过滤器的运行原理：
		当用户的请求到达指定的网页之前，可以借助过滤器来改变这些请求的内容，此过程也称为“预处理”；
		当执行结果要响应到用户之前，可经过过滤器修改响应输出的内容，此过程称为“后处理”。

2. Filter快速入门
	1. 步骤：
		1. 定义一个类，实现接口Filter
		2. 复写方法
    		init(FilterConfig filterConfig);
			doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain);
			destroy();
		3. 配置拦截路径
			1. web.xml
            	<filter>
                    <filter-name>demo1</filter-name>
                    <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
                </filter>
                <filter-mapping>
                    <filter-name>demo1</filter-name>
                    <!-- 拦截路径 -->
                    <url-pattern>/*</url-pattern> <!-- /*代表过滤所有 -->
                </filter-mapping>
			2. 注解
		@WebFilter(value="/*",dispatcherTypes = DispatcherType.REQUEST)//默认过滤所有请求访问
		@WebFilter(value="/*",dispatcherTypes = DispatcherType.FORWARD)//只有转发过来才会被过滤
```

```java
//@WebFilter(value="/*",dispatcherTypes = DispatcherType.FORWARD)  //只有转发过来才会被拦截
@WebFilter(value="/*",dispatcherTypes = DispatcherType.REQUEST) 默认访问方式
public class MyFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("init....");
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("doFilter");
        filterChain.doFilter(servletRequest,servletResponse);//放行,执行请求的资源
        System.out.println("doFilter... laster");//执行完请求的资源后还有通过该filter
    }

    @Override
    public void destroy() {
        System.out.println("destory....");
    }
}

```

```
3. 过滤器细节
	1. web.xml配置	
		<filter>
	        <filter-name>demo1</filter-name>
	        <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
	    </filter>
	    <filter-mapping>
	        <filter-name>demo1</filter-name>
			<!-- 拦截路径 -->
	        <url-pattern>/*</url-pattern>
	    </filter-mapping>
	2. 过滤器执行流程
		1. 执行过滤器
		2. 执行放行后的资源
		3. 回来执行过滤器放行代码下边的代码
	3. 过滤器生命周期方法
		1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
		2. doFilter:每一次请求被拦截资源时，会执行。执行多次
		3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
	4. 过滤器配置详解
		*1. 拦截路径配置：
			1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行
			2. 拦截目录： /user/*	访问/user下的所有资源时，过滤器都会被执行
			3. 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行
			4. 拦截所有资源：/*		访问所有资源时，过滤器都会被执行
		*2. **拦截方式***配置：资源被访问的方式
			* 注解配置：
				* 设置dispatcherTypes属性
					1. REQUEST：默认值。浏览器直接请求资源
					2. FORWARD：转发访问资源
			* web.xml配置
				* 设置<dispatcher>FORWARD</dispatcher>标签即可
			
	2. 过滤器链(配置多个过滤器)
		*1. 执行顺序：如果有两个过滤器：过滤器1和过滤器2
			1. 过滤器1
			2. 过滤器2
			3. 资源执行
			4. 过滤器2
			5. 过滤器1 
		*2. 过滤器先后顺序问题：
			1. 注解配置：按照类名的字符串比较规则比较，值小的先执行
				* 如： AFilter 和 BFilter，AFilter就先执行了。
			2. web.xml配置： <filter-mapping>谁定义在上边，谁先执行
```

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\FIlter过滤器链.png)

#### 7、Listener监听器

```
    监听器
    事件：动作，动作是发生在事件源身上的.
    事件源
监听器：防盗器(当事件产生的时候，就会执行)

注册监听器：把监听器注册到事件源身上，当事件产生之后，监听器就会执行。

*Web容器使用不同的监听器接口来实现对不同事件的监听，常用的Web事件监听器接口可分为如下三类：
    与Servlet上下文相关的监听器接口
    与会话相关的监听器接口
    与请求相关的监听器接口

Javaweb中需要掌握的监听器
	SevletContextListener监听器
用来监听ServLetContext的
ServletContext会有生/死的事件
与日月齐光，与天地同寿。

通常用这个东西来加载配置文件，后面学SpringMVC的时候会用到这个东西

```

```xml
<!--    应用的初始化参数-->
<!--    ServletContext对象获得-->
    <context-param>
        <param-name>configPath</param-name>
        <param-value>/WEB-INF/config.xml</param-value>
    </context-param>
    
    <listener>
        <listener-class>com.ruandy.filter.MyListener</listener-class>
    </listener>
```

```java
//@WebListener
public class MyListener implements ServletContextListener {
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        //当servlet容器创建成功之后，咱们会去加载配置文件。
        //所以在这里要干的事情就是加载配置文件
        //怎么加载不用关，只有获取配置文件的路径即可
        //配置文件的路径会配置到web.xml中的应用初始化参数中
        //得到ServletContext对象
        //因为ServletContext对象就可以得到应用初始化参数的值
        //通过事件对象：servletContextEvent
        ServletContext ctx = servletContextEvent.getServletContext();
        String configPath = ctx.getInitParameter("configPath");
        System.out.println("----------------"+configPath);
    }
    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {

    }
}
```

#### 8、AJAX(异步JS和XML)

##### 8.1.创建XMLHttpRequest对象

> XMLHttpRequest 是 AJAX 的基础,所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。

``` js
var xmlhttp;
if (window.XMLHttpRequest)
{
    //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
    xmlhttp=new XMLHttpRequest();
}
else
{
    // IE6, IE5 浏览器执行代码
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
}
```

##### 8.2.向服务器发送请求

>XMLHttpRequest 对象用于和服务器交换数据,如需将请求发送到服务器，我们使用 **XMLHttpRequest** 对象的 **open()** 和 **send()** 方法：

| open(*method*,*url*,*async*) | **规定请求的类型、URL 以及是否异步处理请求  method：请求的类**型；GET 或 POST    url*：文件在服务器上的位置    *async*：true（异步）或 false（同步） |
| ---------------------------- | ------------------------------------------------------------ |
| send(*string*)               | 将请求发送到服务器。*string*：仅用于 POST (有请求体)请求     |

###### 8.2.1、GET请求

``` js
xmlhttp.open("GET","/try/ajax/demo_get2.php?fname=Henry&lname=Ford",true); xmlhttp.send();
```

##### 8.2.2、POST请求

如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：

``` js
xmlhttp.open("POST","/try/ajax/demo_post2.php",true);
xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
xmlhttp.send("fname=Henry&lname=Ford");
```

##### 3.服务器的响应

>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。

##### 4.onreadystatechange 事件

>当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。readyState 属性存有 XMLHttpRequest 的状态信息。下面是 XMLHttpRequest 对象的三个重要的属性：

| 属性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| onreadystatechange | 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 |
| readyState         | 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。<br/>0: 请求未初始化  1: 服务器连接已建立  2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 |
| status             | 200: "OK"<br/>404: 未找到页面                                |

```js
xmlhttp.onreadystatechange=function()//每次状态变化都会触发该函数
{
    if (xmlhttp.readyState==4 && xmlhttp.status==200)//当请求完成且响应就绪后开始操作
    {
        document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
    }
}
```

#### 9、MVC模型

```
1. jsp演变历史（了解）
	1. 早期只有servlet，只能使用response输出标签数据，非常麻烦
	2. 后来有jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中写大量的java代码（后台），又写html（前台），造成难于维护，难于分工协作
	3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性，更好维护
2. MVC：开发模式 
	1. M：Model，模型。JavaBean
		* 完成具体的业务操作，如：查询数据库，封装对象
	2. V：View，视图。JSP
		* 展示数据
	3. C：Controller，控制器。Servlet
		* 获取用户的输入
		* 调用模型
		* 将数据交给视图进行展示

	* 优缺点：
		1. 优点：
			1. 耦合性低，方便维护，可以利于分工协作
			2. 重用性高

		2. 缺点：
			1. 使得项目架构变得复杂，对开发人员要求高


```

## 第五部分：Java EE

### 1、Maven

>核心特性:
>		\1.   依赖管理
>		\2.   项目打包

#### 1、项目痛点

\1.   将项目以不同的ide打开的时候,需要删除之前的ide的环境设置,比较麻烦.而且不同ide生成项目的 目录结构也略有区别
\2.   项目中可能有很多需要依赖的jar包,下载麻烦,管理麻烦,升级麻烦

#### 2、Maven

\1.   项目设置有统一的规则,保证不同ide之间对项目的兼容性
\2.   项目可以根据maven的配置,自动下载依赖并更新

>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information.

翻译就是:Maven是一个软件工程的项目管理工具,基于工程对象模型`POM `,Maven可以从中央信息仓中构建项目,生成对项目的报告,生成项目文档.**核心就是**管理项目,构建项目

#### 3、POM工程对象模型

什么是`POM`?  是Maven最基本的,也是最重要的一个概念,我们开发者所能看到的POM的表现形式通常是以`pom.xml`出现的,这个xml中,存在我们项目的各种信息,而且在我们使用maven命令对项目进行编译,打包,clean等等之类的操作时,Maven也是先要读取该 pom.xml 文件

#### 4、Maven项目的项目结构

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Maven项目的项目结构.png)

#### 5、项目的pom.xml

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Maven项目的pomxml文件.png)

#### 6、Maven的仓库

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Maven的仓库.png)

#### 7、Maven的生命周期

Maven的的生命周期有`3`套:`clean(清理)`,`default(默认)`,`site(站点)`

##### 1、clean(清理)

1.  pre-clean:清理之前的准备工作
2.  clean:清理(删除)上一次构建的结果
3.  post-clean:做一些清理完毕之后的工作
4. 目的是删除Maven构建的`target`目录

##### 2、default(默认)

包含一下阶段:
		`validate `:验证阶段,构建之前检查项目信息的正确性
		`compile` :编译阶段
		`test `:测试阶段,就是会帮你执行测试用例,在工程打包过程中,默认会执行这个阶段.可以通过 `mvn package -DskipTests` 指令在打包的时候跳过运行测试用例
		`package` :打包阶段,将编译好的字节码文件,配置文件之类的,打包成一个jar包,war包,甚至ear包
		`verify` :验证阶段,验证打包的有效性
		`install` :本地部署,将打的包部署到(复制到)本地仓库中,以供本地的其他项目引用
		`deploy `:远程仓库部署,将打的包先部署到本地仓库,再部署到远程仓库

##### 3、site

​		`pre-site`:生成站点的准备工作
​		`site`:生成站点
​		`post-site`:结束生成
​		`site-deploy`:发布站点

### 2、Java EE介绍

>**Java EE**架构技术经历多年的发展，出现了很多实用技术。从最初的**JSP**和**Servlet**，到**JSP Model 2**基础上的各种**MVC**框架，以及轻量级容器和数据持久化工具等。目前，比较成熟的企业级开发框架有：**Struts**、**Spring MVC**、**JSF**、**Tapestry**、**TopLink**、**JPA**、**Hibernate**、**MyBatis**、**Spring**等。其中**Spring**、**Spring MVC**和**MyBatis**三个开源框架的组合**（SSM）**，以其优异的性能，成为最流行的轻量级**Java EE**架构。

### 3、Spring

什么叫Spring?  
		1.狭义的Spring:指的就是Spring FrameWork
		2.广义的Spring指的就是整个Spring的生态,包括以Spring FrameWork为基础,包含SpringBoot,SpringCloud,Spring Data,Spring Security等在内的所以一站式开发框架

>**Spring** 是一个**为企业提供轻量级解决方案**的**开源应用框架** ，是分层的JavaSE/EE full-stack 轻量级开源框架，以**IOC**（Inverse of Control 控制反转）和**AOP**（Aspect Oriented Programming 面向切面编程）为内核，使用基本的JavaBean来完成以前只可能由EJB完成的工作，取代了EJB的臃肿、低效的开发模式。
>
>该解决方案包括基于**依赖注入(DI)的核心机制**、基于**AOP的声明式事务管理**、**与多种持久化层技术的整合**、以及优秀的**Web MVC**框架等 , 
>
>Spring致力于Java EE应用各层的解决方案。在实际开发中，通常在服务器端采用**三层体系结构**，分别为**表现层（Web层）**，**业务逻辑层（Service层）**，**数据访问层（Dao层）**，Spring对每一层都提供了技术支持：
>		1.表现层：在表现层提供了Spring MVC以及与Struts等框架的整合功能
>		2.业务逻辑层：在业务逻辑层可以管理事务、记录日志等
>		3.数据访问层：在数据访问层可以整合MyBatis、Hibernate、JdbcTemplaye等技术
>
>**Spring**框架模块化分层架构如下图：

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Spring框架模块化分层架构.png)

#### 1、IOC和DI

>**控制反转**（Inversion of Control，**Io**C）是一个比较抽象的概念，是Spring框架的核心，用来消减计算机程序的耦合问题。
>**依赖注入**（Dependency Injection，**DI**）是IoC的另外一种说法，只是从不同的角度，描述相同的概念。
>
>IoC是一种宏观上的设计理念,而DI是控制翻转的具体技术实现
>
>1. IoC:    在使用Spring框架之后，对象的实例不再由调用者来创建，而是**由Spring容器来创建**，Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由调用者的程序代码转移到了Spring容器，控制权发生了反转，这就是Spring的控制反转。
>1. DI:    从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量，这相当于为调用者注入它所依赖的实例，这就是Spring的依赖注入。
>
>**综上所述，**控制反转是一种通过描述（在Spring中可以是XML或注解）并通过第三方去产生或获取特定对象的方式。在Spring中实现控制反转的是**IoC容器**，其实现方法是**依赖注入**。

##### 1、Spring IOC容器

>Spring容器会负责控制程序之间的关系，而不是由程序代码直接控制。Spring提供了两种核心容器,分别为**BeanFactory**和**ApplicationContext**。

###### 1、BeanFactory

>**BeanFactory**:由org.springframework.beans.factory.**BeanFactory接口**定义，它提供了完整的IoC服务支持，是一个**管理Bean的工厂**，主要负责初始化各种Bean;在创建BeanFactory实例时，需要提供Spring所管理容器的详细配置信息，这些信息通常采用XML文件形式来管理，其加载配置信息的语法如下：  BeanFactory beanFactory = new XmlBeanFactory(new  FileSystemResource("F: /applicationContext.xml"));(注意:创建BeanFactory实例时，需要提供XML文件的绝对路径。)

###### 2、ApplicationContext

>ApplicationContext: 是BeanFactory的子接口，是另一种常用的Spring核心容器。它由org.springframework.context.ApplicationContext接口定义，**不仅包含了BeanFactory的所有功能，还添加了对国际化、资源访问、事件传播等方面的支持。**创建ApplicationContext接口实例，通常采用**两种方法**，具体如下：
>
>1. 通过ClassPathXmlApplicationContext创建:（推荐使用） ApplicationContext applicationContext = new **ClassPathXmlApplicationContext**(String configLocation);
>
>   (ClassPathXmlApplicationContext会从**类路径classPath**中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。)
>
>2. 2.通过FileSystemXmlApplicationContext创建:
>
>      ApplicationContext applicationContext =     new FileSystemXmlApplicationContext(String configLocation);
>     （ FileSystemXmlApplicationContext会从指定的文件系统路径**（绝对路径）**中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。）

###### 3、IoC容器的实例化

>​     1.在Java项目中，会通过ClassPathXmlApplicationContext类来实例化ApplicationContext容器。而在Web项目中，ApplicationContext容器的实例化工作会交由Web服务器来完成。
>
>​     2.Web服务器实例化ApplicationContext容器时，通常会使用ContextLoaderListener来实现，此种方式只需要在web.xml中添加如下代码：

```xml
<context-param>
    <param-name>contextConfigLocation</param-name> 
    <param-value>classpath:spring/applicationContext.xml</param-value>
</context-param> 
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>

```

##### 2、依赖注入DI

> 另外:Spring规定了两种类型来决定注入值时,是否要用ref:
>
> \1.    Straight Values :包含Java的8种基本数据类型以及其包装类,和 String .这种情况用 value
>
> \2.    idref:通过ref关联在IOC容器中具体id的引用类型的数据

>在Spring容器中实现IoC的方法是依赖注入，依赖注入的作用是在使用Spring框架创建对象时，动态地将其所依赖的对象（如属性值）注入Bean组件中。Spring框架的依赖注入通常有**两种实现**方式：一种是使用**构造方法**注入，另一种是使用属性的**setter方法**注入。

**在XML文件中配置bean时,不指定id或name,IOC容器会给一个默认的名字(尾数0开始): pers.lintao.entity.Man#0**

###### 1、通过构造方法注入

通过构造方法注入的方式实现依赖注入,可能会出现**循环依赖**的问题,但是使用setter方法不会,因为通过构造方法注入是使用类的有参构造器进行的,而通过setter方法注入,是先通过无参构造器创建对象,然后再通过对象调用setter方法

```xml
<bean id="dependencyA" class="com.softeem.dependency.DependencyA">
    <constructor-arg name="dependencyB" ref="dependencyB"/>
    <!--	<property name="dependencyB" ref="dependencyB"/>-->
</bean>
<bean id="dependencyB" class="com.softeem.dependency.DependencyB">
    <constructor-arg name="dependencyA" ref="dependencyA"/>
    <!--	<property name="dependencyA" ref="dependencyA"/>-->
</bean>
```

```xml
<bean id="jackMa" class="com.softeem.entity.Man">
    <constructor-arg name="name" value="杰克马"/>
    <constructor-arg name="fund" value="数百亿的"/>
    <constructor-arg name="woman" ref="lili"/>
</bean>
<bean id="jackMa" class="com.softeem.entity.Man">
    <constructor-arg index="0" value="杰克马"/>
    <constructor-arg index="1" value="数百亿的"/>
    <constructor-arg index="2" ref="lili"/>
</bean>
<!--也可以通过 c标签(c命名空间) 来替代,前提是要在beans标签中加入:xmlns:c="http://www.springframework.org/schema/c"-->
<bean id="lili" class="com.softeem.entity.Woman">
    <constructor-arg name="name" value="莉莉"/>
    <constructor-arg name="age" value="19"/>
    <constructor-arg name="outlook" value="肤白貌美的"/>
</bean>
<bean id="jackMa" class="com.softeem.entity.Man" 
      c:name="杰克马" c:_1="数百亿的" c:woman-ref="lili"/>

```

###### 2、通过setter方法注入

```xml
<bean id="jackMa" class="com.softeem.entity.Man">
    <property name="name" value="杰克马"/>
    <property name="fund" value="数百亿的"/>
    <property name="woman" ref="lili"/>
</bean>
<!--同样可以使用 p标签 代替 <property> 标签
    xmlns:p="http://www.springframework.org/schema/p"-->
<bean id="jackMa" class="com.softeem.entity.Man"
	p:name="杰克马222" p:fund="数百亿的" p:woman-ref="lili"/>
```

###### 3、常见类型的注入方式

Spring创建的list,set和map的默认实现类如图

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Spring创建的list,set和map的默认实现类如图.png)

**a.特殊情况:(Inner Bean)内部bean**

```xml
<bean id="jackMa" class="com.softeem.entity.Man">
    <property name="name" value="杰克马"/>
    <property name="fund" value="数百亿的"/>
    <property name="woman">
        <!--内部bean不需要指定id或name,它是外部bean的专属,不能被容器中其他bean用,appCon.getBeanDefinitionNames()也获取不到他的名字-->
        <bean class="com.softeem.entity.Woman">
            <property name="name" value="玛丽"/>
            <property name="age" value="19"/>
            <property name="outlook" value="肤白貌美的"/>
        </bean>
	</property>
</bean>
```

```java
获取容器里所以被管理的bean的名字:
ApplicationContext appCon = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
String[] beanDefinitionNames = appCon.getBeanDefinitionNames();
for (String beanDefinitionName : beanDefinitionNames) {
      System.out.println(beanDefinitionName);
    }
```

**b.注入数组**

```xml
<bean id="fierceMan" class="com.softeem.entity.FierceMan">
<!--<property name="clothes" value="1,2,3"/>-->
    <property name="clothes">
        <array>
            <value>背心</value>
            <value>短裤</value>
            <value>人字拖</value>
        </array>
    </property>
</bean>
```

**c.注入List集合**

```xml
<property name="cartoonList">
    <list>
        <value>美少女战士</value>
        <value>巴啦啦小魔仙</value>
        <value>金刚葫芦娃</value>
        <value>鼹鼠的故事</value>
    </list>
</property>
```

**d.注入set集合**

```xml
<property name="womanSet">
    <set>
        <!--内部bean-->
        <bean class="com.softeem.entity.Woman">
            <property name="name" value="玛丽"/>
            <property name="age" value="19"/>
            <property name="outlook" value="肤白貌美的"/>
        </bean>
        <!--引用-->
    	<ref bean="lili"/>
    </set>
</property>
<!--被引用的bean-->
<bean id="lili" class="com.softeem.entity.Woman">
    <constructor-arg name="name" value="莉莉"/>
    <constructor-arg name="age" value="19"/>
    <constructor-arg name="outlook" value="肤白貌美的"/>
</bean>
```

**e.注入map集合**

```xml
<property name="foodMap">
    <map>
        <entry key="1" value="蛋白粉"/>
        <entry key="2" value="汤达人"/>
        <entry key="3" value="火鸡面"/>
        <entry key="4" value="统一老坛酸菜"/>
    </map>
</property>
```

**f.注入properties**

```xml
<property name="props">
    <props>
        <prop key="driver">com.mysql.cj.jdbc.Driver</prop>
        <prop key="url">jdbc:mysql://localhost:3306/lady</prop>
        <prop key="username">root</prop>
        <prop key="password">4682739155</prop>
    </props>
</property>
```



##### 3、Bean的配置(bean definition)

>1.什么是Spring中的Bean?     如果把Spring看做一个大型工厂，则Spring容器中的Bean就是该工厂的产品。要想使用这个工厂生产和管理Bean，就需要在配置文件中告诉它需要哪些Bean，以及需要使用何种方式将这些Bean装配到一起。
>
>2.Spring容器支持两种格式的配置文件:Properties文件和XML文件;  在实际开发中，最常使用的是XML文件格式的配置方式，这种配置方式是通过XML文件来注册并管理Bean之间的依赖关系。

###### 1、XML中Bean的配置

>XML配置文件的根元素是<beans>，<beans>中包含了多个<bean>子元素，每一个<bean>子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中。关于<beans>元素的常用属性如下表所示：

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\beans元素的常用属性.png)

###### 2、id和name

>###### id和name在同一个配置文件中,都必须唯一,不可以重复;在多个配置文件中,以后加载的配置文件为准

```java
ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext4.xml","classpath:appl icationContext4-1.xml");
```

>###### id的值只能有且只有一个,name的值可以为单个bean起多个名字

```xml
<!-- 给一个bean设置多个别名,id属性不允许	-->
<bean id="lili,lili1,lili2" class="com.softeem.entity.Woman">
<constructor-arg name="name" value="莉莉"/>
<constructor-arg name="age" value="19"/>
<constructor-arg name="outlook" value="肤白貌美的"/>
</bean>
<!-- 给一个bean设置多个别名,name属性允许	-->
<bean name="mary,mary1,mary2" class="com.softeem.entity.Woman">
<constructor-arg name="name" value="mary"/>
<constructor-arg name="age" value="20"/>
<constructor-arg name="outlook" value="肤白貌美的"/>
</bean>

```

###### 3、Bean的作用域Scope

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\bean的作用域.png)

###### 4、懒加载

```xml
<!-- 开启懒加载,在容器初始化过程中不实例化Bean对象,
而且只有在容器需要该Bean的实例对象时才需要初始化Bean ,而且也是全局唯一	-->

<bean id="lili" class="com.softeem.entity.Woman" lazy-init="true">
<constructor-arg name="name" value="莉莉2"/>
<constructor-arg name="age" value="192"/>
<constructor-arg name="outlook" value="肤白貌美的"/>
</bean>

```

###### 5、depends on



###### 6、Spring获取Bean的实例

>​     创建Spring容器后，就可以获取Spring容器中的Bean。Spring获取Bean的实例通常采用以下**两种**方法：
>
>​		1.Object  **getBean**(String name);根据容器中Bean的id或name来获取指定的Bean，获取之后需要进行强制类型转换。
>
>​		2.<T> T   **getBean**(Class<T> requiredType);根据类的类型来获取Bean的实例。由于此方法为泛型方法，因此在获取Bean之后不需要进行强制类型转换。

##### 4、Bean的实例化(基于XML配置文件)

>1.在面向对象的程序中，想要使用某个对象，就需要先实例化这个对象。同样，在Spring中，要想使用容器中的Bean，也需要实例化Bean。实例化Bean有**三种方式**，分别为**构造方法实例化(常用)**、**静态工厂方式实例化**和**实例工厂方式实例化**

###### 1.通过构造方法

a.无参构造(默认)

```xml
<bean id="lili" class="com.softeem.entity.Woman">
    <property name="name" value="莉莉"/>
    <property name="age" value="19" />
    <property name="outlook" value="肤白貌美的"/>
</bean>
```

b.有参构造

```xml
<bean id="lili" class="com.softeem.entity.Woman">
    <!-- 也可以用index表示有参构造器参数的下标0,1,2 -->
    <constructor-arg name="name" value="莉莉"/>
    <constructor-arg name="age" value="19"/>
    <constructor-arg name="outlook" value="肤白貌美的"/>
</bean>
```

```java
//默认情况下,容器在初始化的时候,就会通过无参构造器帮我们创建对象
ApplicationContext context = new
ClassPathXmlApplicationContext("classpath:applicationContext.xml"); 
Woman lili =context.getBean("lili",Woman.class); System.out.println(lili);

```

###### 2.通过工厂方法(隐藏对象创建的过程)

二者的区别:静态工厂不需要工厂类的实例,直接通过类名就可调用创建实例的方法,而工厂实例需要先创建一个工厂实例的对象,再通过这个对象去调用生产实例的方法

a.静态工厂方法

```java
/**
*	静态工厂
*/
public class WomanStaticFactory {
    public static Woman selectLili(){ 
        Woman lili = new Woman(); lili.setName(" 莉 莉 "); 		lili.setAge(20); lili.setOutlook("肤白貌美的"); 
        return lili;
    }
    public static Woman selectMary(){
        Woman mary = new Woman("玛丽",22,"膀大腰圆的");
        return mary;
	}
}
```

```xml
<bean id="lili" class="com.softeem.factory.WomanStaticFactory" factory-method="selectLili"/>
<bean id="mary" class="com.softeem.factory.WomanStaticFactory" factory-method="selectMary"/>
```

b.工厂实例方法

```java
/**
*	工厂实例
*/
public class WomanStaticFactory {
    public Woman selectLili(){ 
        Woman lili = new Woman(); lili.setName(" 莉 莉 "); 		
        lili.setAge(20); lili.setOutlook("肤白貌美的"); 
        return lili;
    }
    public Woman selectMary(){
        Woman mary = new Woman("玛丽",22,"膀大腰圆的");
        return mary;
	}
}
```

```xml
<bean id="womanFactory" class="com.softeem.factory.WomanStaticFactory"/>

<bean id="lili" factory-bean="womanFactory" factory-method="selectLili"/>
<bean id="mary" factory-bean="womanFactory" factory-method="selectMary"/>
```

##### 6、Bean的生命周期

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\bean的生命周期简洁版.png)

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\bean的生命周期完整版.jpg)

```
1.对Bean进行实例化,还需要参考Scope属性
2.对实例化之后的Bean进行依赖注入
3.检查是否实现了Aware相关的接口
	3.1.如果实现了 BeanNameAware ,Spring会将配置文件中bean的id传给setBeanName()方法
	3.2.如果实现了 BeanFactoryAware ,Spring会调用setBeanFactory方法,将BeanFactory实例传进去
	3.3.如果实现了 ApplicationContextAware ,Spring会调用setApplicationContext方法,将容器/
上下文的引用传递进去
4.做前置处理( BeanPostProcessor 接口):检查是否Bean是否实现了 BeanPostProcessor 接口,将调用 postProcessBeforeInitialization 方法
5.检查是否实现了 InitializingBean 接口,调用 afterPropertiesSet 方法,比如,如果一个Bean 有自定义的初始化方法,就会在该方法之后被调用
6.在第五步的基础上,如果有自定义的初始化方法,则被调用
7.做后置处理( BeanPostProcessor 接口):检查是否Bean是否实现了 BeanPostProcessor 接口,将调用 postProcessAfterInitialization 方法
8.注册和Destruction相关的回调接口
9.使用Bean
10.是否实现了 DisposableBean 接口
11.检查是否有自定义的Destroy方法,有的话就执行
```

###### init-method和detroy-method的使用

```java
public void initMethod(){
	System.out.println("女嘉宾的自定义初始化方法被调用");
}
public void destroyMethod(){
	System.out.println("女嘉宾的自定义销毁方法被调用");
}
```

```xml
<bean id="lili" class="com.softeem.entity.Woman" 
      init-method="initMethod" destroy- method="destroyMethod">
    <constructor-arg name="name" value="莉莉2"/>
    <constructor-arg name="age" value="192"/>
    <constructor-arg name="outlook" value="肤白貌美的"/>
</bean>

```

```java
public class SpringApp4 {
public static void main(String[] args) { 
    ApplicationContext context = new
ClassPathXmlApplicationContext("classpath:applicationContext4-1.xml");
	//关闭容器
    ((ClassPathXmlApplicationContext)context).registerShutdownHook();
	}
}
```

##### 7、Bean 的装配方式

>Bean的装配可以理解为依赖关系注入，Bean的装配方式即Bean依赖注入的方式。Spring容器支持多种形式的Bean的装配方式，如**基于XML的装配**、基于**注解（Annotation）的装配**以及**自动装配**，其中最常用的是基于注解的装配。

###### 1、基于XML的装配

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\基于XML的bean的装配.png)



>XML中的自动装配:所谓自动装配，就是将一个Bean自动的注入到到其他Bean的Property中。 Spring的<bean>元素中包含一个autowire属性，我们可以通过设置autowire的属性值来自动装配Bean。autowire属性有5个值，其值及说明下表所示：

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\自动装配.png)

```xml
<bean id= "testDao" class="annotation.dao. TestDaoImpl" />
<bean id= "testService" class="annotation.service. TestSeviceImpl" autowire="byName" />
<bean id= "testController" class="annotation.controller.TestController" autowire="byName" />
```



###### 2、基于Annotation注解

>基于XML的装配可能会导致XML配置文件过于臃肿，给后续的维护和升级带来一定的困难。为此，Spring提供了对Annotation（注解）技术的全面支持。

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\基于注解的bean的装配.png)

```xml
<!-- 使用context命名空间，通过Spring扫描指定包及其子包下所有Bean的实现类，进行注解解析 -->
<context:component-scan base-package="annotation"/>
```

###### 2.1、**根据组件(** Bean )的类型:用来标注Bean的职责

1.`@Component`:通用注解,就是被扫描后将该类交给IOC容器管理
2.`@Controller`:在web环境下放在控制层的类上
3.`@Service`:一般放在业务层/逻辑层的类上面
4.`@Repository`:一般放在持久层/DAO层的类上

###### 2.2、自动装配相关注解:方便开发人员注入属性

>1.按类型
>		1.`@Autowired`:由IOC容器按照Bean的类型去注入,如果类型匹配不上,还会尝试将属性名当做Bean的id再去根据名称做匹配(`@Autowired`不能使用在局部变量上);有一个布尔类型的`required元配置信息`可以配置,默认值为`true`,代表所注入的属性不可以为null,,如果为null,Spring抛出异常;也可以设置为 false ,代表允许属性为null,Spring不抛出异常,但是jdk会抛异常.还可以加入`@Qualifier("xxxx")`,指定要注入的对象的`id`是什么(`@Qualifier("xxxx")`不能单独使用)
>		2.`@Inject`:基于JSR-330(Java依赖注入标准330文件),需要额外引入依赖
>
>2.按名称
>		1.`@Named`:基于JSR-330,根据名称做注入,一般情况下会配合`@Inject`一起使用
>		2.`@Resource`:基于JSR-250标准,先按照`名称`匹配(元配置信息name的值的优先级 `> `属性名),然后根据`类型`匹配

>元数据主解:辅助容器更好的管理Bean
>		1.`@Primary`:用在根据类型注入,但是容器中有多个相同类型的Bean的情况,@Primary同来提升优先级,但是优先级低于根据名称注入
>		2.`@Scope`:默认情况下是singleton,单例,可以设置为`@Scope(scopeName="prototype")`
>		3.`@PostConstruct`:作用在方法上,相当于XML文件中的`init-method`
>		4.`@PreDestroy`:作用在方法上,相当于XML文件中的`destory-method`
>		5.`@Value`:为类型的属性注入静态数据

```properties
jdbc.driverClassName=cj.Driver jdbc.url=softeem.com
```

```xml
<!-- 让IOC容器读取外部配置文件	-->
<context:property-placeholder location="classpath:jdbc.properties"/>
```

```java
@Value("${jdbc.driverClassName}") 
private String driverClassName; @Value("${jdbc.url}")
private String url;
```

###### 3、基于Java代码配置

```java
package com.softeem.config;

import com.softeem.entity.Man; import com.softeem.entity.Woman;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan; 
import org.springframework.context.annotation.Configuration; 
import org.springframework.context.annotation.Scope;

@Configuration
@ComponentScan(basePackages = "com.softeem") //遗留问题:父子容器(自己学习)
public class IOCConfig {
    @Bean
    @Scope(scopeName = "prototype") 
    public Woman lili2(){
    	Woman woman = new Woman();
        woman.setName(" 莉 莉 ");
        woman.setAge(19); 
        woman.setOutlook("肤白貌美的");
        return woman;
    }

    @Bean
    public Man peter(){
    	Man man = new Man();
        man.setName("peter");
        man.setFund("数百亿的"); 
        man.setWoman(lili2()); 
        return man;
    }

    @Bean
    public Man jack(Woman lili2){
        Man man = new Man(); 
        man.setName("jack"); 
        man.setFund("数百亿的"); 
        man.setWoman(lili2); 
        return man;
    }
}
```

```java
public class SpringApp7 {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(IOCConfig.class);
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
        System.out.println("*************");
        Man jack = context.getBean("jack", Man.class);
        Man peter = context.getBean("peter", Man.class);
        Woman lili2 = context.getBean("lili2", Woman.class);
        System.out.println(jack.getWoman()+":::"+peter.getWoman()+":::"+lili2);
        context.registerShutdownHook();
    }
}
```



#### 2、利用dom4j和发射实现IOC容器

>实现一个简单的IOC容器（dom4j+jaxen（解析xpath语言））

```xml
<dependencies>
    <!-- dom4j:利用java对xml文件进行解析的工具包 -->
    <dependency>
        <groupId>org.dom4j</groupId>
        <artifactId>dom4j</artifactId>
        <version>2.1.1</version>
    </dependency>

	<!-- jaxen:是对xml文件中xpath表达式支持的工具包-->
    <dependency>
        <groupId>jaxen</groupId>
        <artifactId>jaxen</artifactId>
        <version>1.2.0</version>
    </dependency>
</dependencies>

```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!--自定义的约束文件,没有引入外部解析-->
<beans>
    <bean id="tiga" class="com.softeem.entity.Cartoon">
    	<property name="cartoonName" value="迪迦奥特曼"/>
    </bean>

    <bean id="neo" class="com.softeem.entity.Cartoon">
    	<property name="cartoonName" value="雷欧奥特曼"/>
    </bean>
</beans>
```

```java
/**
*	卡通
*	@author muzi@softeem.com
* @since 2021年8月17日20:31:22
*/
public class Cartoon {
private String cartoonName; public String getCartoonName() {
    return cartoonName;
    }
    public void setCartoonName(String cartoonName) { this.cartoonName = cartoonName;
    }

    @Override
    public String toString() { 
        return "Cartoon{" + "cartoonName='" + cartoonName + '\'' + '}';
    }
}

```

```java
/**
*	上下文的接口
*	@author muzi@softeem.com
* @since 2021年8月17日20:31:22
*/
public interface ApplicationContext {

public Object getBean(String id);
}
```

```java
/**
*	根据类路径下的xml配置文件初始化的容器
*
*	@author muzi@softeem.com
* @since 2021年8月17日20:31:22
*/
public class ClassPathXmlApplicationContext implements ApplicationContext {
    //容器本身
    private Map container = new HashMap();
    /*spring用的是Map但是不是HashMap，用的是ConcurrentHashMap();
    因为HashMap并发环境下线程不安全，会出现Hash碰撞*/

    public ClassPathXmlApplicationContext() {
        try {
            //获取配置文件的位置
            String path = this.getClass().getResource("/applicationContext.xml").getPath();
            System.out.println("配置文件的地址为:" + path);
            //创建解析配置文件的类的实例
            SAXReader saxReader = new SAXReader();
            //将配置文件解析文Document对象
            Document document = saxReader.read(new File(path));
            //获取Document对象的根节点下的所有子节点
            List<Node> beans = document.getRootElement().selectNodes("bean"); 
            for (Node bean : beans) {
                Element element = (Element) bean;
                String id = element.attributeValue("id"); 
                System.out.println("获取到的节点的id属性值为:" + id);
                String className = element.attributeValue("class");
                //利用反射机制获得Class对象
                Class clazz = Class.forName(className);
                //创建实例对象
                Object obj = clazz.newInstance();
                List<Node> propertyList = element.selectNodes("property"); 
                //遍历bean下的属性标签,并设置实例对象的属性值
                for (Node propertyNode : propertyList) {
    				Element property= (Element)propertyNode; 
                    String name = property.attributeValue("name");
                    System.out.println("属性名为:"+name);
   					 String value = property.attributeValue("value");
                    System.out.println("值为:"+value);
                    //cartoonName==> setCartoonName
                    String setMethod = "set" + name.substring(0, 1).toUpperCase() +
                    name.substring(1);
                    System.out.println("set方法名字为:"+setMethod);
                    Method method = clazz.getMethod(setMethod, String.class); 									method.invoke(obj,value);
    				}
    				//将注入值之后的对象交给容器管理
                	container.put(id, obj);
    			}
        	System.out.println("容器初始化完毕~~~");
    } catch (DocumentException e) { e.printStackTrace();
    } catch (ClassNotFoundException e) { e.printStackTrace();
    } catch (InstantiationException e) { e.printStackTrace();
    } catch (IllegalAccessException e) { e.printStackTrace();
    } catch (NoSuchMethodException e) { e.printStackTrace();
    } catch (InvocationTargetException e) { e.printStackTrace();
    }
}

    @Override
    public Object getBean(String id) { 
        return container.get(id);
    }
}

```

```java
public class App {

public static void main(String[] args) {
ApplicationContext context = new ClassPathXmlApplicationContext(); Cartoon tiga =(Cartoon) context.getBean("tiga"); System.out.println(tiga);
}
}

```

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\简单实现一个IOC容器.jpg)

#### 3、AOP

>1.AOP的全称是Aspect-Oriented Programming，即面向切面编程。它是面向对象编程（OOP）的一种补充，目前已成为一种比较成熟的编程方式。
>
>2.AOP采取**横向抽取机制**，将分散在各个方法中的重复代码提取出来，然后在程序编译或运行时，再将这些提取出来的代码应用到需要执行的地方。这种采用横向抽取机制的方式，采用传统的OOP思想显然是无法办到的，因为OOP只能实现父子关系的纵向的重用。虽然AOP是一种新的编程思想，但却不是OOP的替代品，它只是OOP的延伸和补充。
>
>3.AOP的使用，使开发人员在编写业务逻辑时可以专心于核心业务，而不用过多的关注于其他业务逻辑的实现，这不但提高了开发效率，而且增强了代码的可维护性。AOP的基本单元是Aspect(切面),下图是类与切面的关系:

![ ](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\类与切面的关系.png)

##### 1、AOP的术语

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\AOP术语.png)

##### 2、切点表达式

| -          | 值                                                |
| ---------- | ------------------------------------------------- |
| 切点表达式 | execution(*  com.softeem..\*.*(..))               |
| 方法签名   | void com.softeem.service.UserService.insertUser() |

>涉及到的通配符(从左到右):
>
>1. `*`:返回值的通配符,返回任意类型
>2. `..`:包的通配符:代表所有包及其子包
>3. `*`:类名的通配符:代表所有类
>4. `*`:方法的通配符,代表所有方法
>5. `..`:方法参数的通配符,代表所有类型,任意个数的参数
>
>常见形式:
>
>1. execution(*  com.softeem..\*.insert*(..)):所有以insert开头的参数任意,返回值任意方法
>2. execution(*  com.softeem..\*.*(String,..)):匹配所有方法中方法参数的第一个参数为String的方法
>3. execution(*  com.softeem..\*.*(..,String)):匹配所有方法中方法参数的最后一个参数为String的方法



##### 3、Spring AOP的织入方式

>1.根据不同的实现技术，AOP织入有三种方式：a**编译器织入**，需要有特殊的Java编译器；b**类装载期织入**，需要有特殊的类装载器；c**动态代理织入**，在运行期为目标类添加通知/生成子类的方式。
>
>2.Spring AOP框架默认采用动态代理织入，而**AspectJ**（基于Java语言的AOP框架）采用编译器织入和类装载期织入。

###### 3.1、JDK动态代理织入

>Spring AOP中常用JDK和CGLIB两种动态代理技术。
>
>1. JDK动态代理是通过java.lang.reflect.Proxy 类来实现的，它必须借助一个接口才能产生代理对象。因此，对于使用业务接口的类，Spring默认会使用JDK动态代理来实现AOP。我们可以调用Proxy类的newProxyInstance()方法来创建代理对象。



###### 3.2、CGLIB动态代理织入

>2. CGLIB（Code Generation Library）是一个高性能开源的代码生成包，它采用非常底层的字节码技术，对指定的目标类生成一个子类，并对子类进行增强。在Spring Core包中已经集成了CGLIB所需要的JAR包，不需要另外导入JAR包。





##### 4、Spring AOP通知类型(xml配置)

**`特别注意`:3个After通知执行的顺序是以在配置文件中声明的顺序为准,并没有默认顺序;同理前置通知和环绕通知也是如此**

| **类型**               | **说明**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| Before advice          | 前置通知:在目标方法执行前运行                                |
| After returning advice | 返回后通知:在目标方法返回数据后执行(正常执行结束)  ,和After throwing advice互斥(二者只会出现其中一个) |
| After throwing advice  | 异常通知:在目标方法抛出异常后执行,和 After returning advice 互斥(二者只会出现其中一个) |
| After (finally) advice | 后置通知:在目标方法运行后执行(无论是正常结束还是抛出异常)    |
| `Around advice  `      | 环绕通知:可以进行自定义通知执行的时机,甚至于可以决定目标方法是否执行,返回值是什么;    joinPoint.proceed();调用目标代码执行业务方法 |

###### 4.0.JoinPoint

```java
		//joinPoint.getSignature():通过连接点获得目标方法的方法签名
        System.out.println("方法签名为:"+joinPoint.getSignature());
        //joinPoint.getTarget():通过连接点获取目标对象
        System.out.println("目标对象"+joinPoint.getTarget());
    	//通过joinPoint.getArgs()获得目标方法被调用时拿到的实际参数值
		Object[] args = joinPoint.getArgs();
```

**ProceedingJoinPoint 参数只能用在环绕通知里,否则报上述错误,其他通知类型的参数使用ProceedingJoinPoint 的父类对象JoinPoint** 

###### 4.1.Before advice

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 										   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 									   xmlns:aop="http://www.springframework.org/schema/aop" 
       xsi:schemaLocation="http://www.springframework.org/schema/beans 							   https://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop                						   		   https://www.springframework.org/schema/aop/spring-aop.xsd">
	<!-- 切面类对象的配置	-->
    <bean id="myAspect" class="com.softeem.aspect.MyAspect"/>
    <!-- 目标对象的配置	-->
    <bean id="userService" class="com.softeem.service.UserService"/>

    <!-- AOP的配置	-->
    <aop:config>
        <aop:pointcut id="firstPC" expression="execution(* com.softeem..*.*(..))"/>
        <aop:aspect ref="myAspect">
            <!--	aop:before定义一个前置通知	-->
            <aop:before method="logExecuteTime" pointcut-ref="firstPC"/>
        </aop:aspect>
    </aop:config>
    
</beans>
```

```java
/**
*	切面类
*	@author lyming
*/
public class MyAspect {
//import org.aspectj.lang.JoinPoint;来自AspectJ 
    public void logExecuteTime(JoinPoint joinpoint){
        System.out.println("当前方法执行时间为"+ LocalDateTime.now());
    }
}
```

```java
/**
*	用户Service
*	@author lyming
*/
public class UserService { 
    public void insertUser(){
        //业务逻辑相关代码
        System.out.println("UserService插入一条用户信息");
	}
}
```

```java
public class App {

public static void main(String[] args) { 
    ClassPathXmlApplicationContext context = new
						ClassPathXmlApplicationContext("classpath:applicationContext.xml");
    UserService userService = context.getBean("userService", UserService.class); 				userService.insertUser();
}
```

###### 4.2.After returning advice

```java
    public void afterReturningAdvice(JoinPoint joinPoint,Object result){ 							System.out.println("==============返回后=============");
        //joinPoint.getSignature():通过连接点获得目标方法的方法签名
        System.out.println("方法签名为:"+joinPoint.getSignature());
        //joinPoint.getTarget():通过连接点获取目标对象
        System.out.println("目标对象"+joinPoint.getTarget());
    	//通过joinPoint.getArgs()获得目标方法被调用时拿到的实际参数值
        Object[] args = joinPoint.getArgs();
        for (int i = 0; i < args.length; i++) { 
            System.out.println("第"+(i+1)+"个参数值为"+args[i]);
		}
		System.out.println("afterReturningAdvice 通 知 "); 
		System.out.println("目标方法执行的返回值为"+result);
}
```

```xml
<aop:aspect ref="myAspect">
    <!--	返回后通知	-->
    <aop:after-returning method="afterReturningAdvice" pointcut-ref="firstPC" returning="result"/>
</aop:aspect>
```

###### 4.3.After throwing advice

```java
    public void afterThrowingAdvice(JoinPoint joinPoint,Throwable e){ 								System.out.println("========== 异 常 后 =======");                                           System.out.println("afterThrowingAdvice 通 知 "); 
    	System.out.println("目标方法抛出的异常为"+e);
        //记录日志 什么时间+什么接口+什么参数+抛出了什么异常+异常信息是什么
        //lambda+stream
        System.out.println(LocalDateTime.now()+"接口为:"+joinPoint.getSignature()
        +"参数为"+ joinPoint.getArgs()+"异常为"+e);
	}
```

```xml
<aop:aspect ref="myAspect">
    <!--	异常返回通知	-->
    <aop:after-throwing method="afterThrowingAdvice" pointcut-ref="firstPC" throwing="e"/>
</aop:aspect>
```

```java
public int insertUser(int id,String name) throws Exception {
	//业务逻辑的代码
    System.out.println("==============insertUser=============");
    System.out.println("新增了带参数的一个用户");
    if (1==1) {
    	throw new Exception("无中生有的异常");
    }
    return 1;
}
```

###### 4.4.After (finally) advice

```java
public void afterFinallyAdvice(JoinPoint joinPoint){ 
    System.out.println("==============后置通知============="); 									System.out.println("afterThrowingAdvice通知");
}
```

```xml
<aop:aspect ref="myAspect">
    <aop:after method="afterFinallyAdvice" pointcut-ref="firstPC" />
</aop:aspect>
```

###### 4.5.Around Advice环绕通知

```java
public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
    //前置通知
    System.out.println("前置通知");
    //目标方法执行
    try {
        //执行目标对象的业务代码
        Object result = joinPoint.proceed(); 
        System.out.println("返回后通知");
        //返回后通知
        return result;
    } catch (Throwable throwable) {
        //异常通知
        System.out.println("异常通知,异常为"+throwable);
        //一定要抛出去,避免调用目标方法的线程不知道出现了异常
        //一个最典型的错误就是不抛出异常影响事务回滚
        throw throwable;
    }finally {
    	System.out.println("后置通知");
    }
}
```

##### 5、基于注解配置Spring AOP

```java
@Component 
@Aspect
public class MyAspect2 {
    /**
    * 定义切点
    */
    @Pointcut("execution(* com.softeem..*.*(..))") 
    public void firstPC(){
        
    }
    /**
    *	引用切点,如果切点是本类定义的,则可以省略类名,否则应写为类名加方法名
    *	@Before(value="MyAspect2.firstPC()")
    */
    @Before(value="firstPC()")
    public void beforeAdvice(JoinPoint joinPoint) { 
        System.out.println("==============前置============="); 
        Object target = joinPoint.getTarget(); 
        System.out.println("目标对象" + joinPoint.getTarget());
    	System.out.println("当前接口执行时间为" + LocalDateTime.now());
    }

    @AfterReturning(value = "firstPC()",returning ="result" )
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) { 							System.out.println("==============返回后=============");
    	System.out.println("afterReturningAdvice 通 知 ");
        System.out.println("目标方法执行的返回值为" + result);
    	result = 100;
    }

    @AfterThrowing(value = "firstPC()",throwing ="e")
    public void afterThrowingAdvice(JoinPoint joinPoint, Throwable e) { 							System.out.println("============== 异 常 后 ============="); 								System.out.println("afterThrowingAdvice 通 知 "); 
        System.out.println("目标方法抛出的异常为" + e);
    	//记录日志 什么时间+什么接口+什么参数+抛出了什么异常+异常信息是什么
    	//lambda+stream
    	System.out.println(LocalDateTime.now() + "接口为:" + joinPoint.getSignature()
    + "参数为" + joinPoint.getArgs() + "异常为" + e);
    }

    @After(value="firstPC()")
    public void afterFinallyAdvice(JoinPoint joinPoint) { 
        System.out.println("==============后置通知=============");
        System.out.println("afterFinallyAdvice通知");
    }

    @Around(value="firstPC()")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        //前置通知
        System.out.println("前置通知");
        //目标方法执行
        try {
            Object result = joinPoint.proceed();
            System.out.println("返回后通知");
            //返回后通知
            return result;
        } catch (Throwable throwable) {
            //异常通知
            System.out.println("异常通知,异常为"+throwable);
            //一定要抛出去,避免调用目标方法的线程不知道出现了异常
            //一个最典型的错误就是不抛出异常影响事务回滚
            throw throwable;
        }finally {
        	System.out.println("后置通知");
        }
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 								xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop 
https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 开启包扫描和注解开发 -->
    <context:component-scan base-package="com.softeem"/>
    <!-- aspectJ提供了一套注解,帮助我们自动代理 -->
    <aop:aspectj-autoproxy/>

</beans>

```

#### 4、Spring-JDBC的CRUD

##### 4.1.SpringJDBC的配置

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.9.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.2.9.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.22</version>
    </dependency>
</dependencies>
```

```xml
    <!-- 开启包扫描和注解开发 -->
	<context:component-scan base-package="com.softeem"/>

    <!-- #################数据库的配置################# -->
    <!-- 数 据 源 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/vip1_spring_jdbc? useSSL=false&amp;
        characterEncoding=UTF- 8&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>

    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    	<property name="dataSource" ref="dataSource"/>
    </bean>

```

```java
@Repository
public class TestDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void findById(Integer id) {
        String sql = "SELECT * FROM test WHERE id = ?"; 
        Test test = jdbcTemplate.queryForObject(sql,new Object[]{id},
        		new BeanPropertyRowMapper<Test>(Test.class)); 
        System.out.println(test);
    }
}
```

```java
public class App {

    public static void main(String[] args) { 
        ClassPathXmlApplicationContext context = new
            ClassPathXmlApplicationContext("classpath:applicationContext.xml"); 
        TestDao testDao = context.getBean("testDao", TestDao.class); 
        testDao.findById(1);
    }
}
```

##### 4.2.更新数据的操作

>JdbcTemplate提供了若干个update()方法，update()方法可以完成插入、更新和删除数据的操作。在JdbcTemplate类中，提供了一系列的update()方法，其常用方法下表所示：

| 方法                                                         | 描述                                                         |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| int update(String sql)                                       | 发出单个 SQL 更新操作,返回受影响条数                         |
| int update(String sql, Object[] args)                        | 发出单个 SQL 更新操作,绑定指定的参数,返回受影响条数          |
| int update(String sql, Object[] args, int[] argTypes)        | 发出单个 SQL 更新操作,绑定指定的参数和参数类型,返回受影响条数 |
| int update(String sql, PreparedStatementSetter pss)          | 使用 PreparedStatementSetter 发出一条更新语句以设置绑定参数，并使用给定的 SQL。 |
| int update(PreparedStatementCreator psc)                     | 创建PreparedStatement对象同时给SQL语句绑定参数               |
| int update(final PreparedStatementCreator psc, final PreparedStatementSetter pss) |                                                              |
| int update(PreparedStatementCreator psc, KeyHolder generatedKeyHolder) | 返回数据库的表自增主键值                                     |

```java
@Repository
public class ForumDao {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;	
    
    public void addForum(final Forum forum) {
    	final String sql = "INSERT INTO t_forum(forum_name,forum_desc) VALUES(?,?)";
    	Object[] params = new Object[] { forum.getForumName(),forum.getForumDesc() };
        // 方式2
        jdbcTemplate.update(sql, params);

        // 方式3 显示指定每个占位符所对应的字段的数据类型
        jdbcTemplate.update(sql, params,new int[]{Types.VARCHAR,Types.VARCHAR});
    }
    ...
}
     JdbcTemplate	将原来复杂的数据更新操作简化为定义SQL语句、准备参数、调用update()这3个步骤。
     尽量使用可绑定参数的SQL语句，尽量在DAO中使用类级别的静态常量（final static）定义SQL语句，不应在方法内部声明SQL字符串变量。
```

```java
public void addForum(final Forum forum) {
    final String sql = "INSERT INTO t_forum(forum_name,forum_desc) VALUES(?,?)";
    Object[] params = new Object[] { forum.getForumName(),forum.getForumDesc() };
    // 方式4
    jdbcTemplate.update(sql, new PreparedStatementSetter() {
        @Override
        public void setValues(PreparedStatement ps) throws SQLException {
            ps.setString(1, forum.getForumName());
            ps.setString(2, forum.getForumDesc());
        }
    });    
}
/*
int update(String sql,PreparedStatementSetter pss):
    PreparedStatementSetter是一个回调接口，它定义了一个void setValues(PreparedStatement ps)接口方法。JdbcTemplate使用SQL语句创建出PreparedStatement实例后，将调用回调接口方法执行绑定参数的操作。
    PreparedStatement绑定参数时，参数索引从1开始而非从0开始。
*/
```

```java
public void addForum(final Forum forum) {
    final String sql = "INSERT INTO t_forum(forum_name,forum_desc)   VALUES(?,?)";
    Object[] params = new Object[] { forum.getForumName(),forum.getForumDesc() };
    // 方式5
    jdbcTemplate.update(new PreparedStatementCreator() {
		@Override
        public PreparedStatement createPreparedStatement(Connection conn)
	           throws SQLException {
             PreparedStatement ps = conn.prepareStatement(sql);
             ps.setString(1, forum.getForumName());
             ps.setString(2, forum.getForumDesc());
             return ps;
        }
   });
}
/*
int update(PreparedStatementCreator psc):
    PreparedStatementCreator 也是一个回调接口，它负责创建一个PreparedStatement 实例。它定义了一个PreparedStatement createPreparedStatement(Connection conn)接口方法。
    
int  update(PreparedStatementCreator psc,PreparedStatementSetter pss)联合使用PreparedStatementCreator 和PreparedStatementSetter回调接口。
     在实际使用中，应该优先考虑使用不带回调接口的jdbcTemplate方法。
*/
```

###### 4.2.1.返回数据库的表自增主键值

```java
/*
在JDBC3.0规范中，当新增记录时，允许将数据库自动产生的主键值绑定到Statement或PreparedStatement。Spring利用这一技术，提供了一个可以返回新增记录对应主键值的方法，如下：
int  update(PreparedStatementCreator psc，keyHolder generatedkeyHolder)
       keyHolder 是一个回调接口，Spring使用它保存新增记录对应的主键。Spring为keyHolder 接口指代了一个通用的实现类GeneratedKeyHolder。
*/
public void addForum(final Forum forum) {
       final String sql = "INSERT INTO t_forum(forum_name,forum_desc)   VALUES(?,?)";
       Object[] params = new Object[] { forum.getForumName(),forum.getForumDesc() };
       // 方式4
       KeyHolder keyHolder = new GeneratedKeyHolder();
       jdbcTemplate.update(new PreparedStatementCreator() {
             public PreparedStatement createPreparedStatement(Connection conn)
	           throws SQLException {
	     PreparedStatement ps = conn.prepareStatement(sql, 		 	                                                       Statement.RETURN_GENERATED_KEYS);
	     ps.setString(1, forum.getForumName());
	     ps.setString(2, forum.getForumDesc());
	     return ps;
             }
        }, keyHolder);
       forum.setForumId(keyHolder.getKey().intValue());
}
```

###### 4.2.2.批量更改数据

>1.int[ ] batchUpdate(String[] sql)多条SQL语句组成一个数组（这些SQL语句不带参数），该方法以批量方式执行这些语句。
>
>2.int[ ] batchUpdate(String sql,BatchPreparedStatementSetter pss)使用该方法对于同一结构的带参数的SQL语句多次进行数据更新操作。通过BatchPreparedStatementSetter 回调接口进行批量参数的绑定工作。

```java
/*
注意：BatchPreparedStatementSetter是一次性提交数据的，而不会分批提交，getBatchSize()是整批的大小。
*/
public void addForums(final List<Forum> forums) {
    final String sql = "INSERT INTO t_forum(forum_name,forum_desc) VALUES(?,?)";
    jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
        //指定本批次大小
        public int getBatchSize() {
                return forums.size();
        }
		//为给定的PreparedStatement 设置参数
        public void setValues(PreparedStatement ps, int index)throws SQLException {
                Forum forum = forums.get(index);
                ps.setString(1, forum.getForumName());
                ps.setString(2, forum.getForumDesc());
        }
    });
}
```



##### 4.3.查询数据的操作

>在Spring JDBC中，仅需要指定SQL查询语句并定义好如何从结果集中返回数据就可以。JdbcTemplate类中还提供了大量的query()方法来处理各种对数据库表的查询操作。其中，常用的几个query()方法如下所示：

**注意**：当处理大结果集时，如果使用RowMapper，那么采用的方式是将结果集中的所有数据都放到一个 List<T>对象中，这样将会占用大量的JVM内存，甚至可能直接引发OutOfMemoryException异常。这时，可使用RowCallbackHandler 接口，在processRow(ResultSet rs)接口方法内部一边获取数据一边完成处理。这样数据就不会在内存中堆积。

采用RowMapper操作方式是先获取数据，然后再处理数据；

采用RowCallbackHandler ,操作方式是一边获取数据一边处理，处理完就可丢弃之。

因此可以将RowMapper看作采用**批量化数据处理**策略，而RowCallbackHandler 则采用**流化数据处理**策略。

###### 4.3.1.使用RowCallbackHandler处理结果集

>•void query(String sql,Object[] args,**RowCallbackHandler rch**)
>
>•void query(String sql,Object[] args,int[] argTypes,**RowCallbackHandler rch**)
>
>•void query(PreparedStatementCreator psc,**RowCallbackHandler rch**)
>
>•void query(String sql,PreparedStatementSetter pss,**RowCallbackHandler rch**)
>
>•void query(String sql,**RowCallbackHandler rch**)

```java
/*
RowCallbackHandler是一个回调接口，通过该接口可以定义如何从结果集中获取数据。它定义了一个void processRow(ResultSet rs)接口方法。Spring会遍历结果集，对结果集中的每一行调用RowCallbackHandler回调接口处理数据。
*/
public Forum getForum(final int forumId) {
    String sql = "SELECT forum_name,forum_desc FROM t_forum WHERE forum_id=?";
    final Forum forum = new Forum();
    jdbcTemplate.query(sql, new Object[] { forumId }, new RowCallbackHandler() {
	    public void processRow(ResultSet rs) throws SQLException {
			forum.setForumId(forumId);
            forum.setForumName(rs.getString("forum_name"));												forum.setForumDesc(rs.getString("forum_desc"));
	    }
    });
    return forum;
}



public List<Forum> getForums(final int fromId, final int toId) {
    String sql = "SELECT forum_id,forum_name,forum_desc FROM t_forum WHERE forum_id between ? and ?";   
 	// 方法1：使用RowCallbackHandler接口
    final List<Forum> forums = new ArrayList<Forum>();
    jdbcTemplate.query(sql,new Object[]{fromId,toId},new RowCallbackHandler(){ 
        public void processRow(ResultSet rs) throws SQLException {
            Forum forum = new Forum();
            forum.setForumId(rs.getInt("forum_id"));		        
            forum.setForumName(rs.getString("forum_name"));
	    	forum.setForumDesc(rs.getString("forum_desc"));
            forums.add(forum);
        }
    });
    return forums;
}
```

###### 4.3.2.使用RowMapper<T>处理结果集

> <T> List<T> query(String sql,Object[] args,RowMapper<T>  rowMapper)
>
> <T> List<T> query(String sql,Object[] args,int[] argTypes,RowMapper<T>  rowMapper)
>
> <T> List<T> query(String sql,RowMapper<T>  rowMapper)
>
> <T> List<T> query(String sql,PreparedStatementSetter pss,RowMapper<T>  rowMapper)
>
> <T> List<T> query(PreparedStatementCreator psc,RowMapper<T>  rowMapper)

```java
/*
也可以使用RowMapper<T>接口定义结果集映射逻辑。该接口只有一个接口方法：
T mapRow(ResultSet rs, int rowNum)。在结果集为多行记录时，该接口更容易使用。
*/
public List<Forum> getForums(final int fromId, final int toId) {
    String sql = "SELECT forum_id,forum_name,forum_desc FROM t_forum WHERE forum_id between ? and ?";   
    return jdbcTemplate.query(sql, new Object[] { fromId, toId },new RowMapper<Forum>() {
	    public Forum mapRow(ResultSet rs, int index)  throws SQLException {
		    Forum forum = new Forum();
		    forum.setForumId(rs.getInt("forum_id"));
		    forum.setForumName(rs.getString("forum_name"));
		    forum.setForumDesc(rs.getString("forum_desc"));
		    return forum;
	     }
	});
}
```

###### 4.3.3.**查询单值数据**

>1、int类型的单值查询接口
>
>​      	•int queryForInt(String sql)
>
>​		 •int queryForInt(String sql,Object...args)
>
>​		 •int queryForInt(String sql,Object[] args,int[] argTypes)
>
>如果返回空结果集或结果集多于一行，均会抛出异常。

>2、long类型的单值查询接口
>
>​		•long queryForLong(String sql)
>
>​		•long queryForLong(String sql,Object...args)
>
>​		•long queryForLong(String sql,Object[] args,int[] argTypes)
>
>  当返回的整数超过int的值范围时，使用这套接口方法将返回长整型数值。

>3、其它类型的单值查询接口
>
>​		<T> T queryForObject(String sql,Class<T> requiredType)
>
>​		<T> T queryForObject(String sql,Object[] args,Class<T> requiredType)
>
>​		<T> T queryForObject(String sql,Object[] args,int[] argTypes,Class<T> requiredType)
>
>​		<T> T queryForObject(String sql,Object[] args,int[] argTypes,RowMapper<T>  rowMapper)
>
>​		<T> T queryForObject(String sql,Object[] args,RowMapper<T>  rowMapper)
>
>​		<T> T queryForObject(String sql,RowMapper<T>  rowMapper)
>
>在使用Class<T> requiredType参数的方法时，结果集必须仅拥有一行一列，且结果集可以被构造成T类型的对象。如果结果集包括多列，则需要使用带RowMapper<T> rowMapper参数的方法，在**接口方法中手工完成对象构造**。

```java
public double getReplyRate(int userId) {
    String sql = "SELECT topic_replies,topic_views FROM t_topic WHERE user_id=?";
    double rate = jdbcTemplate.queryForObject(sql, new Object[] { userId },
				                                new RowMapper<Double>() {
                public Double mapRow(ResultSet rs, int index)  throws SQLException {
	        int replies = rs.getInt("topic_replies");
	        int views = rs.getInt("topic_views");
	        if (views > 0)
	  	  return new Double((double) replies / views);
	        else
		  return new Double(0.0);
                 }
             });
     return rate;
}

```

##### 4.4.调用存储过程

```java
/*
1.JdbcTemplate提供了两个调用存储过程的接口方法。
	<T> T  excute(String callString,CallableStatementCallback<T> action)
       callString参数指定调用存储过程的SQL语句。格式如下：
           {call  <procedure-name> [<arg1>,<arg2>, ...]}
           通过占位符(?)的索引号绑定入参和注册出参。
           CREATE PROCEDURE P_GET_TOPIC_NUM(IN in_user_id INT,OUT out_num INT)
           BEGIN
              SELECT COUNT(*) INTO out_num  FROM t_topic WHERE user_id = in_user_id;
           END
           {call P_GET_TOPIC_NUM(?,?)}

     	CallableStatementCallback<T> 是一个回调接口，该接口只有一个方法
     		T  doInCallableStatement(CallableStatement cs)，用户可以在该方法中进行输入参数绑定、输出参数注册以及返回数据处理等操作。
     		注意：输出参数的位置索引必须和占位符(?)一致。如果存储过程返回结果集，则可以通过
CallableStatement#getResultSet()方法获取结果集 ，并按传统的方式获取结果集中的数据。
     		*/
public int getUserTopicNum(final int userId) {
	String sql = "{call P_GET_TOPIC_NUM(?,?)}";
   	Integer num = jdbcTemplate.execute(sql,new CallableStatementCallback<Integer>() {
		public Integer doInCallableStatement(CallableStatement cs)
				               throws SQLException, DataAccessException {
			cs.setInt(1, userId);   //绑定入参
			cs.registerOutParameter(2, Types.INTEGER);  //注册输出参数
			cs.execute();
			return cs.getInt(2);  //获取输出参数的值
		}
	});
	return num;
}

    
/*
2. <T> T  excute(CallableStatementCreator csc,CallableStatementCallback<T> action)
       CallableStatementCreator 是一个回调接口，该接口定义了一个方法
CallableStatement  createCallableStatement(Connection conn)  。CallableStatementCreator 负责创建CallableStatement实例、绑定入参、注册输出参数等工作。
       CallableStatementCallback<T>负责处理存储过程的返回结果。
       Spring提供了创建CallableStatementCreator 的工厂类CallableStatementCreatorFactory，通过该工厂类可以简化CallableStatementCreator 的实例创建工作。

 */   
    public int getUserTopicNum(final int userId) {
	String sql = "{call P_GET_TOPIC_NUM(?,?)}";
   	CallableStatementCreatorFactory fac = new CallableStatementCreatorFactory(sql);
	fac.addParameter(new SqlParameter("userId",Types.INTEGER));               //入参
	fac.addParameter(new SqlOutParameter("topicNum",Types.INTEGER));   //出参
	Map<String,Integer> paramsMap = new HashMap<String,Integer>();
	paramsMap.put("userId",userId);
	CallableStatementCreator csc = fac.newCallableStatementCreator (paramsMap);
	Integer num = jdbcTemplate.execute(csc,new CallableStatementCallback<Integer>(){
		public Integer doInCallableStatement(CallableStatement cs)
				throws SQLException, DataAccessException {
			cs.execute();
			return cs.getInt(2);
			}	
     });
	return num;
}

```

##### 4.5.两个易用的JDBC模板类

```java
/*
Spring 还提供了两个易用的JDBC模板类，分别是SimpleJdbcTemplate和NamedParameterJdbcTemplate。前者封装了JdbcTemplate，将常用的API开放出来；后者提供了命名参数绑定的功能。
     1.NamedParameterJdbcTemplate模板类支持命名参数变量的SQL，它位于
org.springframework.jdbc.core.namedparam包中。该包中还定义了一个用于承载命名参数的				        2.SqlParameterSource接口，该接口有两个实现类：
		1.BeanPropertySqlParameterSource该实现类将一个JavaBean对象封装成一个参数源，以便通过JavaBean属性名和SQL语句中命名参数匹配的方式绑定参数。
		2.MapSqlParameterSource该实现类内部有一个Map存储参数，可以通过addValue(String paramName,Object value)或addValue(Map values)方法添加参数，并通过参数键名和SQL语句中命名参数匹配的方式绑定参数。
*/            
public void addForumByNamedParams(final Forum forum) {
    final String sql = "INSERT INTO t_forum(forum_name, forum_desc) 														VALUES(:forumName,:forumDesc)";
	SqlParameterSource sps = new BeanPropertySqlParameterSource(forum);
	namedParameterJdbcTemplate.update(sql, sps);
}

<bean id="namedParamJdbcTemplate" 
                class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
      <constructor-arg ref="dataSource"/>
</bean> 
  
         在SQL语句中声明命名参数的格式是：":paramName"。
         如果数据表记录没有对应的领域对象，则可以直接使用MapSqlParameterSource达到参数绑定的目的。         
public void addForumByNamedParams(final Forum forum) {
       final String sql = "INSERT INTO t_forum(forum_name, forum_desc)VALUES(:forumName,:forumDesc)";
        MapSqlParameterSource sps = new MapSqlParameterSource().
        addVaule("forumName",forum.getForumName()).
        addVaule("forumDesc",forum.getForumDesc())
        namedParameterJdbcTemplate.update(sql, sps);
}



```

##### 4.6.LOB类型数据处理

 LOB代表大对象数据，包括BLOB和CLOB两种类型，前者用于**存储大块的二进制数据**，如图片、视频数据等；而后者用于存储**长文本数据**。在不同的数据库中，大对象对应的字段类型往往并不相同。

MySQL中对应BLOB和LONGTEXT类型。由于有些数据库使用了自己的API操作LOB数据，因此需要从数据源的代理JDBC对象中抽取本地数据库的JDBC对象.LOB数据可以使用**块数据和流数据**的方式进行访问。

>**LobCreator**  : Spring定义了一个独立于java.sql.Blob/Clob接口，以统一的方式操作各种数据库LOB类型数据的LobCreator接口。它不是线程安全的，一个LobCreator 只能操作一个LOB数据。 
>
>接口方法：
>
>1.  void close()  //关闭会话，并释放LOB资源
>2. void setBlobAsBinaryStream(PreparedStatement ps,int paramIndex,InputStream contentStream,int contentLength)  //通过流填充BLOB数据
>3. void setBlobAsBytes(PreparedStatement ps,int paramIndex,byte[] content)  //通过二进制数据填充BLOB数据
>4. void setClobAsAsciiStream(PreparedStatement ps,int paramIndex,InputStream  asciiStream,int contentLength)  //通过ASCII字符流填充CLOB数据
>5. void setClobAsCharacterStream(PreparedStatement ps,int paramIndex,Reader characterStream,int contentLength)  //通过Unicode字符流填充CLOB数据
>6. void setClobAsStream(PreparedStatement ps,int paramIndex,String content)  //通过字符串填充CLOB数据



>LobHandler : LobHandler 接口为操作大二进制字段和大文本字段提供了统一访问接口。 此外LobHandler 还充当LobCreator 的工厂类。Oracle必须使用OracleLobHandler 实现类，其它数据库使用DefaultLobHandler就可以了。Oracle 10g也可以使用DefaultLobHandler。
>
>接口方法：
>
>1. LobCreator getLobCreator ()  //生成一个会话相关的LobCreator 对象
>2. InputStream getBlobAsBinaryStream(ResultSet rs,int columnIndex)     //从结果集中返回 InputStream，通过InputStream读取BLOB数据
>3. byte[] getBlobAsBytes(ResultSet rs,int columnIndex)  //以二进制数据的方式获取结果集中的 BLOB数据
>4. InputStream getClobAsAsciiStream(ResultSet rs,int columnIndex)  //从结果集中返回 InputStream，通过InputStream以ASCII字符流的方式读取CLOB数据
>5. Reader getClobAsCharacterStream(ResultSet rs,int columnIndex)  //从结果集中获取Unicode字符流Reader ，通过Reader 以Unicode字符流的方式读取CLOB数据
>6. String getClobAsStream(ResultSet rs,int columnIndex)  //从结果集中以字符串的方式获取  CLOB数据

###### 4.6.1.插入LOB

```xml
<bean id="lobHandler" lazy-init="true"
            class="org.springframework.jdbc.support.lob.DefaultLobHandler" />
```

```java
@Autowired
private LobHandler lobHandler;

public void addPost(final Post post){
	String sql = " INSERT INTO t_post(post_id,user_id,post_text,post_attach) VALUES(?,?,?,?)"    
    jdbcTemplate.execute(sql,new AbstractLobCreatingPreparedStatementCallback(this.lobHandler){
         protected void setValues(PreparedStatement ps,LobCreator lobCreator)
                  throws SQLException {	    	  
               ps.setInt(1, incre.nextIntValue());  //通过自增键指定主键值   
               ps.setInt(2, post.getUserId());	
               lobCreator.setClobAsString(ps, 3, post.getPostText());
               lobCreator.setBlobAsBytes(ps, 4, post.getPostAttach());
           }
    });
}

```

###### 4.6.2.读取LOB

```java
public List<Post> getAttachs(final int userId) {
    String sql = " SELECT post_id,post_attach FROM t_post where user_id =? and post_attach is not null ";
    return jdbcTemplate.query(sql, new Object[] { userId },new RowMapper<Post>() {
		public Post  mapRow(ResultSet rs, int rowNum)	throws SQLException {
	        int postId = rs.getInt(1);
	        byte[] attach = lobHandler.getBlobAsBytes(rs, 2);
	        Post post = new Post();
	        post.setPostId(postId);
	        post.setPostAttach(attach);
	        return post;
	}
           });
}


public void getAttach(final int postId, final OutputStream os) {
     String sql = "SELECT post_attach FROM t_post WHERE post_id=? ";
     jdbcTemplate.query(sql, new Object[] {postId},
			                    new AbstractLobStreamingResultSetExtractor() {	
         protected void handleNoRowFound() throws LobRetrievalFailureException {
			System.out.println("Not Found result!");
		}
         public void streamData(ResultSet rs) throws SQLException,IOException {
	        InputStream  is = lobHandler.getBlobAsBinaryStream(rs, 1);
	       	if (is != null) {
            	FileCopyUtils.copy(is, os);
	        }
		 }
    });
}
```



#### 5、Junit配合Spring-test

```xml
<properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <spring.version>5.2.9.RELEASE</spring.version>
</properties>
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.13.2</version>
    <!-- 作用范围:test 代表只在test包中生效	-->
    <scope>test</scope>
</dependency>

<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>${spring.version}</version>
</dependency>

```

```java
/**
*@RunWith:由Junit提供的,里面必须给一个Runner的值,告诉Junit以什么样的环境来运行测试用例
*SpringJUnit4ClassRunner.class(Runner一个子类) 由Spring-test提供的,为Junit提供Spring环境加载的条件
*@ContextConfiguration 由Spring-test提供,用来指定配置文件或者配置类的地址,以便于初始化IOC容器
*@WebAppConfiguration 以web环境运行
*/
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext.xml") 
@WebAppConfiguration
public class TestDaoTest {

    @Autowired
    private TestDao testDao;

    @Test
    public void findById() { 
        testDao.findById(1);
    }
}
```

#### 6、Spring的事务管理

##### 6.1.编程式事务

>手写事务创建,提交,回滚的代码

```xml
<!--开启包扫描和注解开发-->
    <context:component-scan base-package="pers.lintao"/>

    <!--配置事务源-->
    <bean id="dataScourse" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/vip2109?useSSL=false&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true"/>
        <property name="username" value="root"/>
        <property name="password" value="root"/>
    </bean>
    <!--jdbc模板-->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataScourse"/>
    </bean>
    <!--事务管理器-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataScourse"/>
    </bean>
```

```java
@Service
public class TestService {

    @Autowired
    private TestDao testDao;

    //注入事务管理器
    @Autowired
    private DataSourceTransactionManager transactionManager;

    public void batchInsert(){ 
        Test test;
        //创建一个默认的事务对象
        DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
        //开启事务
        TransactionStatus status = transactionManager.getTransaction(transactionDefinition);
        try {
            for (int i = 1; i < 11; i++) {
                //	if (i == 6) {
                //	throw new RuntimeException("无中生有的异常");
                //	}
                test = new Test(); 
                test.setId(i); 
                test.setName("木子" + i); 
                testDao.insertTest(test);
            }
        	//提交事务
            transactionManager.commit(status);
        } catch (Exception e) {
        	//回滚事务
            transactionManager.rollback(status);
            throw e;
        }
    }
}

```

##### 6.2.声明式事务

>声明式事务是SpringAOP的一个典型实现,其实就是用到了环绕通知

```xml
<!-- 声明式事务是基于AOP的,AOP又是基于aspectJ的,所以这个依赖不能少 -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.6</version>
</dependency>

```

```xml
<!-- 基于数据源的事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"/>
</bean>
<!-- 声明式事务配置;要配合aop使用 -->
<tx:advice id="txAdvisor" transaction-manager="transactionManager">
    <tx:attributes>
        <!-- 需要加事务管理的方法 -->
        <tx:method name="batchInsert*"/>
        <tx:method name="insert*"/>
        <tx:method name="update*"/>
        <tx:method name="delete*"/>
        <tx:method name="query*" propagation="NEVER" read-only="true"/>
        <tx:method name="select*" propagation="NEVER" read-only="true"/>
    </tx:attributes>
</tx:advice>
<aop:config>
    <aop:pointcut id="PC" expression="execution(* com.softeem..*Service.*(..))"/>
    <aop:advisor advice-ref="txAdvisor" pointcut-ref="PC"/>
</aop:config>

```

```java
// 1. 前置通知
// 2.目标方法执行
public void batchInsert2() {
    try {
        Test test;
        for (int i = 1; i < 11; i++) { 
            if (i == 6) {
        		throw new RuntimeException("无中生有的异常");
        	}
            test = new Test(); 
            test.setId(i); 
            test.setName("木子" + i); 
            testDao.insertTest(test);
    	}
    } catch (Exception e) {
        System.out.println("捕获到异常了");
    	//一定要抛出异常,不然事务管理器捕获不到异常,
    	// 会认为目标方法正常执行,只会提交事务,产生脏数据,而不会回滚事务
    	throw new ServiceException("batchInsert2抛出异常了,异常信息为:"+e.getMessage());
    }
    }
    //3.后置通知/异常通知
}

```

##### 6.3.声明式事务+注解

```xml
<!-- 基于数据源的事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
	<property name="dataSource" ref="dataSource"/>
</bean>

<!-- 开启注解式声明式事务配置 -->
<tx:annotation-driven transaction-manager="transactionManager"/>

```

```java
@Service 
@Transactional
public class TestService {
    
}
```

>@Transactional可以用在方法上,代表给某个方法加上声明式事务,可以指定一些元配置信息,比如
>
>propagation , isolation , timeout 和 readOnly
>
>@Transactional也可以用在类上,代表给该类下所有的方法加入声明式事务 如果方法和类上都有该注解,遵循 就近原则 ,以方法上的注解配置为准

### 4、Sprin-MVC(自学webflux)

#### 1、Spring MVC介绍及作用

>**Spring Web MVC** is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning.`( Spring Web MVC 是建立在Servlet API之上的WEB框架 )` The formal name, “Spring Web MVC,” comes from the name of its source module ( spring**-** webmvc ), but it is more commonly known as “Spring MVC”.`( 正式的名字是Spring Web MVC)来源于spring-webmvc模块 ,但是通常被称为SpringMVC)`,`自学Spring-webflux,很重要`

>**Spring MVC**是**Spring**提供的一款基于**MVC**架构模式的**轻量级Web框架**，其目的是将**Web**开发模块化，对整体架构进行解耦，简化**Web**开发流程**。**Spring MVC基于请求驱动，即使用**请求 — 响应**模型。由于**Spring MVC**遵循**MVC**架构规范，因此分层开发数据模型（**Model**）、响应视图层（**View**）和控制层（**Controller**），可以让开发者设计出结构规整的**Web层**

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\MVC模型.png)

>### Spring MVC的作用:
>
>1.SpringMVC提供了一个 **`DispatcherServlet`** 作为前端控制器来分发请求
>
>2.SpringMVC各个组件分工明确,比如提供了`控制器`,`验证器`,`命令对象`,`模型对象`等等,每个功能的实现由一个 专门的组件负责完成
>
>3.SpringMVC对用户的输入做一个`数据自动的绑定`,还能够正确的转换数据类型
>
>4.SpringMVC内置了常见的`校验器`,可以校验用户的输入
>
>5.SpringMVC中有一个叫`视图解析器`的组件,默认的视图解析器对JSP有很好的支持,如果需要对别的模板文  件进行解析,则需要引入额外依赖

#### 2、Spring MVC处理请求流程及重要组件

>SpringMVC**执行流程**:
>
>1. 用户发送请求至**前端控制器DispatcherServlet**
>2. DispatcherServlet收到请求调用**处理器映射器HandlerMapping**。
>3. 处理器映射器根据请求uri找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。
>4. DispatcherServlet根据处理器Handler获取**处理器适配器HandlerAdapter**执行HandlerAdapter处理一系列的操作，如:参数封装,数据格式转换,数据验证等操作
>5. 执行处理器Handler(Controller,也叫倾面控制器)。
>6. Handler执行完成返回ModelAndView
>7. HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet
>8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器
>9. ViewReslover解析后返回具体View
>10. DispatcherServlet对View进行渲染视图(即将模型数据model填充至视图中)。
>11. DispatcherServlet响应用户。

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\springmvc处理请求的流程.jpg)

##### 3.1.重要组件:从DispatcherServlet开始

```java
//在DispatcherServlet源码中涉及到了初始化其他SpringMVC重要组件的过程
protected void initStrategies(ApplicationContext context) {
    //初始化上传文件相关的解析器
    initMultipartResolver(context);
    //初始化本地化解析器
    initLocaleResolver(context);
    //初始化主题解析器
    initThemeResolver(context);
    //初始化处理器映射器
    initHandlerMappings(context);
    //初始化处理器适配器
    initHandlerAdapters(context);
    //初始化异常处理器
    initHandlerExceptionResolvers(context);
    //初始化请求到视图名字的解析器
    initRequestToViewNameTranslator(context);
    //初始化视图解析器
    initViewResolvers(context);
    //初始化flash映射的解析器
    initFlashMapManager(context);
}
```

##### 3.2.DispatcherServlet.properties文件

```properties
key:组件的接口名	value:组件的实现类

//本地化国际化解析器org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.Ac ceptHeaderLocaleResolver

//主题解析器
org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.Fi xedThemeResolver

//处理器映射器
org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler
.BeanNameUrlHandlerMapping,\org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\ org.springframework.web.servlet.function.support.RouterFunctionMapping

//处理器适配器
org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.Htt pRequestHandlerAdapter,\org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\ org.springframework.web.servlet.function.support.HandlerFunctionAdapter

//异常处理器
org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servl et.mvc.method.annotation.ExceptionHandlerExceptionResolver,\org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

//视图名称解析器
org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.se rvlet.view.DefaultRequestToViewNameTranslator

//视图解析器
org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.Inte rnalResourceViewResolver

//flashMap映射解析器
org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.suppor t.SessionFlashMapManager
```

##### 3.3.重要组件及其作用

| **组件名**        | **说明**                                                     |
| :---------------- | ------------------------------------------------------------ |
| DispatcherServlet | SpringMVC的入口,作用就是对请求分流,底层就是 Servlet          |
| HandlerMapping    | 检查请求是否合法(有没有对应的Handler去处理该请求),<br /> 有就返回执行链  ( HandlerExecutionChain )对象 |
| HandlerAdapter    | 根据适配器设计模式去匹配接口                                 |
| Handler           | 具体处理请求的组件,其中控制器是最简单的Handler,还包括拦截器  |
| ViewResolver      | 将数据和指定的模板引擎结合起来渲染成静态页面                 |

#### 3、创建Spring MVC项目

>前提:因为我们使用的是Spring5.X的版本,所以对环境有以下的要求:
>
>\1.   JDK最低为JDK8+
>
>\2.   J2EE7:Servlet3.1+,Tomcat8.5+

```xml
<!-- spring-webmvc:会自动引入其他Spring的依赖 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.2.9.RELEASE</version>
</dependency>
```

##### 4.1.为一个普通maven项目新建一个web门面

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Maven项目加web门面.png)

##### 4.2.为项目打包一定要将项目必要的依赖也加入打包设置中交给tomacat

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Springmvc项目打包依赖导出.jpg)

##### 4.3.在web.xml文件中配置DispatcherServlet

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" 										          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 									 xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0">
    <servlet>
        <servlet-name>spring-mvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-
        class>
        <init-param>
            <!--	初始化参数:指定SpringIOC容器配置文件的位置	-->
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
        <!-- 在web容器启动的时候创建并初始化DispatcherServlet的优先级 -->
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>spring-mvc</servlet-name>
        <!-- /代表所有请求 -->
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

##### 4.4.配置Spring的文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- 包扫描,能扫描指定包下@Controller,@Service,@Repository,@Component -->
    <context:component-scan base-package="com.softeem"/>
    <!-- 开启SpringMVC注解开发模式,依赖于Spring包扫描 -->
    <mvc:annotation-driven />
    <!-- 让DispatcherServlet对静态资源进行放行	-->
    <mvc:default-servlet-handler/>
</beans>

```

#### 4、请求相关的注解

```xml
<!-- 包扫描,能扫描指定包下@Controller,@Service,@Repository,@Component -->
<context:component-scan base-package="com.softeem"/>
<!-- 开启SpringMVC注解开发模式,依赖于Spring包扫描
相当于指定了两个SpringMVC组件的具体实现:HandMapping==> RequestMappingHandlerMapping HandlerAdapter==> RequestMappingHandlerAdapter -->
<mvc:annotation-driven />
<!-- 让DispatcherServlet对静态资源进行放行	-->
<mvc:default-servlet-handler/>
```

##### 4.1.路径请求的注解

>### @RequestMapping,元属性:
>
>1. name:给映射路径指定一个别名**(用的很少)**
>
>2. `value/path`:用于将指定的实际路径映射到方法或者类上面
>
>3. `method`:指定请求的方法类型(如GET,POST等),如果不配置,默认支持所有HTTP方法
>
>4. params:指定请求中必须包含哪些参数,才能让请求进入类或者方法
>
>5. headers:指定请求头里面必须包含哪些参数,才能让请求进入类或者方法
>
>6. cosumes:指定请求里面的内容的类型`(cont-type)`,比如表单常用的 application/x-www-form-
>
>  urlencoded
>
>7. produces:指定返回的内容的类型,返回内容的信息必须在请求头Accept包含的类型中
>
>##### 注意:在此之上呢,SpringMVC对 RequestMapping 注解进行了几个简单封装,比如GetMapping("xxx)==>@RequestMapping("xxx",RequestMethod.GET)
>
>但是RequestMapping 可以放在类上也可以放在方法上,其他GetMapping,RequestMapping只能方法方法上

```java
//@RequestMapping("/first")
@Controller
public class FirstController {	
    /**
    *	@RequestMapping("/path"):代表路径映射,可以该注解可以放在类或者方法上
    *	@return
    */ 
    @RequestMapping(value="/fr",method=RequestMethod.GET)
    public String firstRequest(){ 
        System.err.println("Hello Request"); 
        return "123";
    }
}
```

##### 4.2.参数绑定的注解

>1. @RequstParam :用以接收是来自`formdata`或`url`的QueryString的参数; 
>2. @PathVarible :主要用在Restful开发风格中,能够处理URI中的数据
>3. @RequestBody :用来接收`请求体(body)`中的数据。一般用于处理比如：`application/json`、`application/xml`等类型的数据;特别的,Get请求是没有请求体的,所以使用这个注解不能放在Get请求中
>3. 总结 •在GET请求中，不能使用@RequestBody。 在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化的配置必须统一。

###### 4.2.1@RequestParam

```java
/**
*	@RequestParam三个明显的作用:
*		①请求中的参数和方法中的参数绑定(name)
* 		②要求被修饰的参数是否必传(required)默认为true
*		③如果请求中没有传该参数,可以给一个默认值(defaultValue)
*	@param username
*	@param age
*	@return
*/ 
@GetMapping("/getData2")
@ResponseBody //代表直接响应文本,不输出页面
public String getData2(@RequestParam(name = "user_name",defaultValue = "匿名") String username, int age){
	System.out.println(username + "==>" + age); 
    return "index3";
}
```

###### 4.2.2@PathVariable

```java
///getData3/111 ==>myage=111 
@GetMapping("/getData3/{myage}") 
@ResponseBody //代表直接响应文本,不输出页面
public String getData3(@PathVariable("myage") int age){ 
    //将路径上的占位符myage绑定到age上
    System.out.println(age);
	return "index4";
}
```

###### 4.2.3@RequestBody

>@requestBody注解常用来处理content-type比如：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。**@RequestBody接受的是一个json格式的字符串，一定是一个字符串。**
>
>        1.@RequestBody接受的是一个json格式的字符串，一定是一个json对象字符串。
>        
>        2.在使用springmvc的做项目时,将JSON字符串和JSON对象混淆了。
>    
>        3.@RequestParam接受单个参数，参数位置位于链接后。@RequestBody接受JSON对象字符串，参数位置位于

```java
/**
*	在GET请求的方法参数前加了@RequestBody反而报错
*	原因是因为@RequestBody是帮助SpringMVC去解析请求体中的数据的,
*	而GET请求没有请求体
*/ 
@GetMapping("/getData4")
@ResponseBody //代表直接响应文本,不输出页面
public String getData4(Student student){
    //spring mvc会自动将类型转换,自己封装成一个student对象,属性名一致
    System.out.println(student);
	return "index3";
}
```

##### 4.3.接收各种类型的参数

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>SOFTEEM</title>
    </head>
    <body>
        <h1>你喜欢的高质量女性是谁?</h1>
        <form action="/second/getComplexData3" method="post">
            <h3>你的名字是什么/</h3>
            <input name="username"/><br>
            <h3>你中意的女性是谁?</h3>
            <select name="lady">//下拉框
                <option value="Yoona">林允儿</option>
                <option value="Jessica">郑秀妍</option>
                <option value="Actress">天海翼</option>
                <option value="nicola">新垣结衣</option>
                <option value="java">Java</option>
            </select>
            <div>
                <h3>你喜欢她的原因是什么?</h3>//多选框
                <input type="checkbox" name="reason" value="1">长相甜美
                <input type="checkbox" name="reason" value="2">为了学习
                <input type="checkbox" name="reason" value="3">演技精湛
                <input type="checkbox" name="reason" value="4">其他
            </div>
            <button type="submit">点我!</button>
        </form>
    </body>
</html>

```

###### 4.3.1.接收普通单一属性

>方法参数名会根据前端参数名自动匹配(要求前后名字一致,也可以用`@RequestParam`给方法参数绑定前端名字不一致的参数名)

```java
@PostMapping("/getComplexData") 
@ResponseBody
public String test1(String username,String lady){ 
    return "Success";
}
```

###### 4.3.2.接收列表

>### 通过数组接收(原生支持)

```java
@PostMapping("/getComplexData") 
@ResponseBody
public String test1(String username,String lady,Integer[] reason){ 
    return "Success";
}

```

>## 通过集合接收(注意加@RequestParam)

```java
@PostMapping("/getComplexData2") @ResponseBody
public String test2(String username, String lady, @RequestParam List<Integer> reason){
return "Success";
}
```

>### 通过包装类接收(最简单,springmvc会自动转换)

```java
@PostMapping("/getComplexData3") 
@ResponseBody
public String test3(Student2 student2){ 
    return "Success";
}

public class Student2 {
	private String username;
    private String lady;
	//private Integer[] reason; 两者都可以,且List集合前不用加@RequestParam
    private List<Integer> reason;
	...
}
```

###### 4.3.3.接收组合对象

>一个类的属性中有其他类的实例,前端在给该参数命名时要加上对象名;如下:

```html
<h3>填写调查问卷有奖励,输入收货地址即可领取</h3>
<div>
    <h4>收货地址</h4> <input name="emsInfo.address">
    <h4>联系方式</h4> <input name="emsInfo.telephone">
</div>
```

```java
@PostMapping("/getComplexData3")
@ResponseBody
public String test3(Student2 student2){ 
    return "Success";
}

public class Student2 {
	private String username; 
    private String lady; 
    private List<Integer> reason;
    /**
    * 快递信息
    */
    public EMSInfo emsInfo;
...
}
public class EMSInfo { 
    private String address; 
    private String telephone;
	...
}
```

#### 5、响应及数据模型

##### 5.1.@ResposeBody

>1. 直接响应数据,不涉及到视图
>2. 可以是标准字符串和结构化数据(xml/`json`)
>3. 会被`StringHttpMessageConverter`影响(处理响应乱码就是对它进行配置)

##### 5.2.数据模型

>Servlet的3个作用域
>
>1. 请求作用域:HttpServletRequest
>2. 会话作用域:HttpSession
>3. 应用程序作用域:ServletContex
>
>SpringMVC提供的几个数据模型:
>
>1.  Model
>2. ModelMap
>3. ModelAndView

###### 5.2.1.请求作用域

>默认工况下,这三个数据模型组件保留的数据都是**请求作用域** 级别;
>
>可以使用**@SessionAttributes**加在类上提升到Session级别

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
        <title>Title</title>
    </head>
    <body>
    	获取后端的数据:${student.username}
    </body>
</html>
```

```java
@Controller
@RequestMapping("/third")
public class ThirdController {
    /**
    * 使用Model
    * @param username
    * @param model
    * @return
    */
    @GetMapping("/test1")
    public String test1(String username,Model model) {
        System.out.println("接收到的参数为:"+username);
        Student student = new Student();
        student.setUsername("木子好帅啊~");
        model.addAttribute("student", student);
        return "/third.jsp";
    }
    /**
    * 使用ModelMap
    * @param username
    * @param modelMap
    * @return
    */
    @GetMapping("/test2")
    public String test2(String username, ModelMap modelMap) {
        System.out.println("接收到的参数为:"+username);
        Student student = new Student();
        student.setUsername(username);
        modelMap.addAttribute("student", student);
        return "/third.jsp";
    }
    /**
    * 使用ModelAndView
    * @param username
    * @return
    */
    @GetMapping("/test3")
    public ModelAndView test3(String username) {
        System.out.println("接收到的参数为:"+username);
        ModelAndView modelAndView = new ModelAndView("/third.jsp");
        // modelAndView.setViewName("/third.jsp");
        Student student = new Student();
        student.setUsername(username);
        modelAndView.addObject("student", student);
        return modelAndView;
    }
}
```

###### 5.2.2.Session作用域

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
<title>Title</title>
</head>
<body>
请求作用域获取后端的数据:${requestScope.student1.username} <br>
Session作用域获取后端的数据:${sessionScope.student1.username}<br>
请求作用域获取后端的数据:${requestScope.student2.username} <br>
Session作用域获取后端的数据:${sessionScope.student2.username}<br>
请求作用域获取后端的数据:${requestScope.student3.username} <br>
Session作用域获取后端的数据:${sessionScope.student3.username}
</body>
</html>
```

```java
/**
* @author muzi@softeem.com
* @description 使用SpringMVC数据模型
* @since 2021/9/9 20:41
*/
@Controller
@RequestMapping("/third")
//@SessionAttributes里面的值必须和
//model.addAttribute("student", student);
//modelMap.addAttribute("student", student);
//modelAndView.addObject("student", student);
//里面的key保持一致
@SessionAttributes({"student1","student2","student3"})
public class ThirdController {
    /**
    * 使用Model
    * @param username
    * @param model
    * @return
    */
    @GetMapping("/test1")
    public String test1(String username,Model model) {
        System.out.println("接收到的参数为:"+username);
        Student student = new Student();
        student.setUsername("木子好帅啊~");
        model.addAttribute("student1", student);
        return "/third.jsp";
    }
    /**
    * 使用ModelMap
    * @param username
    * @param modelMap
    * @return
    */
    @GetMapping("/test2")
    public String test2(String username, ModelMap modelMap) {
        System.out.println("接收到的参数为:"+username);
        Student student = new Student();
        student.setUsername(username);
        modelMap.addAttribute("student2", student);
        return "/third.jsp";
    }
    /**
    * 使用ModelAndView
    * @param username
    * @return
    */
    @GetMapping("/test3")
    public ModelAndView test3(String username) {
        System.out.println("接收到的参数为:"+username);
        ModelAndView modelAndView = new ModelAndView("/third.jsp");
        // modelAndView.setViewName("/third.jsp");
        Student student = new Student();
        student.setUsername(username);
        modelAndView.addObject("student3", student);
        return modelAndView;
    }
}
```

#### 6、各种乱码问题

##### 6.1.请求乱码

###### 6.1.1.GET请求乱码问题

>如果你的Tomcat版本8.0以上的版本,那么基本不会出现GET请求乱码在Tomcat安装目录 conf 目录下的 server.xml 中,加上

```xml
<Connector port="8080" protocol="HTTP/1.1"
 URIEncoding="UTF-8" connectionTimeout="20000" redirectPort="8443" />
```

###### 6.1.2.POST请求乱码

>解决POST中文乱码的核心就是加`过滤器(Filter)`

```xml
<!-- 解决POST请求中文乱码问题 -->
<filter>
    <filter-name>characterEncoding</filter-name>
    <filter- class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>characterEncoding</filter-name>
    <!-- /*代表拦截所有请求	-->
    <!-- /只能匹配到不到后缀的url,例如:http://localhost:8080/second/getComplexData3 -->
    <!-- /*任何请求都可以拦截	-->
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

##### 6.2.响应乱码

```java
@PostMapping("/getComplexData3")
@ResponseBody //受StringHttpMessageConverter影响
public String test3(Student2 student2){
	System.out.println(student2); 
    return "软帝云课堂";
}
```

```xml
<!--配合mvc的注解开发驱动配置-->
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="supportedMediaTypes">
                <list>
                	<value>text/html;charset=utf-8</value>
                    <value>application/json;charset=utf-8</value>
                </list>
            </property>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```

```xml
<!--单独配置handlerAdapater-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMapping HandlerAdapter">
    <property name="messageConverters">
    <list>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="supportedMediaTypes">
                <list>
                	<value>text/html;charset=utf-8</value>
                    <value>application/json;charset=utf-8</value>
                </list>
            </property>
        </bean>
    </list>
    </property>
</bean>
```

#### 7、SpringMVC整合模板引擎

##### 7.1.对JSP进行整合优化

```xml
<bean id="viewResolver"
class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <!-- 配置视图的前缀 :一般是视图所在的公共目录 -->
    <property name="prefix" value="/ui/" />
    <!-- 配置视图的后缀:一般是模板的格式 -->
    <property name="suffix" value=".jsp" />
    <!-- 配置content-type,避免中文乱码 -->
    <property name="contentType" value="text/html;charset=UTF-8"/>
</bean>
```

##### 7.2.整合FreeMarker

```xml
<!-- Freemarker -->
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.28</version>
</dependency>
<!-- spring-context-support不仅能够帮助Spring整合其他的模板引擎
,还有其他很多作用,比如在整合缓存工具包的时候也需要-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-support</artifactId>
    <version>5.2.9.RELEASE</version>
</dependency>
```

```xml
<bean id="viewResolver"
class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
    <!-- 配置视图的前缀 :一般是视图所在的公共目录 -->
    <!-- <property name="prefix" value="/ui/" />-->
    <!-- 配置视图的后缀:一般是模板的格式 -->
    <property name="suffix" value=".ftl" />
    <!-- 配置content-type,避免中文乱码 -->
    <property name="contentType" value="text/html;charset=UTF-8"/>
</bean>
<bean id="freeMarkerConfigurer"
    class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
    <property name="templateLoaderPath" value="/WEB-INF/ftl/" />
    <property name="freemarkerSettings">
        <props>
        	<prop key="defaultEncoding">UTF-8</prop>
        </props>
    </property>
</bean>
```

```java
/**
* @author muzi@softeem.com
* @description 检测Freemarker是否整合成功
* @since 2021/9/9 22:11
*/
@Controller
@RequestMapping("fourth")
public class FourthController {
    @GetMapping("test1")
    public String test1(){
    	// /WEB-INF/ftl/demo.ftl
    	return "demo";
    }
}
```

#### 8、Restful开发风格

##### 8.1.Rest

>Rest(REpresentional State Transfer) 直译的意思为:表现层状态转换,
>
>意思就是说一切资源都通过URL来识别和定位; 对资源的CRUD是通过HTTP的方法来定义的

##### 8.2.Restful

>基于Rest的理念的一种开发风格,最典型的例子就是 前后端分离 
>
>1.  使用URL来定位用户的入口 
>2. HTTP的方法要明确 (GET,POST,PUT,PATCH,DELETE) 
>3. 只返回数据(一般都是结构化数据XML,JSON):因为JSON天然被JS支持,而且比XML更加的轻量,所以现在JSON是主流

| URI                 | 说明                |
| ------------------- | ------------------- |
| GET/courses(课程)   | 查询所有课程        |
| GET/courses/1       | 查询id为1的课程信息 |
| POST/courses        | 新增课程            |
| PUT/PARCH/courses/1 | 修改id为1的课程信息 |
| DELETE/courses/1    | 删除id为1的课程信息 |

```java
//@RestController相当于@Controller和@ResponseBody
@RestController
public class RestfulController {
    // @ResponseBody
    @GetMapping("/request/{id}")
    public String getRequest(@PathVariable Integer id){
    	return "{\"state\": \"成功\"}";
    }
    
    // @ResponseBody
    @GetMapping("/request")
    public String getRequest(){
    	return "{\"state\": \"get成功\"}";
    }
    
    // @ResponseBody
    @PostMapping("/request")
    public String postRequest(){
    	return "{\"state\": \"post成功\"}";
    }
    
    // @ResponseBody
    @PutMapping("/request")
    public String putRequest(){
   		return "{\"state\": \"put成功\"}";
    }
    
    @ResponseBody
    @DeleteMapping("/request")
    public String deleteRequest(){
    	return "{\"state\": \"delete成功\"}";
    }
}
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <script src="/jquery.min.js"></script>
        <script>
            $(function () {
                $('#do-get').click(function () {
                    $.ajax({
                        url:"/request/11",
                        type:"get",
                        //前端希望后端返回的数据类型
                        dataType:"json",
                        success:function (data) {
                            console.log(data)
                            $('#restful-response').text(data.state)
                        }
                    })
                });
            $('#do-post').click(function () {
                $.ajax({
                    url:"/request",
                    type:"post",
                    //前端希望后端返回的数据类型
                    dataType:"json",
                    success:function (data) {
                        console.log(data)
                        $('#restful-response').text(data.state)
                    }
                })
            });
            $('#do-put').click(function () {
                $.ajax({
                    url:"/request",
                    type:"put",
                    //前端希望后端返回的数据类型
                    dataType:"json",
                    success:function (data) {
                        console.log(data)
                        $('#restful-response').text(data.state)
                    }
                })
            });
            $('#do-delete').click(function () {
                $.ajax({
                    url:"/request",
                    type:"delete",
                    //前端希望后端返回的数据类型
                    dataType:"json",
                    success:function (data) {
                        console.log(data)
                        $('#restful-response').text(data.state)
                    }
                })
            });
            })
        </script>
    </head>
    <body>
        <input type="button" id="do-get" value="Get点击">
        <input type="button" id="do-post" value="Post点击">
        <input type="button" id="do-put" value="Put点击">
        <input type="button" id="do-delete" value="Delete点击">
        <p id="restful-response"></p>
    </body>
</html>
```

##### 8.3. 简单请求和非简单请求

>如果让页面发送PUT/DELETE请求带数据的话,SpringMVC的接口获取不到数据

```js
$('#do-put').click(function () {
    $.ajax({
        url:"/request",
        type:"put",
        //前端希望后端返回的数据类型
        dataType:"json",
        //传的数据
        data:"name=木子&age=18",
        success:function (data) {
            console.log(data)
            $('#restful-response').text(data.state)
        }
    })
});
```

>但是GET/POST能够拿到数据 这是因为SpringMVC设计之初是为了解决表单数据的解析,而表单提交只支持GET/POST
>
>因为Restful开发风格的流行,以及客户端的多种多样(不仅仅是只有浏览器),SpringMVC加入了过滤器来解 决这个问题 
>
>老版本中可以使用 HiddenHttpMethodFilter 
>
>从Spring5.1开始,可以使用 FormContentFilter 来解决

```xml
<!-- 表单过滤器 ,让SpringMVC支持对非简单请求中的参数进行解析 -->
<filter>
    <filter-name>formContentFilter</filter-name>
    <filter-class>org.springframework.web.filter.FormContentFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>formContentFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

>1. 简单请求是标准结构的HTTP请求 
>2. 非简单请求是复杂的请求,其实是对简单请求的一种扩展,比如PUT/DELETE 
>3. 非简单请求在正式调用接口之前会调用一次 `预检请求`

#### 9、SpringMVC处理时间格式的数据

```xml
<!--前提是引入JSON序列化工具JACKSON -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.3</version>
</dependency>
```

##### 9.1.请求中带时间格式参数

默认情况下如果时间格式满足` yyyy/MM/dd HH:mm:ss `格式,SpringMVC能够自动转换成Date类型,但是其 他格式日期,就会直接报错 

###### 9.1.1局部解决

SpringMVC提供了一个注解` @DateTimeFormat `,可以帮助我们`局部解决`请求中日期格式的转换问题,元属性 pattern值遵循SimpleDateFormat的风格,以下是两种情况:

```java
//第一种:直接传
	@PostMapping("/request")
    public String postRequest(Student student,@DateTimeFormat(pattern = "yyyy-MM-dd")
    Date birthday){
        System.out.println("POST请求接收的数据为***********"+student);
        System.out.println(birthday);
        return "{\"state\": \"post成功\"}";
    }
//第二种:类的类型中
    public class Student {
        private String name;
        private Integer age;
        @DateTimeFormat(pattern = "yyyy-MM-dd")
        private Date birthday;
        ...
    }
```

###### 9.1.2.全局解决

>目标: 全局将请求中的字符串转换成Date类型
>
>分析:数据转换和 HandlerAdapter ,默认的消息转换器只支持将String类型中以 / 分隔的日期格式转换成Date类型,所以我们要自定义转换器,并交给 HandlerAdapter 去执行,中间涉及到了另外一个类,它是来管理自定义转换器的,叫FormattingConversionServiceFactoryBean ,它有一个Set类型集合的属性converters ,用来管理自定义转换器.
>
>所以我们应该做的就是,自定义消息转换器( 自定义一个类去实现Converter接口 ),将自定义转换器交给 FormattingConversionServiceFactoryBean ,然后将FormattingConversionServiceFactoryBean 交 给 handlerAdapter

```java
public class MyConverter implements Converter<String, Date> { 
    @Override
    public Date convert(String source) {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); 
        Date date = null;
        try {
        	date = simpleDateFormat.parse(source);
        } catch (ParseException e) { 
            e.printStackTrace(); 
            return null;
        }
        return date;
    }
}
```

```xml
<bean id="conversionService1" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"
>
    <property name="converters">
        <set>
        	<bean class="com.softeem.converter.MyConverter"/>
        </set>
    </property>
</bean>
<mvc:annotation-driven conversion-service="conversionService1">
```

##### 9.2.响应指定时间格式的参数

pre:借助序列化工具

```xml
<!--	JACKSON	-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.3</version>
</dependency>
```

###### 9.2.1局部解决

>其实引入了` Jackson `之后,`SpringMVC`在响应对象的时候,默认情况会用到`Jackson`帮助我们`序列化成Json数据`.
>
>在用到 @JsonFormat 注解的时候,一定要`加上时区`,因为这个注解是Jackson提供的

```java
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss",timezone = "GMT+8") 
private Date birthday;
```

###### 9.2.2全局解决

```xml
<mvc:annotation-driven conversion-service="conversionService">
	<mvc:message-converters>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="supportedMediaTypes">
                <list>
                    <value>text/html;charset=utf-8</value>
                    <value>application/json;charset=utf-8</value>
                </list>
            </property>
        </bean>
        <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
            <property name="objectMapper">
                <bean class="com.fasterxml.jackson.databind.ObjectMapper">
                    <property name="dateFormat">
                        <bean class="java.text.SimpleDateFormat">
<!--	<constructor-arg name="pattern" value="yyyy- MM-dd HH:mm:ss"/>-->
        <constructor-arg type="java.lang.String" value="yyyy-MM-dd HH:mm:ss"/>
                        </bean>
                    </property>
            	</bean>
            </property>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```

```java
@GetMapping("/parseDate") 
public Date parseDate(){
	return new Date();
}
```

#### 10、跨域问题

##### 10.1.同源策略

>是浏览器自带的一个安全策略,能够阻止从一个域去加载另一个域的资源

##### 10.2.什么叫不同的域

**协议**|**域名**|**端口** 这三个条件要完全相同,才叫同一个域,只要有一个不一样,在做数据请求的时候就叫跨域访问,就会触发浏览器的同源策略

eg:当前服务器为:` [http://softeem.com/test/test2/test3 `]让其去访问(比如通过ajax):

| **URL**                                                      | **是否跨域** |
| ------------------------------------------------------------ | ------------ |
| **http://softeem.com/test2/test3**                           | 不跨域       |
| [**https://softeem.com/test/test2/test3**](https://softeem.com/test/test2/test3) | 跨域         |
| [**http://www.softeem.com/test/test2/test3**](http://www.softeem.com/test/test2/test3) | 跨域         |

**注意:**从http://127.0.0.1:8080/test去访问http://localhost:8080/test也是触发跨域

##### 10.3. 跨域访问方法

>### CORS(Cross-Origin Resource Sharing):跨域资源共享
>
>​		1.   jsonp:只支持GET请求
>
>		2.   CORS:支持所有类型的HTTP请求跨域问题

###### 1.全局解决方案

```xml
<!-- 解决跨域访问 -->
<mvc:cors>
    <!--    path可以使用通配符匹配 -->
    <!--<mvc:mapping path="/restful/*"/>-->
    <mvc:mapping path="/request"
        allowed-methods="GET,POST"
        allowed-origins="http://localhost:8081,https://localhost:8081"
        max-age="3600" />
</mvc:cors>
```

###### 2.局部解决方案

```java
/*
额外的, @CrossOrigin 也可以放在类上,代表该类下面的所有方法都遵循该跨域配置,
如果类和方法上都存在,则遵循就近原则 ,以方法上的配置为准
*/
@PostMapping("/request")
@CrossOrigin(origins = "*",methods = {RequestMethod.GET,RequestMethod.POST}, maxAge = 3600)
public String postRequest(Student student){ 
    System.out.println("POST请求接收的数据为***********"+student); 
    return "{\"state\": \"post成功\"}";
}

```

#### 11、文件上传

```xml
<!--	文件上传必须要依赖于commons-fileupload和commons-io两个包(因为前者依赖后者,所以我们引入前者的依赖即可),DispatcherServlet在初始化的时候会初始化其他组件(包括MultipartResolver),但是在DispatcherServlet.properties文件中没有提供MultipartResolver的类,所以需要我们自己引入它的依赖,并在SpringIOC容器中配置一个名为multipartResolver的org.springframework.web.multipart.commons.CommonsMultipartResolver的bean对象	-->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.4</version>
</dependency>
```

```xml
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <property name="defaultEncoding" value="UTF-8"/>
    <!--	文件上传的最大值(相对于整个请求而言),单位是字节byte ,默认为-1代表不做限制	-->
    <property name="maxUploadSize" value="2000000"/>
    <!-- 文件上传中每个文件大小的最大值,单位字节	-->
    <!--	<property name="maxUploadSizePerFile" value="1000000"/>-->
    <!-- 设置文件流缓冲区的大小,默认为10240(10kb) -->
    <!--	<property name="maxInMemorySize" value="1024"/>-->
</bean>

```

```java
@Controller 
@RequestMapping("/upload")
public class UploadFileController {
    //用户上传文件的根路径
    private static final String FILE_PATH="C:\\Users\\Administrator\\Desktop\\upload";

    @ResponseBody 
    @PostMapping("/fileUpload")
    public String fileUpload(String username, MultipartFile uploadFile){
        System.out.println(" 文 件 名 为 :"+uploadFile.getName()); 
        System.out.println(" 文 件 类 型 :"+uploadFile.getContentType()); 							System.out.println("文件名原本的名字为:"+uploadFile.getOriginalFilename()); 
        //原始名字中有后缀
        String originalFilename = uploadFile.getOriginalFilename();
    	int index = originalFilename.lastIndexOf(".");
        //后缀名
        String suffix = originalFilename.substring(index);
        String fileName = "用户上传" + System.currentTimeMillis() + suffix;
        try {
        	//存储文件
        	uploadFile.transferTo(new File(FILE_PATH + File.separator + fileName));
        } catch (IOException e) {
        	e.printStackTrace(); 
         	System.err.println("存储文件失败~");
        }
        
        //try {
        //    InputStream inputStream = uploadFile.getInputStream(); 
        //    FileOutputStream outputStream = 
        //        new FileOutputStream(FILE_PATH +  File.separator + fileName);
        //    int b = 0;
        //   while ((b = inputStream.read()) != -1) { 
        //        outputStream.write(b);
        //    }
        //} catch (IOException e) { 
        //    e.printStackTrace(); 
        //    System.err.println("存储文件失败~");
        //}

        return "Success";
    }
}
```

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
    <title>文件上传</title>
    </head>
    <body>
        <%--
            1.	application/x-www-form-urlencoded : 数据用字符串拼接以后发送
            2.	multipart/form-data:不对字符进行编码
            3.	text/plain:将空格转换成+,但是如果数据中存在特殊字符的话,不进行编码
        --%>
        <form action="/upload/fileUpload" method="post" enctype="multipart/form-data">
            姓名:<input type="text" name="username"><br>
            头像:<input type="file" name="uploadFile"><br>
            <input type="submit" value="点我提交">
        </form>
    </body>
</html>

```

#### 12、SpringMVC拦截器

>在Servlet阶段学过的过滤器(Filter),它和拦截器(Interceptor)作用是一样的,但是底层的实现完全不一样
>
>1.  拦截器:Interceptor,是Spring框架的一部分,天然运行在IOC容器中,底层基于 代理模式 ,是AOP面向切面编程的又一个具体实现
>2. 过滤器:J2EE的标准,由不同的第三方容器厂商(Tomcat,Jboss,Netty)实现的,基于 函数回调机制
>2. 拦截器的使用场景:日志记录,用户画像,性能监控,权限认证

##### 12.1.自定义拦截器

>自定义拦截器:实现HandlerInterceptor接口并且实现他的三个方法

```java
@Component
public class MyInterceptor implements HandlerInterceptor {
    /**
    *	前置处理器:
    *   	在 HandlerMapping 确定适当的处理程序对象之后，
    *   	但在 HandlerAdapter 调用处理程序之前调用。
    */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(request.getRequestURL()+"这个URL在preHandle被拦截了");
        return true;
    }

    /**
    *	目标资源已经被SpringMVC框架处理之后(Controller里面的方法return)
    在 HandlerAdapter 实际调用处理程序之后，但在 DispatcherServlet 呈现视图之前调用。可以通过给定的 ModelAndView 向视图公开其他模型对象。
    */ 
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    	System.out.println(request.getRequestURL()+"这个URL在postHandle被拦截了");
    }

    /**
    *	产生了响应文本之后(json数据被Jackson处理了之后|数据和模板引擎绑定之后)
    渲染视图后。将在处理程序执行的任何结果上调用，从而允许适当的资源清理。
    */ 
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
    	System.out.println(request.getRequestURL()+"这个URL在afterCompletion被拦截了");
    }
}

```

```xml
<mvc:interceptors>
    <mvc:interceptor>
        <!--	/** 代表可以拦截路径中无论多少级的请求 -->
        <mvc:mapping path="/**"/>
        <!--	<bean class="com.softeem.interceptors.MyInterceptor"/>-->
        <ref bean="myInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\Springmvc拦截器的执行位置.png)

>如图,我们在配置文件里面通过 <`mvc:default-servlet-handler`/>让DispatcherServlet对静态资源放行,但是静态资源后面又被拦截器拦截了,所以出现下面这种情况

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\资源springMV拦截器拦截.jpg)

##### 12.2.拦截器对静态资源放行

```xml
<mvc:interceptors>
    <mvc:interceptor>
        <!--	/** 代表可以拦截路径中无论多少级的请求 -->
        <mvc:mapping path="/**"/>
        <!--	对哪些请求放行	-->
        <mvc:exclude-mapping path="/**.ico"/>
        <mvc:exclude-mapping path="/**.css"/>
        <mvc:exclude-mapping path="/**.js"/>
        <mvc:exclude-mapping path="/static/**"/>
        <!--	<bean class="com.softeem.interceptors.MyInterceptor"/>-->
        <ref bean="myInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>

```

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    System.out.println(request.getRequestURL()+"这个URL在preHandle被拦截了");
    System.out.println(" 用 户 IP 为 "+request.getRemoteHost()); 
    System.out.println("用户的上网环境为:"+request.getHeader("user-agent")); 
    return true;
}
```

>如果存在多个自定义拦截器,他们的执行顺序为?
>
>MyInterceptor: preHandle   postHandle   afterCompletion 
>
>MyInterceptor2: preHandle   postHandle   afterCompletion

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\多个拦截器的执行顺序.png)

### 5、MyBatis

>**Mybatis**是国内比较流行的ORM( Object Relation Mapping 对象关系映射)框架,所有ORM工具唯一的作用就是:把对持久化对象的CRUD的操作,转换为对数据库的操作
>
>**MyBatis** 是一款优秀的**持久层框架**，它支持定制化**SQL**、存储过程以及高级映射。**MyBatis**避免了几乎所有的 **JDBC** 代码和手动设置参数以及获取结果集。**MyBatis**可以使用简单的**XML**或**注解**来配置和映射原生信息，用以将接口和 **Java** 的 **POJO(Plain Old Java Object**，普通 **Java对象**)映射成数据库中的记录，使得开发人员可以使用面向对象的方法来操作数据库

#### 1、创建MyBatis项目

##### 1.1.引入依赖

```xml
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.7</version>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.24</version>
</dependency>

<!-- 日 志 -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.5</version>
</dependency>

<!-- junit -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>4.12</version>
    <scope>test</scope>
</dependency>

```

##### 1.2.创建MyBatis配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!-- 引入外部配置文件 -->
	<properties resource="jdbc.properties" />
    
    <!-- environments:多环境配置的标签 元配置信息default必须存在, 代表使用作为默认加载的环境 -->
    <environments default="development">
        <!--  environment标签代表具体的某个环境配置信息id必须存在,作为当前环境的唯一标志-->
        <environment id="development">
            <!-- type事务管理的配置:
            		=>JDBC:直接使用JDBC的提交和回滚的设置
            		=>MANAGED:这个配置基本啥都不干,因为它依赖于让容器来管理事务-->
            <transactionManager type="JDBC"/>
            <!--dataSource表示数据源的配置:
            		=>POOLED代表使用连接池	=>UNPOOLED:代表直连
            		=>JNDI:把数据源的配置信息放在服务器这样的容器中使用,好处就是可以集中在外部配置文件中对数据源进行管理-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
</configuration>
```

##### 1.3.jdbc.properties

```properties
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&serverTimezone=Asia/Shanghai&characterEncoding=utf-8&useSSL=false
jdbc.username=root
jdbc.password=root
```

##### 1.4.创建工具类生产SqlSession

>因为这里我们只是学习MyBatis所有没有引入Spring,所以需要自己创建和管理SqlSession
>
>同时为了保证SqlSessionFactory全局唯一性,在工具类把它定义为**static**

```java
/**
*	@author muzi@softeem.com
*	@description 1.创建全局唯一的SqlSessionFactory对象 2.创建SqlSession 3.关闭连接
* @since 2021/9/18 21:50
*/
public class MybatisUtil {
    
    private static SqlSessionFactory factory = null; 
    
    static {
        try {
        	Reader reader = Resources.getResourceAsReader("mybatis-config.xml"); 
            factory = new SqlSessionFactoryBuilder().build(reader);
        } catch (IOException e) { 
            e.printStackTrace();
        	throw new ExceptionInInitializerError(e);
        }
    }

    /**
    *  创建SqlSession对象
    */
    public static SqlSession createSqlSession(){ 
        return factory.openSession();
    }

    /**
    *	关闭连接
    */
    public static void closeSqlSession(SqlSession sqlSession){ 
        sqlSession.close();
    }
}
```

##### 1.5.验证是否创建SqlSession对象

```java
@Test
public void testSqlSessionFactory() {
/**
*	1.加载配置文件,初始化Mybatis环境
*	2.获取SqlSessionFactory对象,让其创建SqlSession对象
*	3.通过SqlSession对象获得Connection对象,如果不为空,代表连接到了数据库
*/
	SqlSession sqlSession = null; 
    try {
    	sqlSession = MybatisUtil.createSqlSession(); 												System.out.println(sqlSession.getConnection());
    } finally {
        if (sqlSession != null) {
            //如果数据源的type为POOLED:这里代表将连接交还给连接池
            //如果数据源的type为UNPOOLED:这里相当于JDBC阶段学习的Connection.close
            MybatisUtil.closeSqlSession(sqlSession);
    	}
    }
    }
}

```

##### 1.6.体验通过映射文件查询

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--mapper是根标签, namespace必须配置,意思是命名空间,必须唯一-->
<mapper namespace="xxx">
    <select id="queryAll" resultType="com.softeem.entity.Student"> 
        SELECT id,name,age,address FROM student
    </select>
</mapper>

```

##### 1.7.在MyBatis配置文件中注册映射文件

```xml
<!-- 注册映射文件	-->
<mappers>
	<mapper resource="mappers/studentDao.xml"/>
</mappers>
```

##### 1.8.查询

```java
/**
* 测试查询所有
*/ @Test
public void testQueryAll(){ 
    SqlSession sqlSession = null; 
    try {
        sqlSession = MybatisUtil.createSqlSession();
        List<Student> list = sqlSession.selectList("xxx.queryAll"); 
        for (Student student : list) {
        	System.out.println(student);
        }
        } catch (Exception e) { 
            e.printStackTrace(); 
            System.err.println("查询出错了!");
        }finally {
        	if (sqlSession != null) { 
                MybatisUtil.closeSqlSession(sqlSession);
        	}
    	}
}
```



#### 2、核心组件讲解

>1.**SQLSessionFactory**:负责初始化Mybatis环境,所有要保证它 全局唯一
>2.**SqlSession**:操作数据库的核心对象,提供JDBC方式与数据库进行交互,封装了对数据表CRUD的方法和事务相关的方法

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\MyBatis核心组件.JPG)

#### 3、各种查询

##### 3.1. 传单个参数

```java
/**
* 测试根据id查询学生信息
*/
@Test
public void testQueryById(){ 
    SqlSession sqlSession = null; 
    try {
        sqlSession = MybatisUtil.createSqlSession();
        Student student= sqlSession.selectOne("xxx.queryById",1); 									System.out.println(student);
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    }finally {
    	if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
    	}
    }
}
```

```xml
<!-- parameterType:参数类型  resultType:结果类型	-->
<!-- 如果只传一个参数,那么参数名可以随便给,但是建议用value或者是类里面的属性名 -->
<!-- 暂时记住,Mybatis接收参数要使用#{}也可以使用${} -->
<mapper namespace="xxx">
    <select id="queryById" parameterType="integer" resultType="com.softeem.entity.Student">
        SELECT id,name,age,address FROM student WHERE id=#{id}
    </select>
</mapper>
```

##### 3.2.传多个参数

###### 3.2.1.使用Map集合

```java
/**
* 测试传多个参数,使用Map传参
*/ 
@Test
public void testQueryByRange(){ 
    SqlSession sqlSession = null; 
    try {
        sqlSession = MybatisUtil.createSqlSession(); 
        HashMap map = new HashMap<String,Integer>(); 
        map.put("first", 1);
        map.put("last", 2);
		List<Student> students= sqlSession.selectList("xxx.queryByRange",map);
        for (Student student : students) { 
            System.out.println(student);
        }
        } catch (Exception e) { 
        	e.printStackTrace(); System.err.println("查询出错了!");
        }finally {
        	if (sqlSession != null) { 
                MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}

```

```xml
<mapper namespace="xxx">
    <select id="queryByRange" parameterType="map" resultType="com.softeem.entity.Student">
        SELECT id,name,age,address 
        FROM student 
        WHERE id=#{first} OR id=#{last}
    </select>
</mapper>
```

###### 3.2.1.传对象

```java
/**
* 测试传参使用包装类
*/ 
@Test
public void testQueryByRange3() { 
    SqlSession sqlSession = null; 
    try {
        sqlSession = MybatisUtil.createSqlSession(); 
        StudentParam studentParam = new StudentParam(); 
        studentParam.setParam1(1); studentParam.setParam2(2);
        List<Student> students = sqlSession.selectList("xxx.queryByRange3", studentParam);
        for (Student student : students) { 
            System.out.println(student);
        }
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    } finally {
    	if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
    	}
    }
}
```

```xml
<!-- 使用包装类传参,注意参数名要严格一一对应 -->
<select id="queryByRange3" parameterType="com.softeem.params.StudentParam" resultType="com.softeem.entity.Student">
	SELECT id,name,age,address FROM student WHERE id=#{param1} OR id=#{param2}
</select>
```



##### 3.3.结果接收

###### 3.3.1.基本类型接收(略)

###### 3.3.2.对象接收(以上都是(略))

###### 3.3.3.Map集合接收

>额外的,结果映射也可以用Map接收,但是Mybatis默认使用Map接口的实现类是HashMap,无序,所以如果要求顺序,可以换成LinkedHashMap

```java
/**
*	测试传参和结果映射都用map
*	附加Mybatis映射文件使用map和java.util.LinkedHashMap接收值的区别
*/ 
@Test
public void testQueryByRange2() { 
    SqlSession sqlSession = null; 
    try {
        sqlSession = MybatisUtil.createSqlSession();
        HashMap map = new HashMap<String, Integer>(); 
        map.put("first", 1);
        map.put("last", 2);
        List<Map> students = sqlSession.selectList("xxx.queryByRange2", map); 
        for (Map student : students) {
        	System.out.println(student);
            System.out.println(student.get("name"));
        }
    } catch (Exception e) {
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    } finally {
        if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}
```

```xml
<select id="queryByRange2" parameterType="map" resultType="java.util.LinkedHashMap">
	SELECT id,name,age,address 
    FROM student 
    WHERE id=#{first} OR id=#{last}
</select>
```

###### 3.3.4.接收结果通过ResultMap

```java
/**
* 测试查询所有,返回ResultMap
*/ 
@Test
public void testQueryAllWithResultMap(){ 
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        List<Student> list = sqlSession.selectList("xxx.queryAllWithResultMap"); 
        for (Student student : list) {
        	System.out.println(student);
    	}
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    }finally {
    	if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
    	}
    }
}
/*
暂时resultMap用来解决查询到的结果 下划线转驼峰 ,但是最最要的用处还是 级联查询 (后面学习)
至于 下划线转驼峰 ,我们可以通过配置开启,在Mybatis的配置文件中加上
<settings>
	<setting name="mapUnderscoreToCamelCase" value="true"/>
</settings>
*/
```

```xml
<!-- 外部结果映射 -->
<!-- resultMap中id是该映射的唯一标志,type代表返回的类型 -->
<!-- <id/>子元素代表数据表的主键,其中property代表类中的属性名,column代表表中的字段 -->
<!-- <result/>子元素代表数据表的普通列 -->
<resultMap id="baseMap" type="com.softeem.entity.Student">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="age" column="age"/>
    <result property="address" column="address"/>
</resultMap>

<!-- resultMap外部结果映射的引用-->
<select id="queryAllWithResultMap" resultMap="baseMap"> 
    SELECT id,name,age,address FROM student
</select>
```

#### 4、事务性操作(新增为例)

```java
/**
* 新增单个学生记录
*/
@Test
public void testInsertStudent(){ 
    SqlSession sqlSession = null; 
    try {
    	sqlSession = MybatisUtil.createSqlSession(); 
        Student student = new Student(); student.setId(4);
        student.setName("阿姜");
        student.setAge(99); student.setAddress("湖北武汉");
    	int effectiveNum = sqlSession.insert("xxx.insertStudent",student);
        //提交事务
        sqlSession.commit();
        System.out.println("生效的数量为"+effectiveNum);
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    	//回滚事务
    	sqlSession.rollback();
    }finally {
    	if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
    	}
    }
}
```

```xml
<!-- 写 操 作 -->
<!-- insert没有result属性,但是不代表拿不到新增的数量 -->
<insert id="insertStudent" parameterType="com.softeem.entity.Student"> 
    INSERT INTO student(id,name,age,address) 
    VALUES(#{id},#{name},#{age},#{address})
</insert>
```

#### 5、获取数据库自增主键

##### 5.1.通过具体数据库的技术获取

```java
/**
* 在一个方法中,先新增,再根据id修改
*/ 
@Test
public void testInsertAndUpdate(){ 
    SqlSession sqlSession = null; 
    try {
        sqlSession = MybatisUtil.createSqlSession();
        Student student = new Student(); 
        student.setName(" 阿 姜 2"); 
        student.setAge(9999);
        student.setAddress("湖北武汉");
        int effectiveNum = sqlSession.insert("xxx.insertAndUpdate",student); 						System.out.println("生效的数量为"+effectiveNum);
        
        System.out.println("刚刚新增的学生id为"+student.getId()); 
        student.setName(" 热 巴 不 喜 欢 阿 姜 "); 
        student.setAge(99999);
        sqlSession.update("xxx.updateStudnetById", student);
    	//提交事务
        sqlSession.commit();
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    	//回滚事务
    	sqlSession.rollback();
    }finally {
    	if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}
```

```xml
<insert id="insertAndUpdate" parameterType="com.softeem.entity.Student">
    <selectKey resultType="integer" keyProperty="id" keyColumn="id" order="AFTER"> 
        <!--MySql中如下-->
        select LAST_INSERT_ID()
        <!--Oracle中使用 select SEQUENCE_student.nextval as id from dual -->
    </selectKey>
    INSERT INTO student(name,age,address) 
    VALUES(#{name},#{age},#{address})
</insert>

<update id="updateStudnetById" parameterType="com.softeem.entity.Student">
	UPDATE student SET name=#{name}, age=#{age}, address=#{address}
	WHERE id=#{id}
</update>
```

##### 5.2.通过Mybatis自带的机制获取(推荐)

```xml
<!-- useGeneratedKeys代表告诉Mybatis这里要使用自增主键并返回
,最好配合keyProperty,keyColumn准确定位到主键值-->
<insert id="insertAndUpdate2" parameterType="com.softeem.entity.Student" useGeneratedKeys="true" keyProperty="id" keyColumn="id">
	INSERT INTO student(name,age,address) VALUES(#{name},#{age},#{address})
</insert>

```

#### 6、获取非自增主键

以UUID为例

```xml
<!-- 注意:这里的order是`BEFORE`,并且insert语句中所有字段都要写出来,因为是要先生成UUID作为一个字段值插入表中,上面的主键自增用的是`AFTER`,插入后主键才生成-->
<insert id="insertAndUpdate2" parameterType="com.softeem.entity.Student3">
    <selectKey resultType="string" keyColumn="id" keyProperty="id" order="BEFORE"> 
        SELECT REPLACE(UUID(),'-','')
    </selectKey>
    INSERT INTO student3(id,name,age,address) 
    VALUES(#{id},#{name},#{age},#{address})
</insert>

<update id="updateStudnetById" parameterType="com.softeem.entity.Student3">
    UPDATE student3 SET
    name=#{name}, age=#{age}, address=#{address}
    WHERE id=#{id}
</update>

```

```java
/**
* 在一个方法中,先新增,再根据id修改,主键是uuid
*/ 
@Test
public void testInsertAndUpdate3() { 
    SqlSession sqlSession = null; 
    try {
    	sqlSession = MybatisUtil.createSqlSession(); 
        Student3 student = new Student3(); student.setName(" 阿 姜 2"); 							student.setAge(9999);
    	student.setAddress("湖北武汉");
		sqlSession.insert("xxxxx.insertAndUpdate2", student); 		
    	System.out.println("刚刚新增的学生id为" + student.getId()); 
        student.setName(" 热 巴 真 的 不 喜 欢 阿 姜 ");
        student.setAge(99999);
    	sqlSession.update("xxxxx.updateStudnetById", student);
    	//提交事务
        sqlSession.commit();
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
        //回滚事务
        sqlSession.rollback();
    } finally {
        if (sqlSession != null) {
        	MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}
```

#### 7、分布式id

##### 7.1.多张表用自增主键

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\多张表用自增主键.png)

##### 7.2.号段模式

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\分布式id号段模式.png)

##### 7.3.Redis(后面补充)

通过指令INCR

##### 7.4.基于雪花算法

>使用一个64位二进制来生成全局唯一ID
>
>1. 百度的`uid-generator`
>2. 美团的`leaf`
>3. 滴滴的`tinyid`

#### 8、SQL防注入

>sql注入是一种比较常见的网络攻击手段,一般是逐步对数据字段进行爆破,表爆破,它不是由于系统的bug产生的,往往是因为编程人员代码疏忽.
>
>最简单的方式就是`预编译`,就是将sql语句参数化,结构化,最典型的就是`PreparedStatement`

```java
#{} :是将传入的数据作为一个字符串,会自动对传入的数据加一对双引号这个操作就是`参数化`(Parameterized ),能够解决绝大多数sql注入的问题(有预编译)
${} :是将传入的数值直接拼接上sql语句中;额外的, MybatisPlus 中如果想映射文件传入条件构造器 Wrapper(无预编译)

```

#### 9、动态SQL

##### 9.1.OGNL

>OGNL表达式,是一种开源的表达式语言,MyBatis的动态SQL就是基于它

| **关系**       | **OGNL**                                                     |
| -------------- | ------------------------------------------------------------ |
| e1&e2 与关系   | e1 `and`  e2                                                 |
| e1\|e2 或关系  | e1 `or `e                                                    |
| 相等 e1==e2    | e1`==`e2 或 者 e1 `eq`e2                                     |
| 不等于  e1!=e2 | e1`!=`e2 或 者 e1 `neq` e2                                   |
| 比较关系       | 大于  e1`>`e2(e1 `gt` e2),小于e1`<`e2(e1 `lt` e2),大于等于e1`>=`e2(e1 `gte` e2),小于等于 lte |
| 取反           | `!`e1 或 者 `not`e1                                          |

##### 9.2.动态SQL涉及到的标签

###### 9.2.1.`<if test/>`

```xml
<!-- ======================动态SQL=====================-->
<select id="queryByDynamic" parameterType="com.softeem.entity.Student" resultType="com.softeem.entity.Student">
	SELECT id,name,age,address FROM student WHERE 1=1
    <if test="name!=null">
    	AND name LIKE concat('%',#{name},'%')
    </if>
    <if test="address!=null"> 
        AND address=#{address}
    </if>
</select>
```

```java
/**
  * <if test/>
  */ 
@Test
public void testDynamicSQL1() { 
    SqlSession sqlSession = null; 
    try {
		sqlSession = MybatisUtil.createSqlSession();
		Student params = new Student(); 
        params.setName(" 姜 "); 
        params.setAddress("湖北武汉");
		List<Student> list = sqlSession.selectList("xxx.queryByDynamic",params); 
        for (Student student : list) {
        	System.out.println(student);
        }
	} catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
	} finally {
		if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
		}
	}
}
```

###### 9.2.2.`<where/>`

>如果where标签里的语句为空,则会自动省略sql中的where关键字

```xml
<select id="queryByDynamic" parameterType="com.softeem.entity.Student"
resultType="com.softeem.entity.Student">
    SELECT id,name,age,address
    FROM student
    <where>
        <if test="name!=null and name!=''">
        	AND name LIKE concat('%',#{name},'%')
        </if>
        <if test="address!=null and address!=''">
        	AND address=#{address}
        </if>
    </where>
</select>
```

###### 9.2.3.`<set/>`

```xml
<update id="updateDynamic" parameterType="com.softeem.entity.Student">
    UPDATE student
    <set>
        <if test="name!=null and name!=''">
        	name=#{name},
        </if>
        <if test="age!=null">
        	age=#{age},
        </if>
        <if test="address!=null and address!=''">
        	address=#{address}
        </if>
    </set>
    WHERE id=#{id}
</update>
```

###### 9.2.4.`<choose (when,otherwise)/>`

>choose和switch,case带break时一模一样,一次最多只有一个会满足

```xml
<select id="selectWithChoose" parameterType="com.softeem.entity.Student"
resultType="com.softeem.entity.Student">
    SELECT id,name,age,address
    FROM student
    <where>
        <choose>
            <when test="name!=null and name!=''">
            	AND name LIKE concat('%',#{name},'%')
            </when>
            <when test="age!=null">
            	AND age=#{age}
            </when>
            <otherwise>
            	AND address='湖北武汉'
            </otherwise>
        </choose>
    </where>
</select>
```

```java
/*
* 使用choose做条件分支判断
*/
@Test
public void testSelectWithChoose() {
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        Student student = new Student();
        // student.setId(1);
        // student.setAddress("湖北武汉");
        // student.setName("热巴");
        student.setAge(99999);
        List<Student> list=sqlSession.selectList("xxx.selectWithChoose", student);
        for (Student s : list) {
        	System.out.println(s);
    	}
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println("查询出错了!");
    } finally {
        if (sqlSession != null) {
        	MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}
```

###### 9.2.5.`<foreach/>`

>批处理实际上就把所有操作整合成一句sql执行 MySQL默认一条sql的最大长度是1M,如果SQL语句过长,数据库会直接报错.如果数据量特别大,建议 `分段处理` ,也可以修改数据库配置( 不建议 ,1.如果sql过于长,会产生断崖式的效率下降;2.如果数据库 所在服务器和服务所在的服务器不是同一台,存在数据传输的成本,sql越长对于带宽要求越高)
>
>SQL语句过长采用分段加foreach

```xml
<!-- 批处理:找规律 -->
<!-- insert本来就支持批量插入,INSERT INTO t(a,b,c) VALUES(A1,B1,C1),(A2,B2,C2),
(A3,B3,C3) .......-->
<insert id="batchInsert" parameterType="list" useGeneratedKeys="true"
keyProperty="id" keyColumn="id">
    INSERT INTO student(name, age, address)
    VALUES
    <foreach collection="list" item="item" index="index" separator=",">
    	(#{item.name}, #{item.age}, #{item.address})
    </foreach>
</insert>
```

```java
@Test
public void testBatchInsertWithForeach() {
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        Student student = null;
        ArrayList<Student> list = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            student = new Student();
            student.setAddress("湖北武汉");
            student.setName("热巴真的讨厌阿姜" + i);
            student.setAge(99999);
            list.add(student);
        }
        sqlSession.insert("xxx.batchInsert", list);
        sqlSession.commit();
    }
    ...
```

>传数组

```xml
<!-- 抽取公共SQL片段,可以复用 -->
<sql id="base_column">id, name, age, address</sql>
<!-- select * from student where id in(1,100,1000) -->
<select id="batchQueryWithArray" parameterType="list" resultType="com.softeem.entity.Student">
    <!-- 使用<include refid=/>对公共代码片段做引用 -->
    SELECT <include refid="base_column"/> 
    FROM student
    <where>
        <foreach collection="array" item="item" index="index" separator=","
        open="id in(" close=")">
        	#{item}
        </foreach>
    </where>
</select>
```

```java
/**
* 批处理传数组
*/
@Test
public void testBatchQueryWithArray() {
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        int[] ids = {1, 100, 1000};
        List<Student> list = sqlSession.selectList("xxx.batchQueryWithArray",ids);
        for (Student student : list) {
        	System.out.println(student);
    	}
        ....
```

>传Map

```java
/**
* 批处理传Map
*/
@Test
public void testBatchQueryWithMap() {
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        int[] ids = {1, 100, 1000};
        HashMap map = new HashMap();
        map.put("aaa", ids);
        List<Student> list = sqlSession.selectList("xxx.batchQueryWithMap",
        map);
        for (Student student : list) {
        	System.out.println(student);
        }
...
```

```xml
<!-- select * from student where id in(1,100,1000) -->
<select id="batchQueryWithMap" parameterType="map"
resultType="com.softeem.entity.Student">
    SELECT <include refid="base_column"/> 
    FROM student
    <where>
        <foreach collection="aaa" item="item" index="index" separator=","
        open="id in(" close=")">
            #{item}
        </foreach>
    </where>
</select>
```

>传包装类

```java
/**
* 批处理传包装类
*/
@Test
public void testBatchQueryWithDTO() {
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        int[] ids = {1, 100, 1000};
        List<Integer> idss = new ArrayList<>();
        idss.add(10000);
        idss.add(20000);
        idss.add(30000);
        StudentDTO studentDTO = new StudentDTO();
        studentDTO.setAaa(ids);
        studentDTO.setBbb(idss);
        List<Student> list = sqlSession.selectList("xxx.batchQueryWithDTO",
        studentDTO);
        for (Student student : list) {
        	System.out.println(student);
        }

```

```xml
<!-- select * from student where id in(1,100,1000) -->
<select id="batchQueryWithDTO" parameterType="com.softeem.dto.StudentDTO"
resultType="com.softeem.entity.Student">
	SELECT <include refid="base_column"/> 
    FROM student
    <where>
        <foreach collection="bbb" item="item" index="index" separator=","
        open="id in(" close=")">
        	#{item}
        </foreach>
    </where>
</select>
```

#### 10、MyBatis的缓存机制

>MyBatis的缓存机制分为`两级` 两次相同的SQL查询,第二次不再去从磁盘中读取数据,而是直接从第一次查询结果的缓存中获得数据.
>
>缓存默认会对映射文件中所有的`SELECT`语句生效,但是一旦进行事务性操作,MyBatis会删除(刷新)缓存

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\MyBatis缓存机制.png)

##### 10.1.一级缓存(本地缓存)

>一级缓存是默认开启的,缓存的范围是当前的``SqlSession`

```java
/**
* 一级缓存
*/ 
@Test
public void testQueryById() { 
    SqlSession sqlSession = null;
    try {
        //75931202
        sqlSession = MybatisUtil.createSqlSession(); 
        System.out.println(sqlSession.hashCode());
        Student student1 = sqlSession.selectOne("xxx.queryById", 1); 
        Student student2 = sqlSession.selectOne("xxx.queryById", 1);
        //1327006586======1327006586
        System.out.println(student1.hashCode()+"======"+student2.hashCode());
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    } finally {
        if (sqlSession != null) { 
            MybatisUtil.closeSqlSession(sqlSession);
        }
    }

    SqlSession sqlSession2 = null; 
    try {
        //692331943
        sqlSession2 = MybatisUtil.createSqlSession(); 												System.out.println(sqlSession2.hashCode());
        Student student1 = sqlSession2.selectOne("xxx.queryById", 1); 
        Student student2 = sqlSession2.selectOne("xxx.queryById", 1);
        //447212746======447212746
        System.out.println(student1.hashCode()+"======"+student2.hashCode());
    } catch (Exception e) { 
        e.printStackTrace(); 
        System.err.println("查询出错了!");
    } finally {
        if (sqlSession2 != null) { 
            MybatisUtil.closeSqlSession(sqlSession2);
        }
    }
}
```

##### 10.2.二级缓存

>二级缓存是`mapper(namespace)`级别,使用二级缓存时,可以让多个sqlsession共享缓存的数据,可以全局进行开关

```xml
<!--	全局开关二级缓存在MyBatis的配置文件中，默认是true代表开启二级缓存	-->
<setting name="cacheEnabled" value="true"/>
```

>全局开关相当于向你家输送了电,但是你家里的灯要不要开,有它自己的另一个开关,在Mybatis里面,这个开 关在映射文件`(mapper)`里面

```xml
<mapper namespace="xxx">
    <!-- 对xxx这个namespace开启二级缓存功能 -->
    <cache/>
```

>额外的说明:

```xml
<!--
eviction:淘汰（回收）策略：
    -LRU(Least Recently Used)：默认策略，最近最少使用的缓存对象在回收机制被触发的时候优
    先被清除
    -FIFO(First In First Out)：先进先出，和队列的数据结构一致，回收机制被触发，先缓存的
    先被淘汰
    -SOFT(软引用)：依赖于JVM的垃圾回收机制
    -WEAK(弱引用)：比软引用还要弱的一种引用类型
size：缓存的数量，默认值是1024（个）
flushInterval：缓存刷新的时间间隔，默认没有设置，就是不会间歇性的清空缓存。可以设置任正整数，单位为毫秒
readOnly：是否只读，默认为false。
    -false代表Mybatis会对缓存数据进行拷贝，如果命中缓存，Mybatis返回的是拷贝之后的对象，其中涉及到序列化操作，所以对应的类要实现序列化接口，否则报错。
    -true代表原样返回，所有命中缓存的操作得到的缓存对象是同一个对象
-->
<cache eviction="LRU" size="600" flushInterval="600000" readOnly="true"/>

<!-- 如果查询的数据量比较大，建议把select标签的useCache指定为false，代表不缓存 -->
<select id="queryAll" resultType="com.softeem.entity.Student" useCache="false"> 
    SELECT id, name, age, address FROM student
</select>
```

对于 `<select/< update/> <insert/> <delete/>` 标签，`select标签中`，有一个属性叫`flushCache` 默认为false代表**不会清除缓存**,对于另外的三个标签,他们的 flushCache 值默认为true,代表执行完增删改操作之后,会清空缓存,避免缓存结果和数据库中的结果不一致的情况
额外的:
开启二级缓存后,日志会出现 Cache Hit Ratio [xxx]: 0.0 这样的记录,仅代表 二级缓存命中率

#### 11、类型关联

```xml
<!-- 在MyBatis的配置文件中,两种方式如下 -->
<typeAliases>
    <!-- 设置别名,默认别名为类名,而且不区分大小写 -->
    <!-- <typeAlias type="com.softeem.entity.Student" />-->
    <!-- 设置别名.自定义别名 -->
    <!-- <typeAlias type="com.softeem.entity.Student" alias="teacher"/>-->
    <!-- 设置别名,包扫描批量设置,可以配合类上的@Alias注解,自定义别名 -->
    <package name="com.softeem.entity"/>
</typeAliases>
```

```java
@Alias("teacher")
public class Student {
```

#### 12、级联查询

##### 12.1.多对一/一对一(association)

```xml
<!-- 一对一关联查询 -->
<resultMap id="StudentInfo" type="com.softeem.dto.StudentAssociationDTO">
    <id property="id" column="id" jdbcType="INTEGER"/>
    <result property="name" column="name" jdbcType="VARCHAR"/>
    <result property="age" column="age" jdbcType="INTEGER"/>
    <result property="address" column="address" jdbcType="VARCHAR"/>
    <result property="courseId" column="course_id" jdbcType="INTEGER"/>
    <!-- association用来处理一对一/多对一关联关系的标签 -->
    <association property="course" javaType="com.softeem.entity.Course">
        <id property="courseId" column="course_id"/>
        <result property="courseName" column="course_name"/>
        <result property="courseContent" column="course_content"/>
    </association>
</resultMap>
<!-- 多对一/一对一 复杂版本 -->
<select id="selectManyToOne" resultMap="StudentInfo" parameterType="int">
    SELECT id,NAME,age,address,s.course_id,c.course_id,course_name,course_content
    FROM student s
    LEFT JOIN course c 
    ON s.course_id = c.course_id
    WHERE s.id =#{id}
</select>

<!-- 一对一关联查询 -->
<resultMap id="StudentInfo2" type="com.softeem.dto.StudentAssociationDTO">
    <id property="id" column="id" jdbcType="INTEGER"/>
    <result property="courseId" column="course_id" jdbcType="INTEGER"/>
    <!-- 用来处理一对一/多对一关联关系的标签 -->
    <association property="course" javaType="com.softeem.entity.Course"
    	select="com.softeem.dao.CourseDao.queryById" column="course_id"/>
</resultMap>
<!--级联查询 简单方法-->
<select id="selectManyToOne2" resultMap="StudentInfo2">
    select id,name,age,address,course_id
    from vip1_mybatis.student
    where id = #{id}
</select>
```

```sql
SELECT id,NAME,age,address,s.course_id,c.course_id,course_name,course_content
FROM student s
LEFT JOIN course c 
ON s.course_id = c.course_id
WHERE s.id = 1

-- 第一步:根据学生ID查询学生信息,其中包括关联课程id
SELECT * FROM student WHERE id =1
-- 第二步:根据关联的课程id查询课程信息
SELECT * FROM course WHERE course_id=1
```

```java
/**
* 一对一/多对一 复杂版本
*/
@Test
public void testManyToOne1(){
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        StudentAssociationDTO student =
        	sqlSession.selectOne("com.softeem.dao.StudentDao.selectManyToOne", 1);
        System.out.println(student);
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println("查询出错了!");
    } finally {
        if (sqlSession != null) {
        	MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}

/**
* 一对一/多对一 简单版本
*/
@Test
public void testManyToOne2(){
    SqlSession sqlSession = null;
    try {
        sqlSession = MybatisUtil.createSqlSession();
        StudentAssociationDTO student =
        	sqlSession.selectOne("com.softeem.dao.StudentDao.selectManyToOne2", 1);
        System.out.println(student);
    } catch (Exception e) {
        e.printStackTrace();
        System.err.println("查询出错了!");
    } finally {
        if (sqlSession != null) {
        	MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}
```

##### 12.2.多对多/一对多(collection)

```sql
-- 第一步:根据关联的课程id查询课程信息
SELECT * FROM course WHERE course_id=1
-- 第二步:根据课程id查询学生表中,course_id等于查询到课程id的学生信息
SELECT * FROM student WHERE course_id =1
```

```xml
<!-- 一对多关联查询 -->
<resultMap id="CourseInfo" type="com.softeem.dto.CourseCollectionDTO">
    <id property="courseId" column="course_id" jdbcType="INTEGER"/>
    <collection property="studentList" javaType="list" ofType="com.softeem.entity.Student"
    		select="com.softeem.dao.StudentDao.selectByCourseId" column="course_id"/>
</resultMap>
<!-- 一对多关联查询,已知课程id,要求查询课程相关信息,以及参与课程的所有学生信息 -->
<select id="selectOneToMany" resultMap="CourseInfo">
    select course_id,course_name,course_content
    from vip1_mybatis.course
    where course_id = #{courseId}
</select>
<!-- StudentDao命名空间下的 -->
<select id="selectByCourseId" resultType="com.softeem.entity.Student">
	SELECT * FROM student WHERE course_id =#{courseId}
</select>
```

#### 13、注解开发

##### 13.1.通过代理对象查询

```java
/**
* 学生表(Student)表数据库访问层
*/
public interface StudentDao {
    /**
    * 通过ID查询单条数据
    * @param id 主键
    * @return 实例对象
    */
    Student queryById(Integer id);
```

```xml
<!--mybatis映射文件-->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.softeem.dao.StudentDao">
    
    <resultMap type="com.softeem.entity.Student" id="StudentMap">
        <result property="id" column="id" jdbcType="INTEGER"/>
        <result property="name" column="name" jdbcType="VARCHAR"/>
        <result property="age" column="age" jdbcType="INTEGER"/>
        <result property="address" column="address" jdbcType="VARCHAR"/>
        <result property="courseId" column="course_id" jdbcType="INTEGER"/>
    </resultMap>
    
    <!--查询单个-->
    <select id="queryById" resultMap="StudentMap">
</mapper>
```

```xml
<!--mybatis的配置文件-->
<mappers>
    <mapper class="com.softeem.dao.StudentDao"/>
    <mapper resource="mappers/StudentDao.xml"/>
</mappers>
```

```java
public class StudentDaoTest extends TestCase {
    /**
    * 测试根据id查询学生信息
    */
    @Test
    public void testQueryById() {
        SqlSession sqlSession = null;
        try {
            sqlSession = MybatisUtil.createSqlSession();
            //Student student = sqlSession.selectOne("xxx.queryById", 1);
            StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
            Student student = studentDao.queryById(1);
            System.out.println(student);
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("查询出错了!");
        } finally {
            if (sqlSession != null) {
            	MybatisUtil.closeSqlSession(sqlSession);
        }
    }
}
```

##### 13.2.注解开发

| 注解                            | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| @Select @Update @Insert @Delete | 用来替代映射文件中的<select/>,<insert/>,</update>,</delete>  |
| @Results和@Result               | 用来替代映射文件中的<ResultMap/> 以及里面的子标签<result/>   |
| @ResultMap                      | 是用来在接口中对xml文件中定义的ResultMap标签作引用的         |
| @Options                        | 提供一些标签的元配置信息,例如:useGeneratedKeys,keyProperty,useCache |
| @One                            | 一对一关联查询,相当于<association/>                          |
| @Many                           | 一对多关联查询,相当于<collection/>                           |

```java
/**
* 学生表(Student)表数据库访问层
*/
public interface StudentDao {
    /**
    * 通过ID查询单条数据
    */
    @Select("select id,name,age,address,course_id from student where id = #{id}")
    Student queryById(Integer id);
    
    /**
    * 新增数据
    */
    //@SelectKey(statement = "select last_insert_id()",keyProperty = "id",before =
    //false,resultType = Integer.class)
    @Options(useGeneratedKeys = true,keyProperty = "id",keyColumn = "id")
    @Insert("insert into student(name,age,address,course_id) values (#{name}, #{age}, #{address}, #{courseId})")
    int insert(Student student);
    
    /**
    * 修改数据
    */
    @Update("<script>update vip1_mybatis.student\n" +
                " <set>\n" +
                    " <if test=\"name != null and name != ''\">\n" +
                    	" name = #{name},\n" +
                    " </if>\n" +
                    " <if test=\"age != null\">\n" +
                   	 " age = #{age},\n" +
                    " </if>\n" +
                    " <if test=\"address != null and address != ''\">\n" +
                    	" address = #{address},\n" +
                    " </if>\n" +
                    " <if test=\"courseId != null\">\n" +
                    	" course_id = #{courseId},\n" +
                    " </if>\n" +
                " </set>\n" +
    		" where id = #{id}</script>")
    int update(Student student);
    
    /**
    * 一对一关联查询
    * @param id
    * @return
    */
    @Select(" select id,name,age,address,course_id from student where id = #{id}")
    @Results({
        @Result(property = "id",column = "id",id = true),
        @Result(property = "courseId",column = "course_id"),
        @Result(property = "course",javaType = Course.class,
            one = @One(select = "com.softeem.dao.CourseDao.queryById"),
            column = "course_id")
    })
    StudentDTO selectManyToOne(Integer id);
    
    /**
    * 根据课程id查询关联的学生对象列表
    */
    @Select("SELECT * FROM student WHERE course_id =#{courseId} ")
    List<Student> selectByCourseId(Integer id);
}
```

```java
/**
* 课程表(Course)表数据库访问层
*/
public interface CourseDao {
    /**
    * 通过ID查询单条数据
    */
    @Select(" select course_id,course_name,course_content from course where course_id = #{courseId}")
    Course queryById(Integer courseId);
    
    /**
    * 一对多关联查询
    */
    @Select(" select course_id,course_name,course_content from course where course_id = #{courseId}")
    @Results({
        @Result(property = "courseId",column = "course_id",id = true),
        @Result(property = "studentList",javaType=List.class,
            many=@Many(select="com.softeem.dao.StudentDao.selectByCourseId" )),
            column="course_id" 
    })
    CourseDTO selectOneToMany(Integer courseId);
}

```

```xml
<mappers>
    <!-- 单个依次注册-->   
    <!-- <mapper class="com.softeem.dao.StudentDao"/>-->
    <!-- <mapper class="com.softeem.dao.CourseDao"/>-->
    
    <!-- 包扫描-->  
	<package name="com.softeem.dao"/>
</mappers>
```

```java
public class StudentDaoTest {
    /**
    * 测试根据id查询学生信息
    */
    @Test
    public void testQueryById() {
        SqlSession sqlSession = null;
        try {
            sqlSession = MybatisUtil.createSqlSession();
            // Student student = sqlSession.selectOne("xxx.queryById", 1);
            StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
            Student student = studentDao.queryById(1);
            System.out.println(student);
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("查询出错了!");
        } finally {
            if (sqlSession != null) {
            	MybatisUtil.closeSqlSession(sqlSession);
            }
        }
    }
    /** 
    * 新增单个学生记录
    */
    @Test
    public void testInsertStudent() {
        SqlSession sqlSession = null;
        try {
            sqlSession = MybatisUtil.createSqlSession();
            Student student = new Student();
            student.setName("阿姜");
            student.setAge(999);
            student.setAddress("湖北武汉");
            // int effectiveNum = sqlSession.insert("xxx.insertStudent2", student);
            StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
            int effectiveNum=studentDao.insert(student);
            //提交事务
            sqlSession.commit();
            System.out.println("生效的数量为" + effectiveNum);
            System.out.println("刚刚新增的学生id为" + student.getId());
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("新增出错了!");
            //回滚事务
            sqlSession.rollback();
        } finally {
        	if (sqlSession != null) {
            	MybatisUtil.closeSqlSession(sqlSession);
            }
        }
    }
    /**
    * 修改单个学生记录
    */
    @Test
    public void testUpdateStudent() {
        SqlSession sqlSession = null;
        try {
            sqlSession = MybatisUtil.createSqlSession();
            Student student = new Student();
            student.setId(30011);
            student.setName("阿姜222");
            student.setAge(1);
            //int effectiveNum = sqlSession.insert("xxx.insertStudent2", student);
            StudentDao studentDao = sqlSession.getMapper(StudentDao.class);
            int effectiveNum = studentDao.update(student);
            //提交事务
            sqlSession.commit();
            System.out.println("生效的数量为" + effectiveNum);
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("修改出错了!");
            //回滚事务
            sqlSession.rollback();
            } finally {
                if (sqlSession != null) {
               		MybatisUtil.closeSqlSession(sqlSession);
            }
        }
    }
    /**
    * 一对一/多对一 注解版本
    */
    @Test
    public void testManyToOne(){
        SqlSession sqlSession = null;
        try {
            sqlSession = MybatisUtil.createSqlSession();
            StudentDao mapper = sqlSession.getMapper(StudentDao.class);
            StudentDTO student = mapper.selectManyToOne(1);
            System.out.println(student);
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("查询出错了!");
        } finally {
            if (sqlSession != null) {
            	MybatisUtil.closeSqlSession(sqlSession);
            }
        }
    }
    /**
    * 一对多 注解版本
    */
    @Test
    public void selectOneToMany(){
        SqlSession sqlSession = null;
        try {
            sqlSession = MybatisUtil.createSqlSession();
            CourseDao mapper = sqlSession.getMapper(CourseDao.class);
            // CourseCollectionDTO student =
            sqlSession.selectOne("com.softeem.dao.CourseDao.selectOneToMany", 1);
            CourseDTO courseDTO = mapper.selectOneToMany(1);
            System.out.println(courseDTO);
        } catch (Exception e) {
            e.printStackTrace();
            System.err.println("查询出错了!");
        } finally {
            if (sqlSession != null) {
            	MybatisUtil.closeSqlSession(sqlSession);
            }
        }
    }
}
```

#### 14、整合第三方连接池

##### 14.1.C3P0

```xml
<dependency>
    <groupId>com.mchange</groupId>
    <artifactId>c3p0</artifactId>
    <version>0.9.5.2</version>
</dependency>
```

```java
/**
* @author muzi@softeem.com
* @description
* @since 2021/10/8 16:09
*/
public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {
    public C3P0DataSourceFactory() {
    this.dataSource = new ComboPooledDataSource();
    }
}
```

```xml
<environment id="c3p0">
    <transactionManager type="JDBC"/>
    <dataSource type="com.softeem.datasource.C3P0DataSourceFactory">
        <property name="driverClass" value="${jdbc.driver}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.user}"/>
        <property name="password" value="${jdbc.password}"/>
    </dataSource>
</environment>
```

##### 14.2.Druid

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.6</version>
</dependency>
```

```java
public class DruidDataSourceFactory extends UnpooledDataSourceFactory {
    public DruidDataSourceFactory() {
    	this.dataSource = new DruidDataSource();
    }
    @Override
    public DataSource getDataSource() {
        try {
        	((DruidDataSource) this.dataSource).init();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
            throw new RuntimeException("初始化Druid连接池异常");
        }
        return dataSource;
    }
}
```

```xml
<environment id="druid">
    <transactionManager type="JDBC"/>
    <dataSource type="com.softeem.datasource.DruidDataSourceFactory">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.user}"/>
        <property name="password" value="${jdbc.password}"/>
    </dataSource>
</environment>
```

#### 15、MyBatis Plus





#### 16、分页插件



##### 16.1.PageHelper



##### 16.2.MyBatis Plus分页



### 6、反射机制

#### 1、反射的概念

>执行**User** **user** = new User("heyan");的内存结构如下图:

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\new对象时的内存结构图.png)

>**反射机制**:指的是可以于运行时加载、探知、使用编译期间完全未知的类,程序在**运行状态**中，可以**动态加载**一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法。这种动态获取以及动态调用对象方法的功能就是“**Java的反射机制”**。
>
>**Class c = Class.forName("com.hnist.test.User");**
>
>**加载完类之后，在堆内存中，就产生了一个** **Class** **类型的对象（一个类只有一个** **Class** **对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。** 
>
>**反射机制的核心就是“Class对象”**。获得了**Class**对象，就相当于获得了类结构；我们可以通过“**Class对象**”调用这个类的所有属性、所有方法、构造方法；这样，我们就可以动态加载、运行相关的类。
>
>  **反射机制常见操作中设计到的类:**

| 类名          | 类的作用                   |
| ------------- | -------------------------- |
| Class类       | 代表**类**的结构信息       |
| Method类      | 代表**方法**的结构信息     |
| Field类       | 代表**属性**的结构信息     |
| Constructor类 | 代表**构造方法**的结构信息 |
| Annotation类  | 代表**注解**的结构信息     |

#### 2、Class类

>**java.lang.Class类:**十分特殊，用来表示Java中类型。
>
>**1.Class**类的对象包含了某个被加载类的结构。一个被加载的类对应一个**Class**对象。
>**2.当一个**class被加载，或当加载器（class loader）的defineClass()被JVM调用，JVM **便自动产生一个Class** 对象。
>**3.java.lang.Class**类是反射（Reflection）的根源。
>4.针对任何您想动态加载、运行的类，唯有先获得相应的**Class对象。**	
>			1.**对象.getClass()**
>   		    2.**类名.class** **语法**
>			3.**Class.forName("全类名")（最常被使用）**

#### 3、反射机制的常见操作

| 方法                                                         | 描述                           |
| ------------------------------------------------------------ | ------------------------------ |
| public Constructor getConstructor(Class<?>... parameterTypes) | 获取某一个public修饰的构造方法 |
| public Constructor getDeclaredConstructor(Class<?>... parameterTypes) | 获取某一个构造方法             |
| public Constructor<?>[] getDeclaredConstructors() throws SecurityException | 获取所有的构造方法             |
| public Constructor<?>[] getConstructors() throws SecurityException | 获取所有的public修饰的构造方法 |



```java
package reflection_test;
import java.lang.reflect.Constructor;
public class Test02 {
	public static void main(String[] args)  {
		String path = "reflection_test.User";
		try {
            //获得User类的类对象
			Class clazz = Class.forName(path);
			//获得所有构造方法
			Constructor[]  cons = clazz.getDeclaredConstructors();
			for (Constructor constructor : cons) {
				System.out.println(constructor); 
			}
			System.out.println("############");
			//获得无参构造方法
			Constructor  c1 = clazz.getDeclaredConstructor(null);
			System.out.println("无参构造方法："+c1);
			//获得带参构造方法
			Constructor  c2 = clazz.getDeclaredConstructor(int.class,String.class);
			System.out.println("带参int、String的构造方法："+c2);
			System.out.println("**********************");
			//调用构造方法，构造对象
			User user1 = (User) clazz.newInstance(); //调用无参构造方法
			User user2 = (User) c1.newInstance(null); //调用无参构造方法
			User user3 = (User) c2.newInstance(18,"何焱");//调用带参构造方法传入参数
			user1.printName();
			user2.printName();
			user3.printName();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

| 方法                                                        | 描述                                                     |
| ----------------------------------------------------------- | -------------------------------------------------------- |
| public Field getField(String name)                          | 根据属性名获取某个public修饰的字段(包含从父类继承过来的) |
| public Field getDeclaredField(String name)                  | 根据属性名获取某个字段( 不包含 从父类继承过来的)         |
| public Field[] getFields() throws SecurityException         | 获取所有public修饰的字段(包含从父类继承过来的)           |
| public Field[] getDeclaredFields() throws SecurityException | 获取所有字段( 不包含 从父类继承过来的)                   |



```java
package reflection_test;
import java.lang.reflect.Field;
/**
 * 测试反射操作构造属性(Field类)
 */
public class Test03 {
	public static void main(String[] args)  {
		String path = "reflection_test.User";
		try {
			Class clazz = Class.forName(path);
			//获得所有属性
			Field[]  fields = clazz.getDeclaredFields();
			for (Field f : fields) {
				System.out.println("属性："+f); 
			}
			System.out.println("############");
			//获得指定名字的属性
			Field f2 = clazz.getDeclaredField("uname");
			System.out.println("通过uname名字获得Field对象："+f2);
			//通过反射给对象的属性赋值
			User user = (User) clazz.newInstance();
			f2.setAccessible(true);	//跳过安全检查，可以直接访问私有属性和方法
			f2.set(user, "何小七");
			user.printName();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

| 方法                                                         | 描述                                             |
| ------------------------------------------------------------ | ------------------------------------------------ |
| public Method[] getMethods()                                 | 获取所有被public修饰的方法(包括从父类继承过来的) |
| public Method[] getDeclaredMethods()                         | 获取所有的方法( 不包括 从父类继承过来的)         |
| public Method getMethod(String name, Class<?>... parameterTypes) | 获取单个被public修饰的方法(包括从父类继承过来的) |
| public Method getDeclaredMethod(String name, Class<?>... parameterTypes) | 获取单个方法( 不包括  从父类继承过来的)          |
|                                                              |                                                  |

```java
package reflection_test;
import java.lang.reflect.Method;
/**
 * 反射操作普通方法(Method类)
 */
public class Test04 {
	public static void main(String[] args)  {
		String path = "reflection_test.User";
		try {
			Class clazz = Class.forName(path);
			//获得所有方法
			Method[]  methods = clazz.getDeclaredMethods();
			for (Method m : methods) {
				System.out.println("方法："+m); 
			}
			System.out.println("############");
			//获得指定名字和参数，获得方法
			Method method1 = clazz.getDeclaredMethod("setUname", String.class);
			Method method2 = clazz.getDeclaredMethod("printName", null);
			
			//通过反射调用方法
			User user  = (User) clazz.newInstance();
			method1.invoke(user, "何焱");
			method2.invoke(user, null);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

#### 4、Demo

>通过反射机制,对Student类通过有参构造实例化一个对象,然后修改某个属性值,然后调用某个方法
>
>field.**setAccessible**(true)通过反射机制绕过私有检查机制,可以对private,protected修饰的成员变量或方法进行访问
>破坏了Java的封装性,开发中慎用field.setAccessible(true); System.out.println(field.get(student));

```java
public class Demo {
public static void main(String[] args) {
/**
*	通过反射机制,
*	对Student类通过有参构造实例化一个对象,
*	然后修改某个属性值,
*	然后调用某个方
*/
    try {
        Class<?> clazz = Class.forName("com.softeem.entity.Student"); Constructor<?> constructor = clazz.getConstructor(String.class,
        String.class);
        Student student = (Student)constructor.newInstance("木子", "湖北武汉"); System.out.println(student);
        Field[] declaredFields = clazz.getDeclaredFields(); 
        for (Field field : declaredFields) {
            if (field.getModifiers() == Modifier.PUBLIC) {
                //获取public修饰的字段,并输出
                System.out.println(field.get(student));
            } else if (field.getModifiers() == Modifier.PRIVATE) {
                //获取private修饰的字段的get方法
String getMethodString = "get"+field.getName().substring(0,1).toUpperCase()+                    			 field.getName().substring(1);
                Method getMethod = clazz.getMethod(getMethodString);
                //getMethod.invoke(student); == student.getMethod Object result = getMethod.invoke(student);
                System.out.println(field.getName()+"在student对象中的值为:"+result+"即将被修改");
                String setMethodString = "set"+field.getName().substring(0,1).toUpperCase()
                                            +field.getName().substring(1);
                Method setMethod = clazz.getMethod(setMethodString,String.class); 							setMethod.invoke(student,"中华人民共和国"); System.out.println(student);
            }
          }
           } catch (ClassNotFoundException e) { e.printStackTrace();
            } catch (NoSuchMethodException e) { e.printStackTrace();
            } catch (IllegalAccessException e) { e.printStackTrace();
            } catch (InstantiationException e) { e.printStackTrace();
            } catch (InvocationTargetException e) { e.printStackTrace();
            }
        }
}
```



### 7、设计模式

|                          创建型模式                          | 结构性模式                                                   | 行为型模式                                                   |
| :----------------------------------------------------------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 抽象工厂模式<br />工厂方法模式<br />**单例模式**<br />建造者模式<br />原型模式 | 适配器模式<br />桥接模式<br />组合模式<br />装饰模式<br />外观模式<br />享元模式<br />**代理模式** | 责任链模式<br />解释器模式<br />模板方法模式<br />命令模式<br />迭代器模式<br />中介者模式<br />备忘录模式<br />观察者模式<br />状态模式<br />策略模式<br />访问者模式 |
|                         帮助创建对象                         | 帮助组织对象和类                                             | 关注对象之间的交互,相互通信和协作                            |

#### 1、单例模式

>单例模式的**核心作用**是：**保证一个类只有一个实例**，并且提供一个访问该实例的**全局访问点: getInstance()**。 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

##### 1、饿汉式单例模式

>饿汉式单例模式指在单例类加载的时候就初始化需要单例的对象。
>
>饿汉式单例模式的**特点**是： 线程安全，调用效率高。 但是，不能延时加载。
>
>**饿汉式单例模式有三个要点：**
>Ø**将单例对象设置成static**，并且在类初始化时立刻创建对象。形象的比喻成“饿汉式”，意思就是“单例对象马上就创建，立刻加载，不等不拖”。 饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。
>Ø**私有化构造器**。这样就防止外部调用构造器创建本类的多个对象。
>Ø **getInstance()**方法是提供给外部的唯一方法，只能通过这个方法获得本类的对象。

```java
public class SingletonDemo1 {
    //类初始化时，立即加载这个对象（没有延时加载优势）。加载类时，线程安全！
	private static SingletonDemo1 instance = new SingletonDemo1();  
	//构造器私有化，外部不能调用
	private SingletonDemo1(){
	}
	//方法没有同步，调用效率高！
	public static SingletonDemo1 getInstance(){
		return instance;
	}
}
```

##### 2、懒汉式单例模式

>**懒汉式单例模式**:如果单例对象需要占用很大的内存，那么一开始就初始化该对象，会占用大量的内存。此时，有人就想，如果不在类加载的时候初始化，而是在想用的时候再初始化该对象，像懒汉一样，只有用到的时候再初始化，行不行呢？答案是肯定的。
>
>懒汉式单例模式的**特点**：线程安全，调用效率不高。 但是，可以延时加载。
>
>**懒汉式单例模式3个要点：**
>Ø**单例对象作为属性**，一开始为空，不进行创建。只有在**调用getInstance()**方法时才创建。因此，称为“懒汉式”。
>Ø**构造器私有化，防止外部调用。**
>Ø**getInstance()**方法作为外部唯一调用接口。为了解决并发时可能创建多个对象的情况，必须在方法上增加synchronized进行同步处理。因此，也造成了调用效率较低的问题。

```java
public class SingletonDemo2 {
	//类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）。
	private static SingletonDemo2 instance;  
	//私有化构造器
	private SingletonDemo2(){ 
	}
	//方法同步，调用效率低！
	public static  synchronized SingletonDemo2 getInstance(){
		if(instance==null){
			instance = new SingletonDemo2();
		}
		return instance;
	}
}
```

##### 3、静态内部类式单例模式

>**静态内部类式单例模式**
>		–由于加载一个类时，其内部类不会同时被加载。当且仅当内部类的某个静态成员被调用时才会加载该内部类。
>		–并且JVM会保证类加载的线程安全问题，所以利用这个特性我们可以写出兼顾效率与线程安全的优化版本，即静态内部类式单例模式。
>		–静态内部类式单例模式**特点**：线程安全，调用效率高。 而且，可以延时加载。需要延时加载的情况下，这种实现方式，优于“懒汉式”。
>
>**静态内部类式单例模式有三个要点：**
>Ø**外部类没有static属性**，则不会像饿汉式那样立即加载对象。
>**Ø只有真正调用getInstance()**，才会加载静态内部类。加载类时是线程安全的。**instance**是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性。
>**Ø**兼备了并发高效调用和延迟加载的优势！

```java
public class SingletonDemo4 {
	//只有在用到内部类的静态属性时，才会加载，可实现延时加载
      private static class SingletonClassInstance {
            private static final SingletonDemo4  instance = new  SingletonDemo4();
      }
      private SingletonDemo4(){
      }
	//方法没有同步，调用效率高！
      public static SingletonDemo4  getInstance(){
	return SingletonClassInstance.instance;
      }
}
```

#### 2、工厂模式

>工厂模式：实现了**创建者和调用者**的分离。详细分类：**简单工厂模式**、**工厂方法模式**、**抽象工厂模式**。 我们只需要理解**简单工厂模式**即可。
>
>简单工厂模式：用工厂方法代替new操作。将选择实现类、创建对象统一管理和控制。

```java
//接口
public interface Car {
	void run();
}
//奥迪车实现类
public class Audi implements Car {
	@Override
	public void run() {
		System.out.println("奥迪在跑！");
	}
}
//比亚迪车实现类
public class Byd implements Car {
	@Override
	public void run() {
		System.out.println("比亚迪在跑！");
	}
}
//未使用简单工厂模式
public class Client01 {   //调用者
    public static void main(String[] args) {
	Car c1 = new Audi();
	Car c2 = new Byd();
	c1.run();
	c2.run();
    }
}
//使用简单工厂模式
public class CarFactory {
	public static  Car createCar(String brand){
        switch(brand){
            case "Audi":  return new Audi();
            case "Byd" :  return new Byd();
            default : throw new NotSupportedException("no brand");
	    }
}
public class Client02 {   //调用者
	public static void main(String[] args) {
		Car c1 =CarFactory.createCar("Audi");
		Car c2 = CarFactory.createCar("Byd");
		c1.run();
		c2.run();
	}
}
```

#### 3、代理模式

>**代理模式示意图:**

![](C:\Users\六六.nut\Desktop\java软帝vip\md文件图片\代理模式示意图.png)

>**代理模式的核心作用**：
>1.通过代理，控制对对象的访问。
>2.可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即：AOP面向切面编程的核心实现！）
>3.代理模式的应用场景及其广泛，可以说任何一个框架都用到了代理模式。
>
>**代理模式又分了两种：静态代理模式**和**动态代理模式**。所谓静态代理就是要为要代理的类写一个代理类，或者用工具为其生成一个代理类，总之，就是程序运行前就已经存在的编译好的代理类，这样有时候会觉得非常麻烦，也导致程序非常的不灵活；相比静态代理，**动态代理具有更强的灵活性**，因为它不用在我们设计实现的时候就指定某一个代理类来代理哪一个被代理对象，我们可以把这种指定延迟到程序运行时由JVM来实现。

##### 1、静态代理模式

```java
/**
*	@author muzi@softeem.com
*	@description 房屋租赁的接口
* @since 2021/8/26 20:46
*/
public interface HouseServiceInterface {
    /**
    * 出租房子
    */
    void rentHouse();
    }
}
```

```java
/**
*@author muzi@softeem.com
*@description 房东
* @since 2021/8/26 20:47
*/
public class HouseService implements HouseServiceInterface{ 
    @Override
    public void rentHouse() {
    	System.out.println("我出租了一套房子~开心,晚上吃肉.");
    }
}
```

```java
/**
*	@author muzi@softeem.com
*	@description 中介
* @since 2021/8/26 20:48
*/
public class HouseServiceProxy implements HouseServiceInterface{ 
    //目标对象
    private HouseServiceInterface serviceInterface;
    
    public HouseServiceProxy(HouseServiceInterface serviceInterface) { 
        this.serviceInterface = serviceInterface;
    }

    @Override
    public void rentHouse() {
        //前置通知
        System.out.println("先给我中介费,才能签合同~");
        //目标方法的调用
        serviceInterface.rentHouse();
        //后置通知
        System.out.println("到期了,不租了,你把房间打扫干净给我,或者多交100块清洁费");
    }
}
```

```java
public class App {
public static void main(String[] args) {
    HouseServiceInterface houseServiceProxy = new HouseServiceProxy(new HouseService()) ;
    houseServiceProxy.rentHouse();
    }
}
```

##### 2、动态代理模式

###### 2.1.JDK动态代理模式

```java
//动态代理模式的典型用法：定义统一接口
public interface Star {
	void signContract();	//签合同
	void sing();		//唱歌
	void collectMoney();	//收钱
}

//动态代理模式的典型用法：真正的明星类
public class RealStar implements Star {
	@Override
	public void signContract() {
		System.out.println("(明星本人)签字");
	}
	@Override
	public void sing() {
		System.out.println("(明星本人)唱歌");
	}
    @Override
	public void collectMoney() {
		System.out.println("(明星本人)收钱");
	}
}

//动态代理模式的典型用法：流程处理核心类（相当于经纪人制度）
/*
属性realStar就是真正的“明星对象”；invoke()方法是核心处理方法，他的3个参数表示的含义是：
	proxy：表示代理对象
	method：表示代理对象调用的方法对象
	args：表示代理对象调用的方法的参数
在整个invoke()方法中，可以轻松获得proxy代理对象、realStar(被代理的对象)，也可以轻松调用他们的方法。我们根据反射机制做出处理，如果调用的是sing()方法，则由“明星本人realStar”亲自处理。其他方法，则不做处理。
*/
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class StarHandler implements InvocationHandler {	
	Star realStar;	
	public StarHandler(Star realStar) {
		this.realStar = realStar;
	}
	@Override
	public Object invoke(Object proxy, Method method, Object[] args)throws Throwable {
		Object object = null;		
		System.out.println("真正的方法执行前！");		
		//只有唱歌处理，其他方法不做处理
		if(method.getName().equals("sing")){
			object = method.invoke(realStar, args);
		}else{
			System.out.println("代理处理："+method.getName()); 
		}		
		System.out.println("真正的方法执行后！");
		return object;
	}
}

//测试动态代理模式
import java.lang.reflect.Proxy;
public class Client {
	public static void main(String[] args) {
		//将明星注册到处理核心类里面
		Star realStar = new RealStar();
		StarHandler handler = new StarHandler(realStar);	
		//动态创造代理类和代理对象
		Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), 
				new Class[]{Star.class}, handler);
		//生成的代理对象的任何方法里面都是调用了：handler.invoke()方法
		proxy.sing();
		System.out.println("###################################");
		proxy.collectMoney();
	}
}
/*
课后思考：
为什么调用代理对象的方法，最终会进入核心类handler.invoke()方法呢？
Star proxy = (Star)Proxy.newProxyInstance(ClassLoader.
                                 getSystemClassLoader(),new Class[]{Star.class}, handler);
该代码的核心作用是根据Star接口生成代理类，这是由JDK提供的Proxy类动态生成的类。生成的代理类代码结构如下所示：
public  class  StarProxy$ implements Star{
     InvocationHandler  handler;
     public  void   signContract(){
             handler.invoke(this,method对象,参数);
      }
      public  void   sing(){
             handler.invoke(this,method对象,参数);
      }
      public  void   collectMoney(){
             handler.invoke(this,method对象,参数);
      }
}

*/
```

>JDK的动态代理是基于 接口 的,所以目标类一定要实现至少一个接口

###### 2.2.CGLIB动态代理模式

```xml
<!-- cglib需引入依赖 -->
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>
```

```java
public class MyCGLIBProxy implements MethodInterceptor {
    @Override
	public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
		System.out.println("前置通知====来自cglib");
		//不能直接使用目标方法的invoke,会造成栈溢出,因为每次目标方法被执行,都被会该方法拦截
		//Object result =method.invoke(obj, args); 
        Object result = proxy.invokeSuper(obj, args); 
        System.out.println("返回后通知====来自cglib"); 
        return result;
	}
}
```

```java
public class CglibApp {
    public static void main(String[] args) { 
        //
        Enhancer enhancer = new Enhancer();
        //设置父类(目标对象所属类)Class
        enhancer.setSuperclass(HouseService.class);
        //设置回调器
        enhancer.setCallback(new MyCGLIBProxy());
        //生成代理对象
        HouseService proxyInstance = (HouseService)enhancer.create(); 								proxyInstance.rentHouse();
	}
}
```

## 堆 栈 方法区 常量池

## JSON:JavaScript 对象表示法

>## 什么是 JSON ？
>
>- JSON 指的是 JavaScript 对象表示法（**J**ava**S**cript **O**bject **N**otation）
>
>- JSON 是轻量级的文本数据交换格式
>
>- JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。
>
>- JSON 具有自我描述性，更易理解
>
>  ## JSON - 转换为 JavaScript 对象
>
>  JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。
>
>  由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。

### 1.JSON 语法规则

>JSON 语法是 JavaScript 对象表示语法的子集。
>
>- 数据在名称/值对中 --> "name" : "菜鸟教程"
>- 数据由逗号分隔
>- 大括号 **{}** 保存对象
>- 中括号 **[]** 保存数组，数组可以包含多个对象









## 分布式CAP和BASE理论和zookeeper

单体应用(巨石应用)--->集群

## 微服务SpringCloud Alibaba:

## SpringBoot+SpringCloud

## 前端框架:node.js;Vue.js;react

## 文件上传:webUploader

## Nginx(请求转发,负载均衡)反向代理

## Tomcat Session共享-->Spring Session

## 模板引擎

## 验证码captcha

## vailadtor校验

## 内网穿透

# 项目纪实

## 1、SSM项目

### 1、需要学习的新技术

```js
    //修改状态的方法
    function updateDepartmentStatus(depId,status){
        if (status === 1){
            return '<a class="btn btn-xs btn-default department-status-btn" href="#!" title="修改状态" data-id='+depId+' data-status='+status+' data-toggle="tooltip"><i class="mdi mdi-toggle-switch"></i></a>'
        }
        return '<a class="btn btn-xs btn-default department-status-btn" href="#!" title="修改状态" data-id='+depId+' data-status='+status+' data-toggle="tooltip"><i class="mdi mdi-toggle-switch-off"></i></a>'
    }
    //对.department-wrap列表下所有的a标签加点击事件,同时定位到class为department-status-btn的a标签
    $('.department-wrap').on('click','a',function (event){
        console.log(event.currentTarget.dataset)
        var target = $(event.currentTarget);
        //定位到是否是修改状态的a标签
        if (target.hasClass('department-status-btn')){
            console.log('定位到了修改状态的a标签')
            let depId = event.currentTarget.dataset.id;
            let status = event.currentTarget.dataset.status;
            $.ajax({
                url:'/department/toggleDepartmentStatus',
                type:'post',
                cache:false,
                async:true,
                dataType:'json',
                contentType:'application/json;charset=utf-8',
                data:JSON.stringify({
                    depId:depId,
                    status:status
                }),
                success:function (data){
                    console.log(data.success)
                }
            })
        }
    }
```



### 2、核心技术点

#### 2.1.异常捕获事务回滚

>```
>//TODO:如果用到了声明式事务,在catch中捕获异常之后,一定要抛出,否则事务不会回滚
>```

#### 2.2.前后端数据交互

```js
$("#submit").click(function (){
        //定义一个JS的对象
        let department = {};
        //将名称,地址,状态封装到对象里面
        department.name = $('#dep-name').val();
        department.address = $('#dep-address').val();
        department.status = $('input[name="status"][checked]').val();
        //创建FormData对象
        let formData = new FormData();
        //通过formData实现键值对的数据提交
        formData.append("departmentStr",JSON.stringify(department));
        $.ajax({
            url:addDepartmentUrl,
            type:'post',
            dataType:'json',
            cache:false,
            //默认的contentType是text/plain;jquery执行post时,默认为application/x-www-form-urlencoded;
            contentType:false,
            //processData表示会不会序列化data里面的数据,默认true
            processData:false,
            // data:{name:name, address:address,status:status},
            data:formData,
            success:function (data){
                console.log(data)
            }
        })
    })
涉及的核心知识点:
	1.formdata对象发送数据,contentType会变成multipart/form-data`(注意formdata不属于请求体)`
        
    2.contentType:(以下是常用的)
		2.1.默认值为`text/plain`;jquery在执行post请求时，会设置Content-Type为application/x-www-form-urlencoded;而使用原生ajax请求时，如果不显示的设置Content-Type，那么默认是text/plain
		2.2.form表单提交是的类型可以通过表单的属entype设置,一共两种:默认`application/x-www-form-urlencoded`,另一种文件上传有关`multipart/form-data(需要引入依赖)`;application/x-www-from-urlencoded会将表单内的数据转换为键值对&分隔。
			a.当form的action为get时，浏览器将表单数据以键值对(name1=value1)的形式拼接成字符串，然后把这个字符串append到url后面发送数据。
        	b.当form的action为post时，浏览器将form数据封装到formdata中，然后发送server。这个格式不能提交文件。
        2.3.`application/json`
        
	3.processData:在使用jQuery的$.ajax()方法的时候参数processData默认为true(该方法为jQuery独有的),默认情况下会将发送的数据序列化以适应默认的内容类型application/x-www-form-urlencoded,如果想发送不想转换的的信息的时候需要手动将其设置为false在我遇到的是传输的是blob对象的时候就是不需要将传输的数据序列化,一般的还有类似DOM树等

    4.后端如何接收数据:Contentv-Type和Spring-MVC接收参数的关系
		`请求角度:`
        4.1.GET请求:没有请求体,所以它和Content-Type没有关系,所有数据都是以'key=value'的形式通过url传送到后端,当前后端参数名一致时,后端可以不用@RequestParam绑定参数名接收数据,也可以用@RequestParam绑定参数名接收数据;前后端参数名不一致时是不能使用@RequestParam绑定参数名
        4.2.POST请求:提交数据时将数据放在`body中`或`formdata中`,所以数据才会有'Content-Type'之分,比如以FormDat对象提交数据时,他的数据是放在formdata表单中,要使用@RequestParam接收数据;而当application/json一定用@RequestBody接收;
        `注解角度:`
        1. @RequstParam :用以接收是来自`URL`或`formdata`中的参数
        2. @PathVarible :主要用在Restful开发风格中,能够处理URI中的数据
        3. @RequestBody :用来接收`请求体(body)`中的数据。一般用于处理 比如：`application/json`、`application/xml`等类型的数据;特别的,Get请求是没有请求体的,所以使用这个注解不能放在Get请求中
        4. 总结 •在GET请求中，不能使用@RequestBody。 •在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化的配置必须统一。


<%--
            1.	application/x-www-form-urlencoded : 数据用字符串拼接以后发送
            2.	multipart/form-data:不对字符进行编码
            3.	text/plain:将空格转换成+,但是如果数据中存在特殊字符的话,不进行编码
        --%>

```

#### 2.3.后端JSON字符串转对象

```xml
        <!--前后端交流数据,序列化成json的依赖Jackson-->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.13.0</version>
        </dependency>
```

```java
	@ApiOperation(value = "新增部门信息")
    @PostMapping("/insertDepartment")
    @ResponseBody
    public Map<String,Object> insertDepartment(@RequestParam String departmentStr){
        Map<String,Object> map = new HashMap<>();
        //将接收的JSON字符串转换为对象
        ObjectMapper mapper = new ObjectMapper();
        Department department = mapper.readValue(departmentStr, Department.class);
        return map;
    }
```





## 2、遇到的BUG

### 2.1.MyBatis中

#### 2.1.1.org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)

##### 1.bug背景

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>

    <!-- 引入外部配置文件 -->
    <properties resource="jdbc.properties"/>

    <!-- environments:多环境配置的标签 元配置信息default必须存在, 代表使用作为默认加载的环境 -->
    <environments default="development">
        <!--  environment标签代表具体的某个环境配置信息id必须存在,作为当前环境的唯一标志-->
        <environment id="development">
            <transactionManager type="JDBC"/>
            <!--dataSource表示数据源的配置:=>POOLED代表使用连接池 =>UNPOOLED:代表直连-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <mappers>
        <package name="pers.lintao.dao"/>
    </mappers>

</configuration>
```

```properties
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/javaee?useUnicode=true&serverTimezone=Asia/Shanghai&characterEncoding=utf-8&useSSL=false
jdbc.username=root
jdbc.password=root
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="pers.lintao.dao.PersonTableDao">

    <resultMap type="pers.lintao.entity.PersonTable" id="PersonTableMap">
        <result property="id" column="id" jdbcType="INTEGER"/>
        <result property="pname" column="pname" jdbcType="VARCHAR"/>
        <result property="psex" column="psex" jdbcType="VARCHAR"/>
        <result property="idCardId" column="id_card_id" jdbcType="INTEGER"/>
    </resultMap>

    <!--查询单个-->
    <select id="queryById" resultMap="PersonTableMap">
        select
          id, pname, psex, id_card_id
        from person_table
        where id = #{id}
    </select>

</mapper>
```

```java
public interface PersonTableDao {

    /**
     * 通过ID查询单条数据
     *
     * @param id 主键
     * @return 实例对象
     */
    PersonTable queryById(Integer id);

}
```

```java
public class MyBatisUtil {

    private static SqlSession sqlSession;

    public static SqlSession createSqlSession() throws IOException {
        Reader reader = Resources.getResourceAsReader("mybatis-config.xml");
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        sqlSession = sqlSessionFactory.openSession();
        return sqlSession;
    }

    public static void close(SqlSession sqlSession){
        sqlSession.close();
    }
}
```

```java
@Test
    public void testQuery() throws Exception {
        SqlSession sqlSession = null;
        try {
            sqlSession = MyBatisUtil.createSqlSession();
            PersonTableDao mapper = sqlSession.getMapper(PersonTableDao.class);
            PersonTable personTable = mapper.queryById(1);
            System.out.println(personTable);
        } catch (IOException e) {
            e.printStackTrace();
            throw new Exception("创建SqlSession出错异常");
        } finally {
            if (sqlSession != null){
                MyBatisUtil.close(sqlSession);
            }
        }

    }
```

##### 2.bug详情

```java
org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): pers.lintao.dao.PersonTableDao.queryById

	at org.apache.ibatis.binding.MapperMethod$SqlCommand.<init>(MapperMethod.java:235)
	at org.apache.ibatis.binding.MapperMethod.<init>(MapperMethod.java:53)
	at org.apache.ibatis.binding.MapperProxy.lambda$cachedInvoker$0(MapperProxy.java:108)
	at java.util.concurrent.ConcurrentHashMap.computeIfAbsent(ConcurrentHashMap.java:1660)
	at org.apache.ibatis.util.MapUtil.computeIfAbsent(MapUtil.java:36)
	at org.apache.ibatis.binding.MapperProxy.cachedInvoker(MapperProxy.java:95)
	at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:86)
	at com.sun.proxy.$Proxy8.queryById(Unknown Source)
	at QueryTest.testQuery(QueryTest.java:22)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
	at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
	at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
	at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:235)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:54)

```

##### 3.解决bug

```xml
修改前:    
	<mappers>
         <package name="pers.lintao.dao"/>
    </mappers>
修改后:   
    <mappers>
        <mapper resource="mappers/PersonTableDao.xml"/>
    </mappers>
```

##### 4.原因总结

```xml
<mappers>标签中的子标签只有mapper,package两种;并且同时中能出现一种(The content of element type "mappers" must match "(mapper*,package*)"):
    <!-- 1.mapper适用于xml文件和接口配合适用,也可以可以不用配置<mapper class="pers.lintao.dao.PersonTableDao"/>,因为在xml映射件中的namespace的值就是接口的全限定名 -->
	<mappers>
        <mapper resource="mappers/PersonTableDao.xml"/>
    </mappers>
    或者(必须接口配置在前)
    <mappers>
    	<mapper class="pers.lintao.dao.PersonTableDao"/>
        <mapper resource="mappers/PersonTableDao.xml"/>
    </mappers>
    <!-- 2.package配置适用于mybatis注解开发 -->
    <mappers>
        <package name="pers.lintao.dao"/>
    </mappers>
    
```













# 计算机网络

# 计算机操作系统

# 计算机组成原理

# 数据结构和算法
